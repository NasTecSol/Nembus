// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recipes.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (
    organization_id, recipe_code, recipe_name, description, finished_product_id, yield_quantity, yield_uom_id, preparation_steps, preparation_time_min, cooking_time_min, is_active, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, organization_id, recipe_code, recipe_name, description, finished_product_id, yield_quantity, yield_uom_id, preparation_steps, preparation_time_min, cooking_time_min, is_active, metadata, created_at, updated_at
`

type CreateRecipeParams struct {
	OrganizationID     int32          `json:"organization_id"`
	RecipeCode         string         `json:"recipe_code"`
	RecipeName         string         `json:"recipe_name"`
	Description        pgtype.Text    `json:"description"`
	FinishedProductID  pgtype.Int4    `json:"finished_product_id"`
	YieldQuantity      pgtype.Numeric `json:"yield_quantity"`
	YieldUomID         pgtype.Int4    `json:"yield_uom_id"`
	PreparationSteps   pgtype.Text    `json:"preparation_steps"`
	PreparationTimeMin pgtype.Int4    `json:"preparation_time_min"`
	CookingTimeMin     pgtype.Int4    `json:"cooking_time_min"`
	IsActive           pgtype.Bool    `json:"is_active"`
	Metadata           []byte         `json:"metadata"`
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, createRecipe,
		arg.OrganizationID,
		arg.RecipeCode,
		arg.RecipeName,
		arg.Description,
		arg.FinishedProductID,
		arg.YieldQuantity,
		arg.YieldUomID,
		arg.PreparationSteps,
		arg.PreparationTimeMin,
		arg.CookingTimeMin,
		arg.IsActive,
		arg.Metadata,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.RecipeCode,
		&i.RecipeName,
		&i.Description,
		&i.FinishedProductID,
		&i.YieldQuantity,
		&i.YieldUomID,
		&i.PreparationSteps,
		&i.PreparationTimeMin,
		&i.CookingTimeMin,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRecipe = `-- name: DeleteRecipe :exec
DELETE FROM recipes
WHERE id = $1
`

func (q *Queries) DeleteRecipe(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRecipe, id)
	return err
}

const getRecipe = `-- name: GetRecipe :one

SELECT id, organization_id, recipe_code, recipe_name, description, finished_product_id, yield_quantity, yield_uom_id, preparation_steps, preparation_time_min, cooking_time_min, is_active, metadata, created_at, updated_at FROM recipes
WHERE id = $1 LIMIT 1
`

// recipes.sql
func (q *Queries) GetRecipe(ctx context.Context, id int32) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipe, id)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.RecipeCode,
		&i.RecipeName,
		&i.Description,
		&i.FinishedProductID,
		&i.YieldQuantity,
		&i.YieldUomID,
		&i.PreparationSteps,
		&i.PreparationTimeMin,
		&i.CookingTimeMin,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRecipes = `-- name: ListRecipes :many
SELECT id, organization_id, recipe_code, recipe_name, description, finished_product_id, yield_quantity, yield_uom_id, preparation_steps, preparation_time_min, cooking_time_min, is_active, metadata, created_at, updated_at FROM recipes
WHERE organization_id = $1
ORDER BY recipe_name
`

func (q *Queries) ListRecipes(ctx context.Context, organizationID int32) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listRecipes, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.RecipeCode,
			&i.RecipeName,
			&i.Description,
			&i.FinishedProductID,
			&i.YieldQuantity,
			&i.YieldUomID,
			&i.PreparationSteps,
			&i.PreparationTimeMin,
			&i.CookingTimeMin,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecipe = `-- name: UpdateRecipe :one
UPDATE recipes
SET
    recipe_code = $2,
    recipe_name = $3,
    description = $4,
    finished_product_id = $5,
    yield_quantity = $6,
    yield_uom_id = $7,
    preparation_steps = $8,
    preparation_time_min = $9,
    cooking_time_min = $10,
    is_active = $11,
    metadata = $12,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, organization_id, recipe_code, recipe_name, description, finished_product_id, yield_quantity, yield_uom_id, preparation_steps, preparation_time_min, cooking_time_min, is_active, metadata, created_at, updated_at
`

type UpdateRecipeParams struct {
	ID                 int32          `json:"id"`
	RecipeCode         string         `json:"recipe_code"`
	RecipeName         string         `json:"recipe_name"`
	Description        pgtype.Text    `json:"description"`
	FinishedProductID  pgtype.Int4    `json:"finished_product_id"`
	YieldQuantity      pgtype.Numeric `json:"yield_quantity"`
	YieldUomID         pgtype.Int4    `json:"yield_uom_id"`
	PreparationSteps   pgtype.Text    `json:"preparation_steps"`
	PreparationTimeMin pgtype.Int4    `json:"preparation_time_min"`
	CookingTimeMin     pgtype.Int4    `json:"cooking_time_min"`
	IsActive           pgtype.Bool    `json:"is_active"`
	Metadata           []byte         `json:"metadata"`
}

func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, updateRecipe,
		arg.ID,
		arg.RecipeCode,
		arg.RecipeName,
		arg.Description,
		arg.FinishedProductID,
		arg.YieldQuantity,
		arg.YieldUomID,
		arg.PreparationSteps,
		arg.PreparationTimeMin,
		arg.CookingTimeMin,
		arg.IsActive,
		arg.Metadata,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.RecipeCode,
		&i.RecipeName,
		&i.Description,
		&i.FinishedProductID,
		&i.YieldQuantity,
		&i.YieldUomID,
		&i.PreparationSteps,
		&i.PreparationTimeMin,
		&i.CookingTimeMin,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
