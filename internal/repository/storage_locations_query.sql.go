// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: storage_locations_query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createStorageLocation = `-- name: CreateStorageLocation :one
INSERT INTO storage_locations (
    store_id,
    code,
    name,
    location_type,
    parent_location_id,
    is_active,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, store_id, code, name, location_type, parent_location_id, is_active, metadata, created_at
`

type CreateStorageLocationParams struct {
	StoreID          int32       `json:"store_id"`
	Code             string      `json:"code"`
	Name             string      `json:"name"`
	LocationType     pgtype.Text `json:"location_type"`
	ParentLocationID pgtype.Int4 `json:"parent_location_id"`
	IsActive         pgtype.Bool `json:"is_active"`
	Metadata         []byte      `json:"metadata"`
}

func (q *Queries) CreateStorageLocation(ctx context.Context, arg CreateStorageLocationParams) (StorageLocation, error) {
	row := q.db.QueryRow(ctx, createStorageLocation,
		arg.StoreID,
		arg.Code,
		arg.Name,
		arg.LocationType,
		arg.ParentLocationID,
		arg.IsActive,
		arg.Metadata,
	)
	var i StorageLocation
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Code,
		&i.Name,
		&i.LocationType,
		&i.ParentLocationID,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const deleteStorageLocation = `-- name: DeleteStorageLocation :exec
DELETE FROM storage_locations
WHERE id = $1
`

func (q *Queries) DeleteStorageLocation(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteStorageLocation, id)
	return err
}

const getStorageLocation = `-- name: GetStorageLocation :one
SELECT id, store_id, code, name, location_type, parent_location_id, is_active, metadata, created_at FROM storage_locations
WHERE id = $1
`

func (q *Queries) GetStorageLocation(ctx context.Context, id int32) (StorageLocation, error) {
	row := q.db.QueryRow(ctx, getStorageLocation, id)
	var i StorageLocation
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Code,
		&i.Name,
		&i.LocationType,
		&i.ParentLocationID,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getStorageLocationByCode = `-- name: GetStorageLocationByCode :one
SELECT id, store_id, code, name, location_type, parent_location_id, is_active, metadata, created_at FROM storage_locations
WHERE store_id = $1 AND code = $2
`

type GetStorageLocationByCodeParams struct {
	StoreID int32  `json:"store_id"`
	Code    string `json:"code"`
}

func (q *Queries) GetStorageLocationByCode(ctx context.Context, arg GetStorageLocationByCodeParams) (StorageLocation, error) {
	row := q.db.QueryRow(ctx, getStorageLocationByCode, arg.StoreID, arg.Code)
	var i StorageLocation
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Code,
		&i.Name,
		&i.LocationType,
		&i.ParentLocationID,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const listActiveStorageLocationsByStore = `-- name: ListActiveStorageLocationsByStore :many
SELECT id, store_id, code, name, location_type, parent_location_id, is_active, metadata, created_at FROM storage_locations
WHERE store_id = $1 AND is_active = true
ORDER BY code
`

func (q *Queries) ListActiveStorageLocationsByStore(ctx context.Context, storeID int32) ([]StorageLocation, error) {
	rows, err := q.db.Query(ctx, listActiveStorageLocationsByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StorageLocation
	for rows.Next() {
		var i StorageLocation
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Code,
			&i.Name,
			&i.LocationType,
			&i.ParentLocationID,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStorageLocations = `-- name: ListStorageLocations :many
SELECT id, store_id, code, name, location_type, parent_location_id, is_active, metadata, created_at FROM storage_locations
ORDER BY code
`

func (q *Queries) ListStorageLocations(ctx context.Context) ([]StorageLocation, error) {
	rows, err := q.db.Query(ctx, listStorageLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StorageLocation
	for rows.Next() {
		var i StorageLocation
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Code,
			&i.Name,
			&i.LocationType,
			&i.ParentLocationID,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStorageLocationsByParent = `-- name: ListStorageLocationsByParent :many
SELECT id, store_id, code, name, location_type, parent_location_id, is_active, metadata, created_at FROM storage_locations
WHERE parent_location_id = $1
ORDER BY code
`

func (q *Queries) ListStorageLocationsByParent(ctx context.Context, parentLocationID pgtype.Int4) ([]StorageLocation, error) {
	rows, err := q.db.Query(ctx, listStorageLocationsByParent, parentLocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StorageLocation
	for rows.Next() {
		var i StorageLocation
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Code,
			&i.Name,
			&i.LocationType,
			&i.ParentLocationID,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStorageLocationsByStore = `-- name: ListStorageLocationsByStore :many
SELECT id, store_id, code, name, location_type, parent_location_id, is_active, metadata, created_at FROM storage_locations
WHERE store_id = $1
ORDER BY code
`

func (q *Queries) ListStorageLocationsByStore(ctx context.Context, storeID int32) ([]StorageLocation, error) {
	rows, err := q.db.Query(ctx, listStorageLocationsByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StorageLocation
	for rows.Next() {
		var i StorageLocation
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Code,
			&i.Name,
			&i.LocationType,
			&i.ParentLocationID,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStorageLocationsByType = `-- name: ListStorageLocationsByType :many
SELECT id, store_id, code, name, location_type, parent_location_id, is_active, metadata, created_at FROM storage_locations
WHERE store_id = $1 AND location_type = $2
ORDER BY code
`

type ListStorageLocationsByTypeParams struct {
	StoreID      int32       `json:"store_id"`
	LocationType pgtype.Text `json:"location_type"`
}

func (q *Queries) ListStorageLocationsByType(ctx context.Context, arg ListStorageLocationsByTypeParams) ([]StorageLocation, error) {
	rows, err := q.db.Query(ctx, listStorageLocationsByType, arg.StoreID, arg.LocationType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StorageLocation
	for rows.Next() {
		var i StorageLocation
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Code,
			&i.Name,
			&i.LocationType,
			&i.ParentLocationID,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleStorageLocationActive = `-- name: ToggleStorageLocationActive :one
UPDATE storage_locations
SET is_active = $2
WHERE id = $1
RETURNING id, store_id, code, name, location_type, parent_location_id, is_active, metadata, created_at
`

type ToggleStorageLocationActiveParams struct {
	ID       int32       `json:"id"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) ToggleStorageLocationActive(ctx context.Context, arg ToggleStorageLocationActiveParams) (StorageLocation, error) {
	row := q.db.QueryRow(ctx, toggleStorageLocationActive, arg.ID, arg.IsActive)
	var i StorageLocation
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Code,
		&i.Name,
		&i.LocationType,
		&i.ParentLocationID,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const updateStorageLocation = `-- name: UpdateStorageLocation :one
UPDATE storage_locations
SET 
    name = $2,
    location_type = $3,
    parent_location_id = $4,
    is_active = $5,
    metadata = $6
WHERE id = $1
RETURNING id, store_id, code, name, location_type, parent_location_id, is_active, metadata, created_at
`

type UpdateStorageLocationParams struct {
	ID               int32       `json:"id"`
	Name             string      `json:"name"`
	LocationType     pgtype.Text `json:"location_type"`
	ParentLocationID pgtype.Int4 `json:"parent_location_id"`
	IsActive         pgtype.Bool `json:"is_active"`
	Metadata         []byte      `json:"metadata"`
}

func (q *Queries) UpdateStorageLocation(ctx context.Context, arg UpdateStorageLocationParams) (StorageLocation, error) {
	row := q.db.QueryRow(ctx, updateStorageLocation,
		arg.ID,
		arg.Name,
		arg.LocationType,
		arg.ParentLocationID,
		arg.IsActive,
		arg.Metadata,
	)
	var i StorageLocation
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Code,
		&i.Name,
		&i.LocationType,
		&i.ParentLocationID,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}
