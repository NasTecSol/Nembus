// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: uom_query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProductUOMConversion = `-- name: CreateProductUOMConversion :one
INSERT INTO product_uom_conversions (
    product_id,
    from_uom_id,
    to_uom_id,
    conversion_factor,
    is_default,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, product_id, from_uom_id, to_uom_id, conversion_factor, is_default, metadata, created_at
`

type CreateProductUOMConversionParams struct {
	ProductID        int32          `json:"product_id"`
	FromUomID        int32          `json:"from_uom_id"`
	ToUomID          int32          `json:"to_uom_id"`
	ConversionFactor pgtype.Numeric `json:"conversion_factor"`
	IsDefault        pgtype.Bool    `json:"is_default"`
	Metadata         []byte         `json:"metadata"`
}

func (q *Queries) CreateProductUOMConversion(ctx context.Context, arg CreateProductUOMConversionParams) (ProductUomConversion, error) {
	row := q.db.QueryRow(ctx, createProductUOMConversion,
		arg.ProductID,
		arg.FromUomID,
		arg.ToUomID,
		arg.ConversionFactor,
		arg.IsDefault,
		arg.Metadata,
	)
	var i ProductUomConversion
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.FromUomID,
		&i.ToUomID,
		&i.ConversionFactor,
		&i.IsDefault,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createUnitOfMeasure = `-- name: CreateUnitOfMeasure :one
INSERT INTO units_of_measure (
    code,
    name,
    uom_type,
    decimal_places,
    is_active,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, code, name, uom_type, decimal_places, is_active, metadata
`

type CreateUnitOfMeasureParams struct {
	Code          string      `json:"code"`
	Name          string      `json:"name"`
	UomType       pgtype.Text `json:"uom_type"`
	DecimalPlaces pgtype.Int4 `json:"decimal_places"`
	IsActive      pgtype.Bool `json:"is_active"`
	Metadata      []byte      `json:"metadata"`
}

func (q *Queries) CreateUnitOfMeasure(ctx context.Context, arg CreateUnitOfMeasureParams) (UnitsOfMeasure, error) {
	row := q.db.QueryRow(ctx, createUnitOfMeasure,
		arg.Code,
		arg.Name,
		arg.UomType,
		arg.DecimalPlaces,
		arg.IsActive,
		arg.Metadata,
	)
	var i UnitsOfMeasure
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.UomType,
		&i.DecimalPlaces,
		&i.IsActive,
		&i.Metadata,
	)
	return i, err
}

const deleteProductUOMConversion = `-- name: DeleteProductUOMConversion :exec
DELETE FROM product_uom_conversions
WHERE id = $1
`

func (q *Queries) DeleteProductUOMConversion(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProductUOMConversion, id)
	return err
}

const deleteUnitOfMeasure = `-- name: DeleteUnitOfMeasure :exec
DELETE FROM units_of_measure
WHERE id = $1
`

func (q *Queries) DeleteUnitOfMeasure(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUnitOfMeasure, id)
	return err
}

const getProductUOMConversion = `-- name: GetProductUOMConversion :one
SELECT id, product_id, from_uom_id, to_uom_id, conversion_factor, is_default, metadata, created_at FROM product_uom_conversions
WHERE product_id = $1 AND from_uom_id = $2 AND to_uom_id = $3
`

type GetProductUOMConversionParams struct {
	ProductID int32 `json:"product_id"`
	FromUomID int32 `json:"from_uom_id"`
	ToUomID   int32 `json:"to_uom_id"`
}

func (q *Queries) GetProductUOMConversion(ctx context.Context, arg GetProductUOMConversionParams) (ProductUomConversion, error) {
	row := q.db.QueryRow(ctx, getProductUOMConversion, arg.ProductID, arg.FromUomID, arg.ToUomID)
	var i ProductUomConversion
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.FromUomID,
		&i.ToUomID,
		&i.ConversionFactor,
		&i.IsDefault,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getUnitOfMeasure = `-- name: GetUnitOfMeasure :one
SELECT id, code, name, uom_type, decimal_places, is_active, metadata FROM units_of_measure
WHERE id = $1
`

func (q *Queries) GetUnitOfMeasure(ctx context.Context, id int32) (UnitsOfMeasure, error) {
	row := q.db.QueryRow(ctx, getUnitOfMeasure, id)
	var i UnitsOfMeasure
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.UomType,
		&i.DecimalPlaces,
		&i.IsActive,
		&i.Metadata,
	)
	return i, err
}

const getUnitOfMeasureByCode = `-- name: GetUnitOfMeasureByCode :one
SELECT id, code, name, uom_type, decimal_places, is_active, metadata FROM units_of_measure
WHERE code = $1
`

func (q *Queries) GetUnitOfMeasureByCode(ctx context.Context, code string) (UnitsOfMeasure, error) {
	row := q.db.QueryRow(ctx, getUnitOfMeasureByCode, code)
	var i UnitsOfMeasure
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.UomType,
		&i.DecimalPlaces,
		&i.IsActive,
		&i.Metadata,
	)
	return i, err
}

const listActiveUnitsOfMeasure = `-- name: ListActiveUnitsOfMeasure :many
SELECT id, code, name, uom_type, decimal_places, is_active, metadata FROM units_of_measure
WHERE is_active = true
ORDER BY name
`

func (q *Queries) ListActiveUnitsOfMeasure(ctx context.Context) ([]UnitsOfMeasure, error) {
	rows, err := q.db.Query(ctx, listActiveUnitsOfMeasure)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnitsOfMeasure
	for rows.Next() {
		var i UnitsOfMeasure
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.UomType,
			&i.DecimalPlaces,
			&i.IsActive,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductUOMConversions = `-- name: ListProductUOMConversions :many
SELECT id, product_id, from_uom_id, to_uom_id, conversion_factor, is_default, metadata, created_at FROM product_uom_conversions
WHERE product_id = $1
ORDER BY from_uom_id, to_uom_id
`

func (q *Queries) ListProductUOMConversions(ctx context.Context, productID int32) ([]ProductUomConversion, error) {
	rows, err := q.db.Query(ctx, listProductUOMConversions, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductUomConversion
	for rows.Next() {
		var i ProductUomConversion
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.FromUomID,
			&i.ToUomID,
			&i.ConversionFactor,
			&i.IsDefault,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnitsByType = `-- name: ListUnitsByType :many
SELECT id, code, name, uom_type, decimal_places, is_active, metadata FROM units_of_measure
WHERE uom_type = $1
ORDER BY name
`

func (q *Queries) ListUnitsByType(ctx context.Context, uomType pgtype.Text) ([]UnitsOfMeasure, error) {
	rows, err := q.db.Query(ctx, listUnitsByType, uomType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnitsOfMeasure
	for rows.Next() {
		var i UnitsOfMeasure
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.UomType,
			&i.DecimalPlaces,
			&i.IsActive,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnitsOfMeasure = `-- name: ListUnitsOfMeasure :many
SELECT id, code, name, uom_type, decimal_places, is_active, metadata FROM units_of_measure
ORDER BY name
`

func (q *Queries) ListUnitsOfMeasure(ctx context.Context) ([]UnitsOfMeasure, error) {
	rows, err := q.db.Query(ctx, listUnitsOfMeasure)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnitsOfMeasure
	for rows.Next() {
		var i UnitsOfMeasure
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.UomType,
			&i.DecimalPlaces,
			&i.IsActive,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductUOMConversion = `-- name: UpdateProductUOMConversion :one
UPDATE product_uom_conversions
SET 
    conversion_factor = $2,
    is_default = $3,
    metadata = $4
WHERE id = $1
RETURNING id, product_id, from_uom_id, to_uom_id, conversion_factor, is_default, metadata, created_at
`

type UpdateProductUOMConversionParams struct {
	ID               int32          `json:"id"`
	ConversionFactor pgtype.Numeric `json:"conversion_factor"`
	IsDefault        pgtype.Bool    `json:"is_default"`
	Metadata         []byte         `json:"metadata"`
}

func (q *Queries) UpdateProductUOMConversion(ctx context.Context, arg UpdateProductUOMConversionParams) (ProductUomConversion, error) {
	row := q.db.QueryRow(ctx, updateProductUOMConversion,
		arg.ID,
		arg.ConversionFactor,
		arg.IsDefault,
		arg.Metadata,
	)
	var i ProductUomConversion
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.FromUomID,
		&i.ToUomID,
		&i.ConversionFactor,
		&i.IsDefault,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const updateUnitOfMeasure = `-- name: UpdateUnitOfMeasure :one
UPDATE units_of_measure
SET 
    name = $2,
    uom_type = $3,
    decimal_places = $4,
    is_active = $5,
    metadata = $6
WHERE id = $1
RETURNING id, code, name, uom_type, decimal_places, is_active, metadata
`

type UpdateUnitOfMeasureParams struct {
	ID            int32       `json:"id"`
	Name          string      `json:"name"`
	UomType       pgtype.Text `json:"uom_type"`
	DecimalPlaces pgtype.Int4 `json:"decimal_places"`
	IsActive      pgtype.Bool `json:"is_active"`
	Metadata      []byte      `json:"metadata"`
}

func (q *Queries) UpdateUnitOfMeasure(ctx context.Context, arg UpdateUnitOfMeasureParams) (UnitsOfMeasure, error) {
	row := q.db.QueryRow(ctx, updateUnitOfMeasure,
		arg.ID,
		arg.Name,
		arg.UomType,
		arg.DecimalPlaces,
		arg.IsActive,
		arg.Metadata,
	)
	var i UnitsOfMeasure
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.UomType,
		&i.DecimalPlaces,
		&i.IsActive,
		&i.Metadata,
	)
	return i, err
}
