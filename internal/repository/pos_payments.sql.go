// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pos_payments.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPaymentToTransaction = `-- name: AddPaymentToTransaction :exec
INSERT INTO pos_payments (
    transaction_id,
    payment_method,
    amount,
    reference_number,
    metadata
) VALUES ($1, $2, $3, $4, $5)
`

type AddPaymentToTransactionParams struct {
	TransactionID   int32          `json:"transaction_id"`
	PaymentMethod   string         `json:"payment_method"`
	Amount          pgtype.Numeric `json:"amount"`
	ReferenceNumber pgtype.Text    `json:"reference_number"`
	Metadata        []byte         `json:"metadata"`
}

func (q *Queries) AddPaymentToTransaction(ctx context.Context, arg AddPaymentToTransactionParams) error {
	_, err := q.db.Exec(ctx, addPaymentToTransaction,
		arg.TransactionID,
		arg.PaymentMethod,
		arg.Amount,
		arg.ReferenceNumber,
		arg.Metadata,
	)
	return err
}

const getPaymentsForTransaction = `-- name: GetPaymentsForTransaction :many
SELECT 
    payment_method,
    amount,
    reference_number,
    created_at
FROM pos_payments
WHERE transaction_id = $1
ORDER BY created_at
`

type GetPaymentsForTransactionRow struct {
	PaymentMethod   string           `json:"payment_method"`
	Amount          pgtype.Numeric   `json:"amount"`
	ReferenceNumber pgtype.Text      `json:"reference_number"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetPaymentsForTransaction(ctx context.Context, transactionID int32) ([]GetPaymentsForTransactionRow, error) {
	rows, err := q.db.Query(ctx, getPaymentsForTransaction, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaymentsForTransactionRow
	for rows.Next() {
		var i GetPaymentsForTransactionRow
		if err := rows.Scan(
			&i.PaymentMethod,
			&i.Amount,
			&i.ReferenceNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionPaymentSummary = `-- name: GetTransactionPaymentSummary :one
SELECT 
    COALESCE(SUM(amount), 0) AS total_paid,
    json_agg(
        json_build_object(
            'method', payment_method,
            'amount', amount,
            'ref', reference_number
        )
    ) AS payment_details
FROM pos_payments
WHERE transaction_id = $1
`

type GetTransactionPaymentSummaryRow struct {
	TotalPaid      interface{} `json:"total_paid"`
	PaymentDetails []byte      `json:"payment_details"`
}

func (q *Queries) GetTransactionPaymentSummary(ctx context.Context, transactionID int32) (GetTransactionPaymentSummaryRow, error) {
	row := q.db.QueryRow(ctx, getTransactionPaymentSummary, transactionID)
	var i GetTransactionPaymentSummaryRow
	err := row.Scan(&i.TotalPaid, &i.PaymentDetails)
	return i, err
}
