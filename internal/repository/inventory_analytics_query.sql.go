// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory_analytics_query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInventoryAnalytics = `-- name: CreateInventoryAnalytics :one
INSERT INTO inventory_analytics (
    organization_id,
    store_id,
    product_id,
    category_id,
    date,
    month,
    quarter,
    year,
    opening_stock,
    closing_stock,
    average_stock,
    stock_value,
    receipts,
    issues,
    adjustments,
    stock_turnover_ratio,
    days_of_inventory,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18
) RETURNING id, organization_id, store_id, product_id, category_id, date, month, quarter, year, opening_stock, stock_in, stock_out, closing_stock, stock_value, average_stock, receipts, issues, adjustments, turnover_rate, stock_turnover_ratio, days_in_stock, days_of_inventory, low_stock_alerts, out_of_stock_days, metadata, created_at, updated_at
`

type CreateInventoryAnalyticsParams struct {
	OrganizationID     int32          `json:"organization_id"`
	StoreID            pgtype.Int4    `json:"store_id"`
	ProductID          pgtype.Int4    `json:"product_id"`
	CategoryID         pgtype.Int4    `json:"category_id"`
	Date               pgtype.Date    `json:"date"`
	Month              pgtype.Int4    `json:"month"`
	Quarter            pgtype.Int4    `json:"quarter"`
	Year               pgtype.Int4    `json:"year"`
	OpeningStock       pgtype.Numeric `json:"opening_stock"`
	ClosingStock       pgtype.Numeric `json:"closing_stock"`
	AverageStock       pgtype.Numeric `json:"average_stock"`
	StockValue         pgtype.Numeric `json:"stock_value"`
	Receipts           pgtype.Numeric `json:"receipts"`
	Issues             pgtype.Numeric `json:"issues"`
	Adjustments        pgtype.Numeric `json:"adjustments"`
	StockTurnoverRatio pgtype.Numeric `json:"stock_turnover_ratio"`
	DaysOfInventory    pgtype.Numeric `json:"days_of_inventory"`
	Metadata           []byte         `json:"metadata"`
}

func (q *Queries) CreateInventoryAnalytics(ctx context.Context, arg CreateInventoryAnalyticsParams) (InventoryAnalytic, error) {
	row := q.db.QueryRow(ctx, createInventoryAnalytics,
		arg.OrganizationID,
		arg.StoreID,
		arg.ProductID,
		arg.CategoryID,
		arg.Date,
		arg.Month,
		arg.Quarter,
		arg.Year,
		arg.OpeningStock,
		arg.ClosingStock,
		arg.AverageStock,
		arg.StockValue,
		arg.Receipts,
		arg.Issues,
		arg.Adjustments,
		arg.StockTurnoverRatio,
		arg.DaysOfInventory,
		arg.Metadata,
	)
	var i InventoryAnalytic
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.StoreID,
		&i.ProductID,
		&i.CategoryID,
		&i.Date,
		&i.Month,
		&i.Quarter,
		&i.Year,
		&i.OpeningStock,
		&i.StockIn,
		&i.StockOut,
		&i.ClosingStock,
		&i.StockValue,
		&i.AverageStock,
		&i.Receipts,
		&i.Issues,
		&i.Adjustments,
		&i.TurnoverRate,
		&i.StockTurnoverRatio,
		&i.DaysInStock,
		&i.DaysOfInventory,
		&i.LowStockAlerts,
		&i.OutOfStockDays,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInventoryAnalytics = `-- name: DeleteInventoryAnalytics :exec
DELETE FROM inventory_analytics
WHERE id = $1
`

func (q *Queries) DeleteInventoryAnalytics(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteInventoryAnalytics, id)
	return err
}

const getFastMovingProducts = `-- name: GetFastMovingProducts :many
SELECT 
    product_id,
    AVG(stock_turnover_ratio) AS avg_turnover_ratio,
    AVG(days_of_inventory) AS avg_days_of_inventory,
    SUM(issues) AS total_issues
FROM inventory_analytics
WHERE organization_id = $1
  AND date >= $2 AND date <= $3
  AND product_id IS NOT NULL
GROUP BY product_id
HAVING AVG(stock_turnover_ratio) > $4
ORDER BY avg_turnover_ratio DESC
LIMIT $5
`

type GetFastMovingProductsParams struct {
	OrganizationID     int32          `json:"organization_id"`
	Date               pgtype.Date    `json:"date"`
	Date_2             pgtype.Date    `json:"date_2"`
	StockTurnoverRatio pgtype.Numeric `json:"stock_turnover_ratio"`
	Limit              int32          `json:"limit"`
}

type GetFastMovingProductsRow struct {
	ProductID          pgtype.Int4 `json:"product_id"`
	AvgTurnoverRatio   float64     `json:"avg_turnover_ratio"`
	AvgDaysOfInventory float64     `json:"avg_days_of_inventory"`
	TotalIssues        int64       `json:"total_issues"`
}

func (q *Queries) GetFastMovingProducts(ctx context.Context, arg GetFastMovingProductsParams) ([]GetFastMovingProductsRow, error) {
	rows, err := q.db.Query(ctx, getFastMovingProducts,
		arg.OrganizationID,
		arg.Date,
		arg.Date_2,
		arg.StockTurnoverRatio,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFastMovingProductsRow
	for rows.Next() {
		var i GetFastMovingProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.AvgTurnoverRatio,
			&i.AvgDaysOfInventory,
			&i.TotalIssues,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryAnalytics = `-- name: GetInventoryAnalytics :one
SELECT id, organization_id, store_id, product_id, category_id, date, month, quarter, year, opening_stock, stock_in, stock_out, closing_stock, stock_value, average_stock, receipts, issues, adjustments, turnover_rate, stock_turnover_ratio, days_in_stock, days_of_inventory, low_stock_alerts, out_of_stock_days, metadata, created_at, updated_at FROM inventory_analytics
WHERE id = $1
`

func (q *Queries) GetInventoryAnalytics(ctx context.Context, id int32) (InventoryAnalytic, error) {
	row := q.db.QueryRow(ctx, getInventoryAnalytics, id)
	var i InventoryAnalytic
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.StoreID,
		&i.ProductID,
		&i.CategoryID,
		&i.Date,
		&i.Month,
		&i.Quarter,
		&i.Year,
		&i.OpeningStock,
		&i.StockIn,
		&i.StockOut,
		&i.ClosingStock,
		&i.StockValue,
		&i.AverageStock,
		&i.Receipts,
		&i.Issues,
		&i.Adjustments,
		&i.TurnoverRate,
		&i.StockTurnoverRatio,
		&i.DaysInStock,
		&i.DaysOfInventory,
		&i.LowStockAlerts,
		&i.OutOfStockDays,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryAnalyticsByDateRange = `-- name: GetInventoryAnalyticsByDateRange :many
SELECT id, organization_id, store_id, product_id, category_id, date, month, quarter, year, opening_stock, stock_in, stock_out, closing_stock, stock_value, average_stock, receipts, issues, adjustments, turnover_rate, stock_turnover_ratio, days_in_stock, days_of_inventory, low_stock_alerts, out_of_stock_days, metadata, created_at, updated_at FROM inventory_analytics
WHERE organization_id = $1
  AND date >= $2 AND date <= $3
ORDER BY date DESC
`

type GetInventoryAnalyticsByDateRangeParams struct {
	OrganizationID int32       `json:"organization_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

func (q *Queries) GetInventoryAnalyticsByDateRange(ctx context.Context, arg GetInventoryAnalyticsByDateRangeParams) ([]InventoryAnalytic, error) {
	rows, err := q.db.Query(ctx, getInventoryAnalyticsByDateRange, arg.OrganizationID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryAnalytic
	for rows.Next() {
		var i InventoryAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.ProductID,
			&i.CategoryID,
			&i.Date,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.OpeningStock,
			&i.StockIn,
			&i.StockOut,
			&i.ClosingStock,
			&i.StockValue,
			&i.AverageStock,
			&i.Receipts,
			&i.Issues,
			&i.Adjustments,
			&i.TurnoverRate,
			&i.StockTurnoverRatio,
			&i.DaysInStock,
			&i.DaysOfInventory,
			&i.LowStockAlerts,
			&i.OutOfStockDays,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryAnalyticsByProduct = `-- name: GetInventoryAnalyticsByProduct :many
SELECT id, organization_id, store_id, product_id, category_id, date, month, quarter, year, opening_stock, stock_in, stock_out, closing_stock, stock_value, average_stock, receipts, issues, adjustments, turnover_rate, stock_turnover_ratio, days_in_stock, days_of_inventory, low_stock_alerts, out_of_stock_days, metadata, created_at, updated_at FROM inventory_analytics
WHERE organization_id = $1 AND product_id = $2
  AND date >= $3 AND date <= $4
ORDER BY date DESC
`

type GetInventoryAnalyticsByProductParams struct {
	OrganizationID int32       `json:"organization_id"`
	ProductID      pgtype.Int4 `json:"product_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

func (q *Queries) GetInventoryAnalyticsByProduct(ctx context.Context, arg GetInventoryAnalyticsByProductParams) ([]InventoryAnalytic, error) {
	rows, err := q.db.Query(ctx, getInventoryAnalyticsByProduct,
		arg.OrganizationID,
		arg.ProductID,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryAnalytic
	for rows.Next() {
		var i InventoryAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.ProductID,
			&i.CategoryID,
			&i.Date,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.OpeningStock,
			&i.StockIn,
			&i.StockOut,
			&i.ClosingStock,
			&i.StockValue,
			&i.AverageStock,
			&i.Receipts,
			&i.Issues,
			&i.Adjustments,
			&i.TurnoverRate,
			&i.StockTurnoverRatio,
			&i.DaysInStock,
			&i.DaysOfInventory,
			&i.LowStockAlerts,
			&i.OutOfStockDays,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryAnalyticsByStore = `-- name: GetInventoryAnalyticsByStore :many
SELECT id, organization_id, store_id, product_id, category_id, date, month, quarter, year, opening_stock, stock_in, stock_out, closing_stock, stock_value, average_stock, receipts, issues, adjustments, turnover_rate, stock_turnover_ratio, days_in_stock, days_of_inventory, low_stock_alerts, out_of_stock_days, metadata, created_at, updated_at FROM inventory_analytics
WHERE organization_id = $1 AND store_id = $2
  AND date >= $3 AND date <= $4
ORDER BY date DESC
`

type GetInventoryAnalyticsByStoreParams struct {
	OrganizationID int32       `json:"organization_id"`
	StoreID        pgtype.Int4 `json:"store_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

func (q *Queries) GetInventoryAnalyticsByStore(ctx context.Context, arg GetInventoryAnalyticsByStoreParams) ([]InventoryAnalytic, error) {
	rows, err := q.db.Query(ctx, getInventoryAnalyticsByStore,
		arg.OrganizationID,
		arg.StoreID,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryAnalytic
	for rows.Next() {
		var i InventoryAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.ProductID,
			&i.CategoryID,
			&i.Date,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.OpeningStock,
			&i.StockIn,
			&i.StockOut,
			&i.ClosingStock,
			&i.StockValue,
			&i.AverageStock,
			&i.Receipts,
			&i.Issues,
			&i.Adjustments,
			&i.TurnoverRate,
			&i.StockTurnoverRatio,
			&i.DaysInStock,
			&i.DaysOfInventory,
			&i.LowStockAlerts,
			&i.OutOfStockDays,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventorySummaryByMonth = `-- name: GetInventorySummaryByMonth :many
SELECT 
    year,
    month,
    SUM(closing_stock) AS total_closing_stock,
    SUM(stock_value) AS total_stock_value,
    SUM(receipts) AS total_receipts,
    SUM(issues) AS total_issues
FROM inventory_analytics
WHERE organization_id = $1
  AND date >= $2 AND date <= $3
GROUP BY year, month
ORDER BY year DESC, month DESC
`

type GetInventorySummaryByMonthParams struct {
	OrganizationID int32       `json:"organization_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

type GetInventorySummaryByMonthRow struct {
	Year              pgtype.Int4 `json:"year"`
	Month             pgtype.Int4 `json:"month"`
	TotalClosingStock int64       `json:"total_closing_stock"`
	TotalStockValue   int64       `json:"total_stock_value"`
	TotalReceipts     int64       `json:"total_receipts"`
	TotalIssues       int64       `json:"total_issues"`
}

func (q *Queries) GetInventorySummaryByMonth(ctx context.Context, arg GetInventorySummaryByMonthParams) ([]GetInventorySummaryByMonthRow, error) {
	rows, err := q.db.Query(ctx, getInventorySummaryByMonth, arg.OrganizationID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInventorySummaryByMonthRow
	for rows.Next() {
		var i GetInventorySummaryByMonthRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalClosingStock,
			&i.TotalStockValue,
			&i.TotalReceipts,
			&i.TotalIssues,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlowMovingProducts = `-- name: GetSlowMovingProducts :many
SELECT 
    product_id,
    AVG(stock_turnover_ratio) AS avg_turnover_ratio,
    AVG(days_of_inventory) AS avg_days_of_inventory,
    SUM(closing_stock) AS total_stock
FROM inventory_analytics
WHERE organization_id = $1
  AND date >= $2 AND date <= $3
  AND product_id IS NOT NULL
GROUP BY product_id
HAVING AVG(stock_turnover_ratio) < $4
ORDER BY avg_days_of_inventory DESC
LIMIT $5
`

type GetSlowMovingProductsParams struct {
	OrganizationID     int32          `json:"organization_id"`
	Date               pgtype.Date    `json:"date"`
	Date_2             pgtype.Date    `json:"date_2"`
	StockTurnoverRatio pgtype.Numeric `json:"stock_turnover_ratio"`
	Limit              int32          `json:"limit"`
}

type GetSlowMovingProductsRow struct {
	ProductID          pgtype.Int4 `json:"product_id"`
	AvgTurnoverRatio   float64     `json:"avg_turnover_ratio"`
	AvgDaysOfInventory float64     `json:"avg_days_of_inventory"`
	TotalStock         int64       `json:"total_stock"`
}

func (q *Queries) GetSlowMovingProducts(ctx context.Context, arg GetSlowMovingProductsParams) ([]GetSlowMovingProductsRow, error) {
	rows, err := q.db.Query(ctx, getSlowMovingProducts,
		arg.OrganizationID,
		arg.Date,
		arg.Date_2,
		arg.StockTurnoverRatio,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSlowMovingProductsRow
	for rows.Next() {
		var i GetSlowMovingProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.AvgTurnoverRatio,
			&i.AvgDaysOfInventory,
			&i.TotalStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryAnalytics = `-- name: ListInventoryAnalytics :many
SELECT id, organization_id, store_id, product_id, category_id, date, month, quarter, year, opening_stock, stock_in, stock_out, closing_stock, stock_value, average_stock, receipts, issues, adjustments, turnover_rate, stock_turnover_ratio, days_in_stock, days_of_inventory, low_stock_alerts, out_of_stock_days, metadata, created_at, updated_at FROM inventory_analytics
WHERE organization_id = $1
ORDER BY date DESC
LIMIT $2 OFFSET $3
`

type ListInventoryAnalyticsParams struct {
	OrganizationID int32 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

func (q *Queries) ListInventoryAnalytics(ctx context.Context, arg ListInventoryAnalyticsParams) ([]InventoryAnalytic, error) {
	rows, err := q.db.Query(ctx, listInventoryAnalytics, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryAnalytic
	for rows.Next() {
		var i InventoryAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.ProductID,
			&i.CategoryID,
			&i.Date,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.OpeningStock,
			&i.StockIn,
			&i.StockOut,
			&i.ClosingStock,
			&i.StockValue,
			&i.AverageStock,
			&i.Receipts,
			&i.Issues,
			&i.Adjustments,
			&i.TurnoverRate,
			&i.StockTurnoverRatio,
			&i.DaysInStock,
			&i.DaysOfInventory,
			&i.LowStockAlerts,
			&i.OutOfStockDays,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventoryAnalytics = `-- name: UpdateInventoryAnalytics :one
UPDATE inventory_analytics
SET 
    opening_stock = $2,
    closing_stock = $3,
    average_stock = $4,
    stock_value = $5,
    receipts = $6,
    issues = $7,
    adjustments = $8,
    stock_turnover_ratio = $9,
    days_of_inventory = $10,
    metadata = $11
WHERE id = $1
RETURNING id, organization_id, store_id, product_id, category_id, date, month, quarter, year, opening_stock, stock_in, stock_out, closing_stock, stock_value, average_stock, receipts, issues, adjustments, turnover_rate, stock_turnover_ratio, days_in_stock, days_of_inventory, low_stock_alerts, out_of_stock_days, metadata, created_at, updated_at
`

type UpdateInventoryAnalyticsParams struct {
	ID                 int32          `json:"id"`
	OpeningStock       pgtype.Numeric `json:"opening_stock"`
	ClosingStock       pgtype.Numeric `json:"closing_stock"`
	AverageStock       pgtype.Numeric `json:"average_stock"`
	StockValue         pgtype.Numeric `json:"stock_value"`
	Receipts           pgtype.Numeric `json:"receipts"`
	Issues             pgtype.Numeric `json:"issues"`
	Adjustments        pgtype.Numeric `json:"adjustments"`
	StockTurnoverRatio pgtype.Numeric `json:"stock_turnover_ratio"`
	DaysOfInventory    pgtype.Numeric `json:"days_of_inventory"`
	Metadata           []byte         `json:"metadata"`
}

func (q *Queries) UpdateInventoryAnalytics(ctx context.Context, arg UpdateInventoryAnalyticsParams) (InventoryAnalytic, error) {
	row := q.db.QueryRow(ctx, updateInventoryAnalytics,
		arg.ID,
		arg.OpeningStock,
		arg.ClosingStock,
		arg.AverageStock,
		arg.StockValue,
		arg.Receipts,
		arg.Issues,
		arg.Adjustments,
		arg.StockTurnoverRatio,
		arg.DaysOfInventory,
		arg.Metadata,
	)
	var i InventoryAnalytic
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.StoreID,
		&i.ProductID,
		&i.CategoryID,
		&i.Date,
		&i.Month,
		&i.Quarter,
		&i.Year,
		&i.OpeningStock,
		&i.StockIn,
		&i.StockOut,
		&i.ClosingStock,
		&i.StockValue,
		&i.AverageStock,
		&i.Receipts,
		&i.Issues,
		&i.Adjustments,
		&i.TurnoverRate,
		&i.StockTurnoverRatio,
		&i.DaysInStock,
		&i.DaysOfInventory,
		&i.LowStockAlerts,
		&i.OutOfStockDays,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
