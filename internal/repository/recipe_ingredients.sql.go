// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recipe_ingredients.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRecipeIngredient = `-- name: CreateRecipeIngredient :one
INSERT INTO recipe_ingredients (
    recipe_id, product_id, product_variant_id, quantity, uom_id, is_optional, is_byproduct, line_number, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, recipe_id, product_id, product_variant_id, quantity, uom_id, is_optional, is_byproduct, line_number, metadata, created_at
`

type CreateRecipeIngredientParams struct {
	RecipeID         int32          `json:"recipe_id"`
	ProductID        int32          `json:"product_id"`
	ProductVariantID pgtype.Int4    `json:"product_variant_id"`
	Quantity         pgtype.Numeric `json:"quantity"`
	UomID            pgtype.Int4    `json:"uom_id"`
	IsOptional       pgtype.Bool    `json:"is_optional"`
	IsByproduct      pgtype.Bool    `json:"is_byproduct"`
	LineNumber       pgtype.Int4    `json:"line_number"`
	Metadata         []byte         `json:"metadata"`
}

func (q *Queries) CreateRecipeIngredient(ctx context.Context, arg CreateRecipeIngredientParams) (RecipeIngredient, error) {
	row := q.db.QueryRow(ctx, createRecipeIngredient,
		arg.RecipeID,
		arg.ProductID,
		arg.ProductVariantID,
		arg.Quantity,
		arg.UomID,
		arg.IsOptional,
		arg.IsByproduct,
		arg.LineNumber,
		arg.Metadata,
	)
	var i RecipeIngredient
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.Quantity,
		&i.UomID,
		&i.IsOptional,
		&i.IsByproduct,
		&i.LineNumber,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRecipeIngredient = `-- name: DeleteRecipeIngredient :exec
DELETE FROM recipe_ingredients
WHERE id = $1
`

func (q *Queries) DeleteRecipeIngredient(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRecipeIngredient, id)
	return err
}

const getRecipeIngredient = `-- name: GetRecipeIngredient :one

SELECT id, recipe_id, product_id, product_variant_id, quantity, uom_id, is_optional, is_byproduct, line_number, metadata, created_at FROM recipe_ingredients
WHERE id = $1 LIMIT 1
`

// recipe_ingredients.sql
func (q *Queries) GetRecipeIngredient(ctx context.Context, id int32) (RecipeIngredient, error) {
	row := q.db.QueryRow(ctx, getRecipeIngredient, id)
	var i RecipeIngredient
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.Quantity,
		&i.UomID,
		&i.IsOptional,
		&i.IsByproduct,
		&i.LineNumber,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const listRecipeIngredients = `-- name: ListRecipeIngredients :many
SELECT id, recipe_id, product_id, product_variant_id, quantity, uom_id, is_optional, is_byproduct, line_number, metadata, created_at FROM recipe_ingredients
WHERE recipe_id = $1
ORDER BY line_number
`

func (q *Queries) ListRecipeIngredients(ctx context.Context, recipeID int32) ([]RecipeIngredient, error) {
	rows, err := q.db.Query(ctx, listRecipeIngredients, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeIngredient
	for rows.Next() {
		var i RecipeIngredient
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.Quantity,
			&i.UomID,
			&i.IsOptional,
			&i.IsByproduct,
			&i.LineNumber,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecipeIngredient = `-- name: UpdateRecipeIngredient :one
UPDATE recipe_ingredients
SET
    product_id = $2,
    product_variant_id = $3,
    quantity = $4,
    uom_id = $5,
    is_optional = $6,
    is_byproduct = $7,
    line_number = $8,
    metadata = $9
WHERE id = $1
RETURNING id, recipe_id, product_id, product_variant_id, quantity, uom_id, is_optional, is_byproduct, line_number, metadata, created_at
`

type UpdateRecipeIngredientParams struct {
	ID               int32          `json:"id"`
	ProductID        int32          `json:"product_id"`
	ProductVariantID pgtype.Int4    `json:"product_variant_id"`
	Quantity         pgtype.Numeric `json:"quantity"`
	UomID            pgtype.Int4    `json:"uom_id"`
	IsOptional       pgtype.Bool    `json:"is_optional"`
	IsByproduct      pgtype.Bool    `json:"is_byproduct"`
	LineNumber       pgtype.Int4    `json:"line_number"`
	Metadata         []byte         `json:"metadata"`
}

func (q *Queries) UpdateRecipeIngredient(ctx context.Context, arg UpdateRecipeIngredientParams) (RecipeIngredient, error) {
	row := q.db.QueryRow(ctx, updateRecipeIngredient,
		arg.ID,
		arg.ProductID,
		arg.ProductVariantID,
		arg.Quantity,
		arg.UomID,
		arg.IsOptional,
		arg.IsByproduct,
		arg.LineNumber,
		arg.Metadata,
	)
	var i RecipeIngredient
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.Quantity,
		&i.UomID,
		&i.IsOptional,
		&i.IsByproduct,
		&i.LineNumber,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}
