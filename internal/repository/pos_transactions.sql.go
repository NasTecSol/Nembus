// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pos_transactions.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPosTransaction = `-- name: CreatePosTransaction :one
INSERT INTO pos_transactions (
    transaction_number,
    store_id,
    pos_terminal_id,
    cashier_session_id,
    cashier_id,
    customer_id,
    price_list_id,
    transaction_type,
    transaction_date,
    subtotal,
    tax_amount,
    discount_amount,
    total_amount,
    total_cost,
    status,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13, $14, $15, $16
) RETURNING id, transaction_number, status, total_amount
`

type CreatePosTransactionParams struct {
	TransactionNumber string           `json:"transaction_number"`
	StoreID           int32            `json:"store_id"`
	PosTerminalID     pgtype.Int4      `json:"pos_terminal_id"`
	CashierSessionID  int32            `json:"cashier_session_id"`
	CashierID         int32            `json:"cashier_id"`
	CustomerID        pgtype.Int4      `json:"customer_id"`
	PriceListID       pgtype.Int4      `json:"price_list_id"`
	TransactionType   pgtype.Text      `json:"transaction_type"`
	TransactionDate   pgtype.Timestamp `json:"transaction_date"`
	Subtotal          pgtype.Numeric   `json:"subtotal"`
	TaxAmount         pgtype.Numeric   `json:"tax_amount"`
	DiscountAmount    pgtype.Numeric   `json:"discount_amount"`
	TotalAmount       pgtype.Numeric   `json:"total_amount"`
	TotalCost         pgtype.Numeric   `json:"total_cost"`
	Status            pgtype.Text      `json:"status"`
	Metadata          []byte           `json:"metadata"`
}

type CreatePosTransactionRow struct {
	ID                int32          `json:"id"`
	TransactionNumber string         `json:"transaction_number"`
	Status            pgtype.Text    `json:"status"`
	TotalAmount       pgtype.Numeric `json:"total_amount"`
}

func (q *Queries) CreatePosTransaction(ctx context.Context, arg CreatePosTransactionParams) (CreatePosTransactionRow, error) {
	row := q.db.QueryRow(ctx, createPosTransaction,
		arg.TransactionNumber,
		arg.StoreID,
		arg.PosTerminalID,
		arg.CashierSessionID,
		arg.CashierID,
		arg.CustomerID,
		arg.PriceListID,
		arg.TransactionType,
		arg.TransactionDate,
		arg.Subtotal,
		arg.TaxAmount,
		arg.DiscountAmount,
		arg.TotalAmount,
		arg.TotalCost,
		arg.Status,
		arg.Metadata,
	)
	var i CreatePosTransactionRow
	err := row.Scan(
		&i.ID,
		&i.TransactionNumber,
		&i.Status,
		&i.TotalAmount,
	)
	return i, err
}

const createPosTransactionLine = `-- name: CreatePosTransactionLine :exec
INSERT INTO pos_transaction_lines (
    transaction_id, line_number, product_id, product_variant_id,
    serial_number, batch_number, quantity, uom_id,
    unit_price, discount_amount, tax_amount, line_total, cost_price, metadata
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14)
`

type CreatePosTransactionLineParams struct {
	TransactionID    int32          `json:"transaction_id"`
	LineNumber       pgtype.Int4    `json:"line_number"`
	ProductID        int32          `json:"product_id"`
	ProductVariantID pgtype.Int4    `json:"product_variant_id"`
	SerialNumber     pgtype.Text    `json:"serial_number"`
	BatchNumber      pgtype.Text    `json:"batch_number"`
	Quantity         pgtype.Numeric `json:"quantity"`
	UomID            pgtype.Int4    `json:"uom_id"`
	UnitPrice        pgtype.Numeric `json:"unit_price"`
	DiscountAmount   pgtype.Numeric `json:"discount_amount"`
	TaxAmount        pgtype.Numeric `json:"tax_amount"`
	LineTotal        pgtype.Numeric `json:"line_total"`
	CostPrice        pgtype.Numeric `json:"cost_price"`
	Metadata         []byte         `json:"metadata"`
}

func (q *Queries) CreatePosTransactionLine(ctx context.Context, arg CreatePosTransactionLineParams) error {
	_, err := q.db.Exec(ctx, createPosTransactionLine,
		arg.TransactionID,
		arg.LineNumber,
		arg.ProductID,
		arg.ProductVariantID,
		arg.SerialNumber,
		arg.BatchNumber,
		arg.Quantity,
		arg.UomID,
		arg.UnitPrice,
		arg.DiscountAmount,
		arg.TaxAmount,
		arg.LineTotal,
		arg.CostPrice,
		arg.Metadata,
	)
	return err
}

const getPosTransactionFull = `-- name: GetPosTransactionFull :many
SELECT 
    t.id, t.transaction_number, t.transaction_date, t.status,
    t.subtotal, t.tax_amount, t.discount_amount, t.total_amount,
    t.total_cost,
    cashier.first_name || ' ' || cashier.last_name AS cashier_name,
    term.terminal_name,
    sess.session_number,
    cust.name AS customer_name,
    tl.line_number,
    tl.product_id,
    tl.quantity,
    tl.unit_price,
    tl.discount_amount,
    tl.line_total,
    p.sku,
    p.name AS product_name,
    COALESCE(pb.barcode, '') AS scanned_barcode
FROM pos_transactions t
JOIN cashiers          cshr  ON t.cashier_id         = cshr.id
JOIN users             cashier ON cshr.user_id        = cashier.id
JOIN pos_terminals     term  ON t.pos_terminal_id     = term.id
JOIN cashier_sessions  sess  ON t.cashier_session_id  = sess.id
LEFT JOIN customers    cust  ON t.customer_id         = cust.id
JOIN pos_transaction_lines tl   ON tl.transaction_id = t.id
JOIN products          p     ON tl.product_id         = p.id
LEFT JOIN product_barcodes pb 
    ON pb.product_id = p.id 
   AND pb.is_primary = true
   AND (pb.product_variant_id = tl.product_variant_id OR tl.product_variant_id IS NULL)
WHERE t.id = $1
ORDER BY tl.line_number
`

type GetPosTransactionFullRow struct {
	ID                int32            `json:"id"`
	TransactionNumber string           `json:"transaction_number"`
	TransactionDate   pgtype.Timestamp `json:"transaction_date"`
	Status            pgtype.Text      `json:"status"`
	Subtotal          pgtype.Numeric   `json:"subtotal"`
	TaxAmount         pgtype.Numeric   `json:"tax_amount"`
	DiscountAmount    pgtype.Numeric   `json:"discount_amount"`
	TotalAmount       pgtype.Numeric   `json:"total_amount"`
	TotalCost         pgtype.Numeric   `json:"total_cost"`
	CashierName       interface{}      `json:"cashier_name"`
	TerminalName      pgtype.Text      `json:"terminal_name"`
	SessionNumber     string           `json:"session_number"`
	CustomerName      pgtype.Text      `json:"customer_name"`
	LineNumber        pgtype.Int4      `json:"line_number"`
	ProductID         int32            `json:"product_id"`
	Quantity          pgtype.Numeric   `json:"quantity"`
	UnitPrice         pgtype.Numeric   `json:"unit_price"`
	DiscountAmount_2  pgtype.Numeric   `json:"discount_amount_2"`
	LineTotal         pgtype.Numeric   `json:"line_total"`
	Sku               string           `json:"sku"`
	ProductName       string           `json:"product_name"`
	ScannedBarcode    string           `json:"scanned_barcode"`
}

func (q *Queries) GetPosTransactionFull(ctx context.Context, id int32) ([]GetPosTransactionFullRow, error) {
	rows, err := q.db.Query(ctx, getPosTransactionFull, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPosTransactionFullRow
	for rows.Next() {
		var i GetPosTransactionFullRow
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.TransactionDate,
			&i.Status,
			&i.Subtotal,
			&i.TaxAmount,
			&i.DiscountAmount,
			&i.TotalAmount,
			&i.TotalCost,
			&i.CashierName,
			&i.TerminalName,
			&i.SessionNumber,
			&i.CustomerName,
			&i.LineNumber,
			&i.ProductID,
			&i.Quantity,
			&i.UnitPrice,
			&i.DiscountAmount_2,
			&i.LineTotal,
			&i.Sku,
			&i.ProductName,
			&i.ScannedBarcode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodaysPosTransactions = `-- name: ListTodaysPosTransactions :many
SELECT 
    t.id,
    t.transaction_number,
    t.transaction_date,
    t.total_amount,
    t.status,
    cashier.first_name || ' ' || cashier.last_name AS cashier_name,
    term.terminal_name,
    COUNT(tl.id) AS items_count,
    SUM(tl.quantity) AS total_quantity
FROM pos_transactions t
JOIN cashiers cshr ON t.cashier_id = cshr.id
JOIN users cashier ON cshr.user_id = cashier.id
JOIN pos_terminals term ON t.pos_terminal_id = term.id
JOIN pos_transaction_lines tl ON tl.transaction_id = t.id
WHERE t.store_id = $1
  AND t.transaction_date >= CURRENT_DATE
  AND t.transaction_date < CURRENT_DATE + INTERVAL '1 day'
GROUP BY t.id, cashier.first_name, cashier.last_name, term.terminal_name
ORDER BY t.transaction_date DESC
LIMIT 200
`

type ListTodaysPosTransactionsRow struct {
	ID                int32            `json:"id"`
	TransactionNumber string           `json:"transaction_number"`
	TransactionDate   pgtype.Timestamp `json:"transaction_date"`
	TotalAmount       pgtype.Numeric   `json:"total_amount"`
	Status            pgtype.Text      `json:"status"`
	CashierName       interface{}      `json:"cashier_name"`
	TerminalName      pgtype.Text      `json:"terminal_name"`
	ItemsCount        int64            `json:"items_count"`
	TotalQuantity     int64            `json:"total_quantity"`
}

func (q *Queries) ListTodaysPosTransactions(ctx context.Context, storeID int32) ([]ListTodaysPosTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listTodaysPosTransactions, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTodaysPosTransactionsRow
	for rows.Next() {
		var i ListTodaysPosTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.TransactionDate,
			&i.TotalAmount,
			&i.Status,
			&i.CashierName,
			&i.TerminalName,
			&i.ItemsCount,
			&i.TotalQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const voidPosTransaction = `-- name: VoidPosTransaction :execrows
UPDATE pos_transactions
SET 
    status     = 'voided',
    voided_by  = $2,
    voided_at  = CURRENT_TIMESTAMP,
    metadata   = jsonb_set(metadata, '{void_reason}', to_jsonb($3::text))
WHERE id = $1
  AND status = 'completed'
  AND voided_at IS NULL
`

type VoidPosTransactionParams struct {
	ID       int32       `json:"id"`
	VoidedBy pgtype.Int4 `json:"voided_by"`
	Column3  string      `json:"column_3"`
}

func (q *Queries) VoidPosTransaction(ctx context.Context, arg VoidPosTransactionParams) (int64, error) {
	result, err := q.db.Exec(ctx, voidPosTransaction, arg.ID, arg.VoidedBy, arg.Column3)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
