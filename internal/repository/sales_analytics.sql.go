// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sales_analytics.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDailySalesByStore = `-- name: GetDailySalesByStore :many
SELECT 
    date_trunc('day', t.transaction_date) AS sale_date,
    t.store_id,
    s.name AS store_name,
    COUNT(DISTINCT t.id) AS transaction_count,
    SUM(t.total_amount) AS gross_sales,
    SUM(t.discount_amount) AS total_discounts,
    SUM(t.tax_amount) AS total_taxes,
    SUM(t.total_amount - t.discount_amount) AS net_sales,
    AVG(t.total_amount) AS avg_transaction_value
FROM pos_transactions t
JOIN stores s ON t.store_id = s.id
WHERE t.status = 'completed'
  AND t.transaction_date >= $1::date
  AND t.transaction_date < $2::date + INTERVAL '1 day'
GROUP BY sale_date, t.store_id, s.name
ORDER BY sale_date DESC, net_sales DESC
`

type GetDailySalesByStoreParams struct {
	Column1 pgtype.Date `json:"column_1"`
	Column2 pgtype.Date `json:"column_2"`
}

type GetDailySalesByStoreRow struct {
	SaleDate            pgtype.Interval `json:"sale_date"`
	StoreID             int32           `json:"store_id"`
	StoreName           string          `json:"store_name"`
	TransactionCount    int64           `json:"transaction_count"`
	GrossSales          int64           `json:"gross_sales"`
	TotalDiscounts      int64           `json:"total_discounts"`
	TotalTaxes          int64           `json:"total_taxes"`
	NetSales            int64           `json:"net_sales"`
	AvgTransactionValue float64         `json:"avg_transaction_value"`
}

func (q *Queries) GetDailySalesByStore(ctx context.Context, arg GetDailySalesByStoreParams) ([]GetDailySalesByStoreRow, error) {
	rows, err := q.db.Query(ctx, getDailySalesByStore, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailySalesByStoreRow
	for rows.Next() {
		var i GetDailySalesByStoreRow
		if err := rows.Scan(
			&i.SaleDate,
			&i.StoreID,
			&i.StoreName,
			&i.TransactionCount,
			&i.GrossSales,
			&i.TotalDiscounts,
			&i.TotalTaxes,
			&i.NetSales,
			&i.AvgTransactionValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSellingProductsToday = `-- name: GetTopSellingProductsToday :many
SELECT 
    tl.product_id,
    p.sku,
    p.name,
    SUM(tl.quantity) AS total_qty,
    SUM(tl.line_total) AS total_amount,
    COUNT(DISTINCT t.id) AS transaction_count
FROM pos_transaction_lines tl
JOIN pos_transactions t ON tl.transaction_id = t.id
JOIN products p ON tl.product_id = p.id
WHERE t.status = 'completed'
  AND t.transaction_date >= CURRENT_DATE
  AND t.transaction_date < CURRENT_DATE + INTERVAL '1 day'
  AND t.store_id = $1
GROUP BY tl.product_id, p.sku, p.name
ORDER BY total_amount DESC
LIMIT 20
`

type GetTopSellingProductsTodayRow struct {
	ProductID        int32  `json:"product_id"`
	Sku              string `json:"sku"`
	Name             string `json:"name"`
	TotalQty         int64  `json:"total_qty"`
	TotalAmount      int64  `json:"total_amount"`
	TransactionCount int64  `json:"transaction_count"`
}

func (q *Queries) GetTopSellingProductsToday(ctx context.Context, storeID int32) ([]GetTopSellingProductsTodayRow, error) {
	rows, err := q.db.Query(ctx, getTopSellingProductsToday, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellingProductsTodayRow
	for rows.Next() {
		var i GetTopSellingProductsTodayRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Sku,
			&i.Name,
			&i.TotalQty,
			&i.TotalAmount,
			&i.TransactionCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
