// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sales_orders.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSalesOrderHeader = `-- name: CreateSalesOrderHeader :one
INSERT INTO sales_orders (
    order_number, organization_id, customer_id, store_id,
    order_date, delivery_date, price_list_id, status,
    subtotal, tax_amount, discount_amount, total_amount,
    created_by, metadata
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14)
RETURNING id, order_number, status, total_amount
`

type CreateSalesOrderHeaderParams struct {
	OrderNumber    string         `json:"order_number"`
	OrganizationID int32          `json:"organization_id"`
	CustomerID     pgtype.Int4    `json:"customer_id"`
	StoreID        int32          `json:"store_id"`
	OrderDate      pgtype.Date    `json:"order_date"`
	DeliveryDate   pgtype.Date    `json:"delivery_date"`
	PriceListID    pgtype.Int4    `json:"price_list_id"`
	Status         pgtype.Text    `json:"status"`
	Subtotal       pgtype.Numeric `json:"subtotal"`
	TaxAmount      pgtype.Numeric `json:"tax_amount"`
	DiscountAmount pgtype.Numeric `json:"discount_amount"`
	TotalAmount    pgtype.Numeric `json:"total_amount"`
	CreatedBy      pgtype.Int4    `json:"created_by"`
	Metadata       []byte         `json:"metadata"`
}

type CreateSalesOrderHeaderRow struct {
	ID          int32          `json:"id"`
	OrderNumber string         `json:"order_number"`
	Status      pgtype.Text    `json:"status"`
	TotalAmount pgtype.Numeric `json:"total_amount"`
}

func (q *Queries) CreateSalesOrderHeader(ctx context.Context, arg CreateSalesOrderHeaderParams) (CreateSalesOrderHeaderRow, error) {
	row := q.db.QueryRow(ctx, createSalesOrderHeader,
		arg.OrderNumber,
		arg.OrganizationID,
		arg.CustomerID,
		arg.StoreID,
		arg.OrderDate,
		arg.DeliveryDate,
		arg.PriceListID,
		arg.Status,
		arg.Subtotal,
		arg.TaxAmount,
		arg.DiscountAmount,
		arg.TotalAmount,
		arg.CreatedBy,
		arg.Metadata,
	)
	var i CreateSalesOrderHeaderRow
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.Status,
		&i.TotalAmount,
	)
	return i, err
}

const getSalesOrderFull = `-- name: GetSalesOrderFull :many
SELECT 
    so.id, so.order_number, so.organization_id, so.customer_id, so.store_id, so.order_date, so.delivery_date, so.price_list_id, so.status, so.subtotal, so.tax_amount, so.discount_amount, so.total_amount, so.created_by, so.approved_by, so.metadata, so.created_at, so.updated_at,
    c.name AS customer_name,
    c.customer_code,
    st.name AS store_name,
    u.first_name || ' ' || u.last_name AS created_by_name,
    sol.id AS line_id,
    sol.line_number,
    sol.product_id,
    sol.quantity,
    sol.unit_price,
    sol.discount_amount,
    sol.tax_amount,
    sol.line_total,
    p.sku,
    p.name AS product_name,
    COALESCE(pb.barcode, '') AS primary_barcode
FROM sales_orders so
LEFT JOIN customers     c  ON so.customer_id = c.id
LEFT JOIN stores        st ON so.store_id    = st.id
LEFT JOIN users         u  ON so.created_by  = u.id
LEFT JOIN sales_order_lines sol ON sol.sales_order_id = so.id
LEFT JOIN products      p  ON sol.product_id = p.id
LEFT JOIN product_barcodes pb 
    ON pb.product_id = p.id AND pb.is_primary = true
WHERE so.id = $1
ORDER BY sol.line_number NULLS LAST
`

type GetSalesOrderFullRow struct {
	ID               int32            `json:"id"`
	OrderNumber      string           `json:"order_number"`
	OrganizationID   int32            `json:"organization_id"`
	CustomerID       pgtype.Int4      `json:"customer_id"`
	StoreID          int32            `json:"store_id"`
	OrderDate        pgtype.Date      `json:"order_date"`
	DeliveryDate     pgtype.Date      `json:"delivery_date"`
	PriceListID      pgtype.Int4      `json:"price_list_id"`
	Status           pgtype.Text      `json:"status"`
	Subtotal         pgtype.Numeric   `json:"subtotal"`
	TaxAmount        pgtype.Numeric   `json:"tax_amount"`
	DiscountAmount   pgtype.Numeric   `json:"discount_amount"`
	TotalAmount      pgtype.Numeric   `json:"total_amount"`
	CreatedBy        pgtype.Int4      `json:"created_by"`
	ApprovedBy       pgtype.Int4      `json:"approved_by"`
	Metadata         []byte           `json:"metadata"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	CustomerName     pgtype.Text      `json:"customer_name"`
	CustomerCode     pgtype.Text      `json:"customer_code"`
	StoreName        pgtype.Text      `json:"store_name"`
	CreatedByName    interface{}      `json:"created_by_name"`
	LineID           pgtype.Int4      `json:"line_id"`
	LineNumber       pgtype.Int4      `json:"line_number"`
	ProductID        pgtype.Int4      `json:"product_id"`
	Quantity         pgtype.Numeric   `json:"quantity"`
	UnitPrice        pgtype.Numeric   `json:"unit_price"`
	DiscountAmount_2 pgtype.Numeric   `json:"discount_amount_2"`
	TaxAmount_2      pgtype.Numeric   `json:"tax_amount_2"`
	LineTotal        pgtype.Numeric   `json:"line_total"`
	Sku              pgtype.Text      `json:"sku"`
	ProductName      pgtype.Text      `json:"product_name"`
	PrimaryBarcode   string           `json:"primary_barcode"`
}

func (q *Queries) GetSalesOrderFull(ctx context.Context, id int32) ([]GetSalesOrderFullRow, error) {
	rows, err := q.db.Query(ctx, getSalesOrderFull, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesOrderFullRow
	for rows.Next() {
		var i GetSalesOrderFullRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.OrganizationID,
			&i.CustomerID,
			&i.StoreID,
			&i.OrderDate,
			&i.DeliveryDate,
			&i.PriceListID,
			&i.Status,
			&i.Subtotal,
			&i.TaxAmount,
			&i.DiscountAmount,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ApprovedBy,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CustomerName,
			&i.CustomerCode,
			&i.StoreName,
			&i.CreatedByName,
			&i.LineID,
			&i.LineNumber,
			&i.ProductID,
			&i.Quantity,
			&i.UnitPrice,
			&i.DiscountAmount_2,
			&i.TaxAmount_2,
			&i.LineTotal,
			&i.Sku,
			&i.ProductName,
			&i.PrimaryBarcode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesOrderTotalsByStatus = `-- name: GetSalesOrderTotalsByStatus :many
SELECT 
    status,
    COUNT(*) AS order_count,
    COALESCE(SUM(total_amount), 0) AS total_revenue,
    COALESCE(AVG(total_amount), 0) AS avg_order_value
FROM sales_orders
WHERE organization_id = $1
  AND order_date >= $2::date
  AND order_date <= $3::date
GROUP BY status
ORDER BY status
`

type GetSalesOrderTotalsByStatusParams struct {
	OrganizationID int32       `json:"organization_id"`
	Column2        pgtype.Date `json:"column_2"`
	Column3        pgtype.Date `json:"column_3"`
}

type GetSalesOrderTotalsByStatusRow struct {
	Status        pgtype.Text `json:"status"`
	OrderCount    int64       `json:"order_count"`
	TotalRevenue  interface{} `json:"total_revenue"`
	AvgOrderValue interface{} `json:"avg_order_value"`
}

func (q *Queries) GetSalesOrderTotalsByStatus(ctx context.Context, arg GetSalesOrderTotalsByStatusParams) ([]GetSalesOrderTotalsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getSalesOrderTotalsByStatus, arg.OrganizationID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesOrderTotalsByStatusRow
	for rows.Next() {
		var i GetSalesOrderTotalsByStatusRow
		if err := rows.Scan(
			&i.Status,
			&i.OrderCount,
			&i.TotalRevenue,
			&i.AvgOrderValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalesOrdersDashboard = `-- name: ListSalesOrdersDashboard :many
SELECT 
    so.id,
    so.order_number,
    so.order_date,
    so.status,
    so.total_amount,
    c.name AS customer_name,
    st.name AS store_name,
    COUNT(sol.id) AS line_count,
    SUM(sol.quantity) AS total_items
FROM sales_orders so
LEFT JOIN customers c ON so.customer_id = c.id
LEFT JOIN stores st ON so.store_id = st.id
LEFT JOIN sales_order_lines sol ON sol.sales_order_id = so.id
WHERE so.organization_id = $1
  AND so.order_date >= $2::date
  AND so.order_date <= $3::date
  AND ($4::text IS NULL OR so.status = $4)
GROUP BY so.id, c.name, st.name
ORDER BY so.order_date DESC, so.id DESC
LIMIT 100
`

type ListSalesOrdersDashboardParams struct {
	OrgID    int32       `json:"org_id"`
	FromDate pgtype.Date `json:"from_date"`
	ToDate   pgtype.Date `json:"to_date"`
	Status   string      `json:"status"`
}

type ListSalesOrdersDashboardRow struct {
	ID           int32          `json:"id"`
	OrderNumber  string         `json:"order_number"`
	OrderDate    pgtype.Date    `json:"order_date"`
	Status       pgtype.Text    `json:"status"`
	TotalAmount  pgtype.Numeric `json:"total_amount"`
	CustomerName pgtype.Text    `json:"customer_name"`
	StoreName    pgtype.Text    `json:"store_name"`
	LineCount    int64          `json:"line_count"`
	TotalItems   int64          `json:"total_items"`
}

func (q *Queries) ListSalesOrdersDashboard(ctx context.Context, arg ListSalesOrdersDashboardParams) ([]ListSalesOrdersDashboardRow, error) {
	rows, err := q.db.Query(ctx, listSalesOrdersDashboard,
		arg.OrgID,
		arg.FromDate,
		arg.ToDate,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSalesOrdersDashboardRow
	for rows.Next() {
		var i ListSalesOrdersDashboardRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CustomerName,
			&i.StoreName,
			&i.LineCount,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
