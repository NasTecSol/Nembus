// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products
WHERE organization_id = $1
  AND is_active = COALESCE($2, is_active)
`

type CountProductsParams struct {
	OrganizationID int32       `json:"organization_id"`
	IsActive       pgtype.Bool `json:"is_active"`
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts, arg.OrganizationID, arg.IsActive)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBrand = `-- name: CreateBrand :one

INSERT INTO brands (
    name, code, is_active, metadata
) VALUES (
    $1, $2, $3, $4
) RETURNING id, name, code, is_active, metadata, created_at, updated_at
`

type CreateBrandParams struct {
	Name     string      `json:"name"`
	Code     string      `json:"code"`
	IsActive pgtype.Bool `json:"is_active"`
	Metadata []byte      `json:"metadata"`
}

// =====================================================
// BRANDS
// =====================================================
func (q *Queries) CreateBrand(ctx context.Context, arg CreateBrandParams) (Brand, error) {
	row := q.db.QueryRow(ctx, createBrand,
		arg.Name,
		arg.Code,
		arg.IsActive,
		arg.Metadata,
	)
	var i Brand
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one



INSERT INTO products (
    organization_id, sku, name, description, category_id,
    brand_id, base_uom_id, product_type, tax_category_id,
    is_serialized, is_batch_managed, is_active, is_sellable,
    is_purchasable, allow_decimal_quantity, track_inventory, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
) RETURNING id, organization_id, sku, name, description, category_id, brand_id, base_uom_id, product_type, tax_category_id, is_serialized, is_batch_managed, is_active, is_sellable, is_purchasable, allow_decimal_quantity, track_inventory, metadata, created_at, updated_at
`

type CreateProductParams struct {
	OrganizationID       int32       `json:"organization_id"`
	Sku                  string      `json:"sku"`
	Name                 string      `json:"name"`
	Description          pgtype.Text `json:"description"`
	CategoryID           pgtype.Int4 `json:"category_id"`
	BrandID              pgtype.Int4 `json:"brand_id"`
	BaseUomID            pgtype.Int4 `json:"base_uom_id"`
	ProductType          pgtype.Text `json:"product_type"`
	TaxCategoryID        pgtype.Int4 `json:"tax_category_id"`
	IsSerialized         pgtype.Bool `json:"is_serialized"`
	IsBatchManaged       pgtype.Bool `json:"is_batch_managed"`
	IsActive             pgtype.Bool `json:"is_active"`
	IsSellable           pgtype.Bool `json:"is_sellable"`
	IsPurchasable        pgtype.Bool `json:"is_purchasable"`
	AllowDecimalQuantity pgtype.Bool `json:"allow_decimal_quantity"`
	TrackInventory       pgtype.Bool `json:"track_inventory"`
	Metadata             []byte      `json:"metadata"`
}

// =====================================================
// UNITS OF MEASURE
// Note: UOM queries are in uom_query.sql
// =====================================================
// =====================================================
// TAX CATEGORIES
// Note: Tax category queries are in tax_categories_query.sql
// =====================================================
// =====================================================
// PRODUCTS
// =====================================================
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.OrganizationID,
		arg.Sku,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.BrandID,
		arg.BaseUomID,
		arg.ProductType,
		arg.TaxCategoryID,
		arg.IsSerialized,
		arg.IsBatchManaged,
		arg.IsActive,
		arg.IsSellable,
		arg.IsPurchasable,
		arg.AllowDecimalQuantity,
		arg.TrackInventory,
		arg.Metadata,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.BrandID,
		&i.BaseUomID,
		&i.ProductType,
		&i.TaxCategoryID,
		&i.IsSerialized,
		&i.IsBatchManaged,
		&i.IsActive,
		&i.IsSellable,
		&i.IsPurchasable,
		&i.AllowDecimalQuantity,
		&i.TrackInventory,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProductCategory = `-- name: CreateProductCategory :one

INSERT INTO product_categories (
    parent_category_id, name, code, description, 
    category_level, is_active, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, parent_category_id, name, code, description, category_level, is_active, metadata, created_at, updated_at
`

type CreateProductCategoryParams struct {
	ParentCategoryID pgtype.Int4 `json:"parent_category_id"`
	Name             string      `json:"name"`
	Code             string      `json:"code"`
	Description      pgtype.Text `json:"description"`
	CategoryLevel    pgtype.Int4 `json:"category_level"`
	IsActive         pgtype.Bool `json:"is_active"`
	Metadata         []byte      `json:"metadata"`
}

// =====================================================
// PRODUCT CATEGORIES
// =====================================================
func (q *Queries) CreateProductCategory(ctx context.Context, arg CreateProductCategoryParams) (ProductCategory, error) {
	row := q.db.QueryRow(ctx, createProductCategory,
		arg.ParentCategoryID,
		arg.Name,
		arg.Code,
		arg.Description,
		arg.CategoryLevel,
		arg.IsActive,
		arg.Metadata,
	)
	var i ProductCategory
	err := row.Scan(
		&i.ID,
		&i.ParentCategoryID,
		&i.Name,
		&i.Code,
		&i.Description,
		&i.CategoryLevel,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBrand = `-- name: DeleteBrand :exec
DELETE FROM brands WHERE id = $1
`

func (q *Queries) DeleteBrand(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteBrand, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteProductCategory = `-- name: DeleteProductCategory :exec
DELETE FROM product_categories WHERE id = $1
`

func (q *Queries) DeleteProductCategory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProductCategory, id)
	return err
}

const getBrand = `-- name: GetBrand :one
SELECT id, name, code, is_active, metadata, created_at, updated_at FROM brands WHERE id = $1 LIMIT 1
`

func (q *Queries) GetBrand(ctx context.Context, id int32) (Brand, error) {
	row := q.db.QueryRow(ctx, getBrand, id)
	var i Brand
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBrandByCode = `-- name: GetBrandByCode :one
SELECT id, name, code, is_active, metadata, created_at, updated_at FROM brands WHERE code = $1 LIMIT 1
`

func (q *Queries) GetBrandByCode(ctx context.Context, code string) (Brand, error) {
	row := q.db.QueryRow(ctx, getBrandByCode, code)
	var i Brand
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryHierarchy = `-- name: GetCategoryHierarchy :many
WITH RECURSIVE category_tree AS (
    SELECT 
        id, parent_category_id, name, code, description,
        category_level, is_active, metadata,
        1 as level,
        ARRAY[id] as path,
        name as full_path
    FROM product_categories
    WHERE parent_category_id IS NULL
    
    UNION ALL
    
    SELECT 
        pc.id, pc.parent_category_id, pc.name, pc.code, pc.description,
        pc.category_level, pc.is_active, pc.metadata,
        ct.level + 1,
        ct.path || pc.id,
        ct.full_path || ' > ' || pc.name
    FROM product_categories pc
    INNER JOIN category_tree ct ON pc.parent_category_id = ct.id
)
SELECT id, parent_category_id, name, code, description, category_level, is_active, metadata, level, path, full_path FROM category_tree ct
WHERE CASE 
    WHEN $1 IS NULL THEN true
    ELSE ct.is_active = $1
END
ORDER BY ct.path
`

type GetCategoryHierarchyRow struct {
	ID               int32       `json:"id"`
	ParentCategoryID pgtype.Int4 `json:"parent_category_id"`
	Name             string      `json:"name"`
	Code             string      `json:"code"`
	Description      pgtype.Text `json:"description"`
	CategoryLevel    pgtype.Int4 `json:"category_level"`
	IsActive         pgtype.Bool `json:"is_active"`
	Metadata         []byte      `json:"metadata"`
	Level            int32       `json:"level"`
	Path             interface{} `json:"path"`
	FullPath         string      `json:"full_path"`
}

func (q *Queries) GetCategoryHierarchy(ctx context.Context, filterIsActive interface{}) ([]GetCategoryHierarchyRow, error) {
	rows, err := q.db.Query(ctx, getCategoryHierarchy, filterIsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoryHierarchyRow
	for rows.Next() {
		var i GetCategoryHierarchyRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentCategoryID,
			&i.Name,
			&i.Code,
			&i.Description,
			&i.CategoryLevel,
			&i.IsActive,
			&i.Metadata,
			&i.Level,
			&i.Path,
			&i.FullPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one
SELECT id, organization_id, sku, name, description, category_id, brand_id, base_uom_id, product_type, tax_category_id, is_serialized, is_batch_managed, is_active, is_sellable, is_purchasable, allow_decimal_quantity, track_inventory, metadata, created_at, updated_at FROM products WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProduct(ctx context.Context, id int32) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.BrandID,
		&i.BaseUomID,
		&i.ProductType,
		&i.TaxCategoryID,
		&i.IsSerialized,
		&i.IsBatchManaged,
		&i.IsActive,
		&i.IsSellable,
		&i.IsPurchasable,
		&i.AllowDecimalQuantity,
		&i.TrackInventory,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductBySKU = `-- name: GetProductBySKU :one
SELECT id, organization_id, sku, name, description, category_id, brand_id, base_uom_id, product_type, tax_category_id, is_serialized, is_batch_managed, is_active, is_sellable, is_purchasable, allow_decimal_quantity, track_inventory, metadata, created_at, updated_at FROM products 
WHERE organization_id = $1 AND sku = $2 
LIMIT 1
`

type GetProductBySKUParams struct {
	OrganizationID int32  `json:"organization_id"`
	Sku            string `json:"sku"`
}

func (q *Queries) GetProductBySKU(ctx context.Context, arg GetProductBySKUParams) (Product, error) {
	row := q.db.QueryRow(ctx, getProductBySKU, arg.OrganizationID, arg.Sku)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.BrandID,
		&i.BaseUomID,
		&i.ProductType,
		&i.TaxCategoryID,
		&i.IsSerialized,
		&i.IsBatchManaged,
		&i.IsActive,
		&i.IsSellable,
		&i.IsPurchasable,
		&i.AllowDecimalQuantity,
		&i.TrackInventory,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductCategory = `-- name: GetProductCategory :one
SELECT id, parent_category_id, name, code, description, category_level, is_active, metadata, created_at, updated_at FROM product_categories WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProductCategory(ctx context.Context, id int32) (ProductCategory, error) {
	row := q.db.QueryRow(ctx, getProductCategory, id)
	var i ProductCategory
	err := row.Scan(
		&i.ID,
		&i.ParentCategoryID,
		&i.Name,
		&i.Code,
		&i.Description,
		&i.CategoryLevel,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductCategoryByCode = `-- name: GetProductCategoryByCode :one
SELECT id, parent_category_id, name, code, description, category_level, is_active, metadata, created_at, updated_at FROM product_categories WHERE code = $1 LIMIT 1
`

func (q *Queries) GetProductCategoryByCode(ctx context.Context, code string) (ProductCategory, error) {
	row := q.db.QueryRow(ctx, getProductCategoryByCode, code)
	var i ProductCategory
	err := row.Scan(
		&i.ID,
		&i.ParentCategoryID,
		&i.Name,
		&i.Code,
		&i.Description,
		&i.CategoryLevel,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductWithDetails = `-- name: GetProductWithDetails :one
SELECT 
    p.id, p.organization_id, p.sku, p.name, p.description, p.category_id, p.brand_id, p.base_uom_id, p.product_type, p.tax_category_id, p.is_serialized, p.is_batch_managed, p.is_active, p.is_sellable, p.is_purchasable, p.allow_decimal_quantity, p.track_inventory, p.metadata, p.created_at, p.updated_at,
    pc.name as category_name,
    pc.code as category_code,
    b.name as brand_name,
    b.code as brand_code,
    uom.name as base_uom_name,
    uom.code as base_uom_code,
    tc.name as tax_category_name,
    tc.tax_rate as tax_rate
FROM products p
LEFT JOIN product_categories pc ON p.category_id = pc.id
LEFT JOIN brands b ON p.brand_id = b.id
LEFT JOIN units_of_measure uom ON p.base_uom_id = uom.id
LEFT JOIN tax_categories tc ON p.tax_category_id = tc.id
WHERE p.id = $1
LIMIT 1
`

type GetProductWithDetailsRow struct {
	ID                   int32            `json:"id"`
	OrganizationID       int32            `json:"organization_id"`
	Sku                  string           `json:"sku"`
	Name                 string           `json:"name"`
	Description          pgtype.Text      `json:"description"`
	CategoryID           pgtype.Int4      `json:"category_id"`
	BrandID              pgtype.Int4      `json:"brand_id"`
	BaseUomID            pgtype.Int4      `json:"base_uom_id"`
	ProductType          pgtype.Text      `json:"product_type"`
	TaxCategoryID        pgtype.Int4      `json:"tax_category_id"`
	IsSerialized         pgtype.Bool      `json:"is_serialized"`
	IsBatchManaged       pgtype.Bool      `json:"is_batch_managed"`
	IsActive             pgtype.Bool      `json:"is_active"`
	IsSellable           pgtype.Bool      `json:"is_sellable"`
	IsPurchasable        pgtype.Bool      `json:"is_purchasable"`
	AllowDecimalQuantity pgtype.Bool      `json:"allow_decimal_quantity"`
	TrackInventory       pgtype.Bool      `json:"track_inventory"`
	Metadata             []byte           `json:"metadata"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
	CategoryName         pgtype.Text      `json:"category_name"`
	CategoryCode         pgtype.Text      `json:"category_code"`
	BrandName            pgtype.Text      `json:"brand_name"`
	BrandCode            pgtype.Text      `json:"brand_code"`
	BaseUomName          pgtype.Text      `json:"base_uom_name"`
	BaseUomCode          pgtype.Text      `json:"base_uom_code"`
	TaxCategoryName      pgtype.Text      `json:"tax_category_name"`
	TaxRate              pgtype.Numeric   `json:"tax_rate"`
}

func (q *Queries) GetProductWithDetails(ctx context.Context, id int32) (GetProductWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getProductWithDetails, id)
	var i GetProductWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.BrandID,
		&i.BaseUomID,
		&i.ProductType,
		&i.TaxCategoryID,
		&i.IsSerialized,
		&i.IsBatchManaged,
		&i.IsActive,
		&i.IsSellable,
		&i.IsPurchasable,
		&i.AllowDecimalQuantity,
		&i.TrackInventory,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryName,
		&i.CategoryCode,
		&i.BrandName,
		&i.BrandCode,
		&i.BaseUomName,
		&i.BaseUomCode,
		&i.TaxCategoryName,
		&i.TaxRate,
	)
	return i, err
}

const listBrands = `-- name: ListBrands :many
SELECT id, name, code, is_active, metadata, created_at, updated_at FROM brands
WHERE is_active = COALESCE($3, is_active)
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListBrandsParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) ListBrands(ctx context.Context, arg ListBrandsParams) ([]Brand, error) {
	rows, err := q.db.Query(ctx, listBrands, arg.Limit, arg.Offset, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Brand
	for rows.Next() {
		var i Brand
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoryChildren = `-- name: ListCategoryChildren :many
SELECT id, parent_category_id, name, code, description, category_level, is_active, metadata, created_at, updated_at FROM product_categories
WHERE parent_category_id = $1
  AND is_active = COALESCE($2, is_active)
ORDER BY name
`

type ListCategoryChildrenParams struct {
	ParentCategoryID pgtype.Int4 `json:"parent_category_id"`
	IsActive         pgtype.Bool `json:"is_active"`
}

func (q *Queries) ListCategoryChildren(ctx context.Context, arg ListCategoryChildrenParams) ([]ProductCategory, error) {
	rows, err := q.db.Query(ctx, listCategoryChildren, arg.ParentCategoryID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductCategory
	for rows.Next() {
		var i ProductCategory
		if err := rows.Scan(
			&i.ID,
			&i.ParentCategoryID,
			&i.Name,
			&i.Code,
			&i.Description,
			&i.CategoryLevel,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductCategories = `-- name: ListProductCategories :many
SELECT id, parent_category_id, name, code, description, category_level, is_active, metadata, created_at, updated_at FROM product_categories
WHERE is_active = COALESCE($1, is_active)
  AND parent_category_id IS NULL
ORDER BY name
`

func (q *Queries) ListProductCategories(ctx context.Context, isActive pgtype.Bool) ([]ProductCategory, error) {
	rows, err := q.db.Query(ctx, listProductCategories, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductCategory
	for rows.Next() {
		var i ProductCategory
		if err := rows.Scan(
			&i.ID,
			&i.ParentCategoryID,
			&i.Name,
			&i.Code,
			&i.Description,
			&i.CategoryLevel,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, organization_id, sku, name, description, category_id, brand_id, base_uom_id, product_type, tax_category_id, is_serialized, is_batch_managed, is_active, is_sellable, is_purchasable, allow_decimal_quantity, track_inventory, metadata, created_at, updated_at FROM products
WHERE organization_id = $1
  AND is_active = COALESCE($4, is_active)
  AND category_id = COALESCE($5, category_id)
  AND brand_id = COALESCE($6, brand_id)
  AND product_type = COALESCE($7, product_type)
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListProductsParams struct {
	OrganizationID int32       `json:"organization_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	IsActive       pgtype.Bool `json:"is_active"`
	CategoryID     pgtype.Int4 `json:"category_id"`
	BrandID        pgtype.Int4 `json:"brand_id"`
	ProductType    pgtype.Text `json:"product_type"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.OrganizationID,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
		arg.CategoryID,
		arg.BrandID,
		arg.ProductType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.BrandID,
			&i.BaseUomID,
			&i.ProductType,
			&i.TaxCategoryID,
			&i.IsSerialized,
			&i.IsBatchManaged,
			&i.IsActive,
			&i.IsSellable,
			&i.IsPurchasable,
			&i.AllowDecimalQuantity,
			&i.TrackInventory,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPurchasableProducts = `-- name: ListPurchasableProducts :many
SELECT id, organization_id, sku, name, description, category_id, brand_id, base_uom_id, product_type, tax_category_id, is_serialized, is_batch_managed, is_active, is_sellable, is_purchasable, allow_decimal_quantity, track_inventory, metadata, created_at, updated_at FROM products
WHERE organization_id = $1
  AND is_purchasable = true
  AND is_active = true
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListPurchasableProductsParams struct {
	OrganizationID int32 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

func (q *Queries) ListPurchasableProducts(ctx context.Context, arg ListPurchasableProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listPurchasableProducts, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.BrandID,
			&i.BaseUomID,
			&i.ProductType,
			&i.TaxCategoryID,
			&i.IsSerialized,
			&i.IsBatchManaged,
			&i.IsActive,
			&i.IsSellable,
			&i.IsPurchasable,
			&i.AllowDecimalQuantity,
			&i.TrackInventory,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSellableProducts = `-- name: ListSellableProducts :many
SELECT id, organization_id, sku, name, description, category_id, brand_id, base_uom_id, product_type, tax_category_id, is_serialized, is_batch_managed, is_active, is_sellable, is_purchasable, allow_decimal_quantity, track_inventory, metadata, created_at, updated_at FROM products
WHERE organization_id = $1
  AND is_sellable = true
  AND is_active = true
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListSellableProductsParams struct {
	OrganizationID int32 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

func (q *Queries) ListSellableProducts(ctx context.Context, arg ListSellableProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listSellableProducts, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.BrandID,
			&i.BaseUomID,
			&i.ProductType,
			&i.TaxCategoryID,
			&i.IsSerialized,
			&i.IsBatchManaged,
			&i.IsActive,
			&i.IsSellable,
			&i.IsPurchasable,
			&i.AllowDecimalQuantity,
			&i.TrackInventory,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBrands = `-- name: SearchBrands :many
SELECT id, name, code, is_active, metadata, created_at, updated_at FROM brands
WHERE is_active = true
  AND (name ILIKE '%' || $1 || '%' OR code ILIKE '%' || $1 || '%')
ORDER BY name
LIMIT $2 OFFSET $3
`

type SearchBrandsParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchBrands(ctx context.Context, arg SearchBrandsParams) ([]Brand, error) {
	rows, err := q.db.Query(ctx, searchBrands, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Brand
	for rows.Next() {
		var i Brand
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, organization_id, sku, name, description, category_id, brand_id, base_uom_id, product_type, tax_category_id, is_serialized, is_batch_managed, is_active, is_sellable, is_purchasable, allow_decimal_quantity, track_inventory, metadata, created_at, updated_at FROM products
WHERE organization_id = $1
  AND is_active = true
  AND (
    sku ILIKE '%' || $2 || '%' OR
    name ILIKE '%' || $2 || '%' OR
    description ILIKE '%' || $2 || '%'
  )
ORDER BY name
LIMIT $3 OFFSET $4
`

type SearchProductsParams struct {
	OrganizationID int32       `json:"organization_id"`
	Column2        pgtype.Text `json:"column_2"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, searchProducts,
		arg.OrganizationID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.BrandID,
			&i.BaseUomID,
			&i.ProductType,
			&i.TaxCategoryID,
			&i.IsSerialized,
			&i.IsBatchManaged,
			&i.IsActive,
			&i.IsSellable,
			&i.IsPurchasable,
			&i.AllowDecimalQuantity,
			&i.TrackInventory,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBrand = `-- name: UpdateBrand :one
UPDATE brands
SET 
    name = COALESCE($1, name),
    is_active = COALESCE($2, is_active),
    metadata = COALESCE($3, metadata)
WHERE id = $4
RETURNING id, name, code, is_active, metadata, created_at, updated_at
`

type UpdateBrandParams struct {
	Name     pgtype.Text `json:"name"`
	IsActive pgtype.Bool `json:"is_active"`
	Metadata []byte      `json:"metadata"`
	ID       int32       `json:"id"`
}

func (q *Queries) UpdateBrand(ctx context.Context, arg UpdateBrandParams) (Brand, error) {
	row := q.db.QueryRow(ctx, updateBrand,
		arg.Name,
		arg.IsActive,
		arg.Metadata,
		arg.ID,
	)
	var i Brand
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET 
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    category_id = COALESCE($3, category_id),
    brand_id = COALESCE($4, brand_id),
    base_uom_id = COALESCE($5, base_uom_id),
    product_type = COALESCE($6, product_type),
    tax_category_id = COALESCE($7, tax_category_id),
    is_serialized = COALESCE($8, is_serialized),
    is_batch_managed = COALESCE($9, is_batch_managed),
    is_active = COALESCE($10, is_active),
    is_sellable = COALESCE($11, is_sellable),
    is_purchasable = COALESCE($12, is_purchasable),
    allow_decimal_quantity = COALESCE($13, allow_decimal_quantity),
    track_inventory = COALESCE($14, track_inventory),
    metadata = COALESCE($15, metadata)
WHERE id = $16
RETURNING id, organization_id, sku, name, description, category_id, brand_id, base_uom_id, product_type, tax_category_id, is_serialized, is_batch_managed, is_active, is_sellable, is_purchasable, allow_decimal_quantity, track_inventory, metadata, created_at, updated_at
`

type UpdateProductParams struct {
	Name                 pgtype.Text `json:"name"`
	Description          pgtype.Text `json:"description"`
	CategoryID           pgtype.Int4 `json:"category_id"`
	BrandID              pgtype.Int4 `json:"brand_id"`
	BaseUomID            pgtype.Int4 `json:"base_uom_id"`
	ProductType          pgtype.Text `json:"product_type"`
	TaxCategoryID        pgtype.Int4 `json:"tax_category_id"`
	IsSerialized         pgtype.Bool `json:"is_serialized"`
	IsBatchManaged       pgtype.Bool `json:"is_batch_managed"`
	IsActive             pgtype.Bool `json:"is_active"`
	IsSellable           pgtype.Bool `json:"is_sellable"`
	IsPurchasable        pgtype.Bool `json:"is_purchasable"`
	AllowDecimalQuantity pgtype.Bool `json:"allow_decimal_quantity"`
	TrackInventory       pgtype.Bool `json:"track_inventory"`
	Metadata             []byte      `json:"metadata"`
	ID                   int32       `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.BrandID,
		arg.BaseUomID,
		arg.ProductType,
		arg.TaxCategoryID,
		arg.IsSerialized,
		arg.IsBatchManaged,
		arg.IsActive,
		arg.IsSellable,
		arg.IsPurchasable,
		arg.AllowDecimalQuantity,
		arg.TrackInventory,
		arg.Metadata,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.BrandID,
		&i.BaseUomID,
		&i.ProductType,
		&i.TaxCategoryID,
		&i.IsSerialized,
		&i.IsBatchManaged,
		&i.IsActive,
		&i.IsSellable,
		&i.IsPurchasable,
		&i.AllowDecimalQuantity,
		&i.TrackInventory,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductCategory = `-- name: UpdateProductCategory :one
UPDATE product_categories
SET 
    parent_category_id = COALESCE($1, parent_category_id),
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    category_level = COALESCE($4, category_level),
    is_active = COALESCE($5, is_active),
    metadata = COALESCE($6, metadata)
WHERE id = $7
RETURNING id, parent_category_id, name, code, description, category_level, is_active, metadata, created_at, updated_at
`

type UpdateProductCategoryParams struct {
	ParentCategoryID pgtype.Int4 `json:"parent_category_id"`
	Name             pgtype.Text `json:"name"`
	Description      pgtype.Text `json:"description"`
	CategoryLevel    pgtype.Int4 `json:"category_level"`
	IsActive         pgtype.Bool `json:"is_active"`
	Metadata         []byte      `json:"metadata"`
	ID               int32       `json:"id"`
}

func (q *Queries) UpdateProductCategory(ctx context.Context, arg UpdateProductCategoryParams) (ProductCategory, error) {
	row := q.db.QueryRow(ctx, updateProductCategory,
		arg.ParentCategoryID,
		arg.Name,
		arg.Description,
		arg.CategoryLevel,
		arg.IsActive,
		arg.Metadata,
		arg.ID,
	)
	var i ProductCategory
	err := row.Scan(
		&i.ID,
		&i.ParentCategoryID,
		&i.Name,
		&i.Code,
		&i.Description,
		&i.CategoryLevel,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
