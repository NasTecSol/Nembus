// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: submenus_query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubmenu = `-- name: CreateSubmenu :one
INSERT INTO submenus (
    menu_id,
    parent_submenu_id,
    name,
    code,
    route_path,
    icon,
    display_order,
    is_active,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, menu_id, parent_submenu_id, name, code, route_path, icon, display_order, is_active, metadata, created_at, updated_at
`

type CreateSubmenuParams struct {
	MenuID          int32       `json:"menu_id"`
	ParentSubmenuID pgtype.Int4 `json:"parent_submenu_id"`
	Name            string      `json:"name"`
	Code            string      `json:"code"`
	RoutePath       pgtype.Text `json:"route_path"`
	Icon            pgtype.Text `json:"icon"`
	DisplayOrder    pgtype.Int4 `json:"display_order"`
	IsActive        pgtype.Bool `json:"is_active"`
	Metadata        []byte      `json:"metadata"`
}

func (q *Queries) CreateSubmenu(ctx context.Context, arg CreateSubmenuParams) (Submenu, error) {
	row := q.db.QueryRow(ctx, createSubmenu,
		arg.MenuID,
		arg.ParentSubmenuID,
		arg.Name,
		arg.Code,
		arg.RoutePath,
		arg.Icon,
		arg.DisplayOrder,
		arg.IsActive,
		arg.Metadata,
	)
	var i Submenu
	err := row.Scan(
		&i.ID,
		&i.MenuID,
		&i.ParentSubmenuID,
		&i.Name,
		&i.Code,
		&i.RoutePath,
		&i.Icon,
		&i.DisplayOrder,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSubmenu = `-- name: DeleteSubmenu :exec
DELETE FROM submenus
WHERE id = $1
`

func (q *Queries) DeleteSubmenu(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteSubmenu, id)
	return err
}

const getSubmenu = `-- name: GetSubmenu :one
SELECT id, menu_id, parent_submenu_id, name, code, route_path, icon, display_order, is_active, metadata, created_at, updated_at FROM submenus
WHERE id = $1
`

func (q *Queries) GetSubmenu(ctx context.Context, id int32) (Submenu, error) {
	row := q.db.QueryRow(ctx, getSubmenu, id)
	var i Submenu
	err := row.Scan(
		&i.ID,
		&i.MenuID,
		&i.ParentSubmenuID,
		&i.Name,
		&i.Code,
		&i.RoutePath,
		&i.Icon,
		&i.DisplayOrder,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubmenuByCode = `-- name: GetSubmenuByCode :one
SELECT id, menu_id, parent_submenu_id, name, code, route_path, icon, display_order, is_active, metadata, created_at, updated_at FROM submenus
WHERE menu_id = $1 AND code = $2
`

type GetSubmenuByCodeParams struct {
	MenuID int32  `json:"menu_id"`
	Code   string `json:"code"`
}

func (q *Queries) GetSubmenuByCode(ctx context.Context, arg GetSubmenuByCodeParams) (Submenu, error) {
	row := q.db.QueryRow(ctx, getSubmenuByCode, arg.MenuID, arg.Code)
	var i Submenu
	err := row.Scan(
		&i.ID,
		&i.MenuID,
		&i.ParentSubmenuID,
		&i.Name,
		&i.Code,
		&i.RoutePath,
		&i.Icon,
		&i.DisplayOrder,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveSubmenusByMenu = `-- name: ListActiveSubmenusByMenu :many
SELECT id, menu_id, parent_submenu_id, name, code, route_path, icon, display_order, is_active, metadata, created_at, updated_at FROM submenus
WHERE menu_id = $1 AND is_active = true
ORDER BY display_order, id
`

func (q *Queries) ListActiveSubmenusByMenu(ctx context.Context, menuID int32) ([]Submenu, error) {
	rows, err := q.db.Query(ctx, listActiveSubmenusByMenu, menuID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Submenu
	for rows.Next() {
		var i Submenu
		if err := rows.Scan(
			&i.ID,
			&i.MenuID,
			&i.ParentSubmenuID,
			&i.Name,
			&i.Code,
			&i.RoutePath,
			&i.Icon,
			&i.DisplayOrder,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubmenus = `-- name: ListSubmenus :many
SELECT id, menu_id, parent_submenu_id, name, code, route_path, icon, display_order, is_active, metadata, created_at, updated_at FROM submenus
ORDER BY display_order, id
`

func (q *Queries) ListSubmenus(ctx context.Context) ([]Submenu, error) {
	rows, err := q.db.Query(ctx, listSubmenus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Submenu
	for rows.Next() {
		var i Submenu
		if err := rows.Scan(
			&i.ID,
			&i.MenuID,
			&i.ParentSubmenuID,
			&i.Name,
			&i.Code,
			&i.RoutePath,
			&i.Icon,
			&i.DisplayOrder,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubmenusByMenu = `-- name: ListSubmenusByMenu :many
SELECT id, menu_id, parent_submenu_id, name, code, route_path, icon, display_order, is_active, metadata, created_at, updated_at FROM submenus
WHERE menu_id = $1
ORDER BY display_order, id
`

func (q *Queries) ListSubmenusByMenu(ctx context.Context, menuID int32) ([]Submenu, error) {
	rows, err := q.db.Query(ctx, listSubmenusByMenu, menuID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Submenu
	for rows.Next() {
		var i Submenu
		if err := rows.Scan(
			&i.ID,
			&i.MenuID,
			&i.ParentSubmenuID,
			&i.Name,
			&i.Code,
			&i.RoutePath,
			&i.Icon,
			&i.DisplayOrder,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubmenusByParent = `-- name: ListSubmenusByParent :many
SELECT id, menu_id, parent_submenu_id, name, code, route_path, icon, display_order, is_active, metadata, created_at, updated_at FROM submenus
WHERE parent_submenu_id = $1
ORDER BY display_order, id
`

func (q *Queries) ListSubmenusByParent(ctx context.Context, parentSubmenuID pgtype.Int4) ([]Submenu, error) {
	rows, err := q.db.Query(ctx, listSubmenusByParent, parentSubmenuID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Submenu
	for rows.Next() {
		var i Submenu
		if err := rows.Scan(
			&i.ID,
			&i.MenuID,
			&i.ParentSubmenuID,
			&i.Name,
			&i.Code,
			&i.RoutePath,
			&i.Icon,
			&i.DisplayOrder,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleSubmenuActive = `-- name: ToggleSubmenuActive :one
UPDATE submenus
SET is_active = $2
WHERE id = $1
RETURNING id, menu_id, parent_submenu_id, name, code, route_path, icon, display_order, is_active, metadata, created_at, updated_at
`

type ToggleSubmenuActiveParams struct {
	ID       int32       `json:"id"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) ToggleSubmenuActive(ctx context.Context, arg ToggleSubmenuActiveParams) (Submenu, error) {
	row := q.db.QueryRow(ctx, toggleSubmenuActive, arg.ID, arg.IsActive)
	var i Submenu
	err := row.Scan(
		&i.ID,
		&i.MenuID,
		&i.ParentSubmenuID,
		&i.Name,
		&i.Code,
		&i.RoutePath,
		&i.Icon,
		&i.DisplayOrder,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubmenu = `-- name: UpdateSubmenu :one
UPDATE submenus
SET 
    parent_submenu_id = $2,
    name = $3,
    route_path = $4,
    icon = $5,
    display_order = $6,
    is_active = $7,
    metadata = $8
WHERE id = $1
RETURNING id, menu_id, parent_submenu_id, name, code, route_path, icon, display_order, is_active, metadata, created_at, updated_at
`

type UpdateSubmenuParams struct {
	ID              int32       `json:"id"`
	ParentSubmenuID pgtype.Int4 `json:"parent_submenu_id"`
	Name            string      `json:"name"`
	RoutePath       pgtype.Text `json:"route_path"`
	Icon            pgtype.Text `json:"icon"`
	DisplayOrder    pgtype.Int4 `json:"display_order"`
	IsActive        pgtype.Bool `json:"is_active"`
	Metadata        []byte      `json:"metadata"`
}

func (q *Queries) UpdateSubmenu(ctx context.Context, arg UpdateSubmenuParams) (Submenu, error) {
	row := q.db.QueryRow(ctx, updateSubmenu,
		arg.ID,
		arg.ParentSubmenuID,
		arg.Name,
		arg.RoutePath,
		arg.Icon,
		arg.DisplayOrder,
		arg.IsActive,
		arg.Metadata,
	)
	var i Submenu
	err := row.Scan(
		&i.ID,
		&i.MenuID,
		&i.ParentSubmenuID,
		&i.Name,
		&i.Code,
		&i.RoutePath,
		&i.Icon,
		&i.DisplayOrder,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
