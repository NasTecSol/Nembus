// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: purchase_analytics_query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPurchaseAnalytics = `-- name: CreatePurchaseAnalytics :one
INSERT INTO purchase_analytics (
    organization_id,
    store_id,
    supplier_id,
    product_id,
    category_id,
    date,
    month,
    quarter,
    year,
    total_orders,
    total_quantity,
    total_amount,
    discounts_received,
    taxes_paid,
    net_amount,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16
) RETURNING id, organization_id, store_id, supplier_id, product_id, category_id, date, month, quarter, year, units_purchased, total_cost, discounts, taxes, net_cost, orders, total_orders, total_quantity, total_amount, discounts_received, taxes_paid, net_amount, average_order_value, metadata, created_at, updated_at
`

type CreatePurchaseAnalyticsParams struct {
	OrganizationID    int32          `json:"organization_id"`
	StoreID           pgtype.Int4    `json:"store_id"`
	SupplierID        pgtype.Int4    `json:"supplier_id"`
	ProductID         pgtype.Int4    `json:"product_id"`
	CategoryID        pgtype.Int4    `json:"category_id"`
	Date              pgtype.Date    `json:"date"`
	Month             pgtype.Int4    `json:"month"`
	Quarter           pgtype.Int4    `json:"quarter"`
	Year              pgtype.Int4    `json:"year"`
	TotalOrders       pgtype.Int4    `json:"total_orders"`
	TotalQuantity     pgtype.Numeric `json:"total_quantity"`
	TotalAmount       pgtype.Numeric `json:"total_amount"`
	DiscountsReceived pgtype.Numeric `json:"discounts_received"`
	TaxesPaid         pgtype.Numeric `json:"taxes_paid"`
	NetAmount         pgtype.Numeric `json:"net_amount"`
	Metadata          []byte         `json:"metadata"`
}

func (q *Queries) CreatePurchaseAnalytics(ctx context.Context, arg CreatePurchaseAnalyticsParams) (PurchaseAnalytic, error) {
	row := q.db.QueryRow(ctx, createPurchaseAnalytics,
		arg.OrganizationID,
		arg.StoreID,
		arg.SupplierID,
		arg.ProductID,
		arg.CategoryID,
		arg.Date,
		arg.Month,
		arg.Quarter,
		arg.Year,
		arg.TotalOrders,
		arg.TotalQuantity,
		arg.TotalAmount,
		arg.DiscountsReceived,
		arg.TaxesPaid,
		arg.NetAmount,
		arg.Metadata,
	)
	var i PurchaseAnalytic
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.StoreID,
		&i.SupplierID,
		&i.ProductID,
		&i.CategoryID,
		&i.Date,
		&i.Month,
		&i.Quarter,
		&i.Year,
		&i.UnitsPurchased,
		&i.TotalCost,
		&i.Discounts,
		&i.Taxes,
		&i.NetCost,
		&i.Orders,
		&i.TotalOrders,
		&i.TotalQuantity,
		&i.TotalAmount,
		&i.DiscountsReceived,
		&i.TaxesPaid,
		&i.NetAmount,
		&i.AverageOrderValue,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePurchaseAnalytics = `-- name: DeletePurchaseAnalytics :exec
DELETE FROM purchase_analytics
WHERE id = $1
`

func (q *Queries) DeletePurchaseAnalytics(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePurchaseAnalytics, id)
	return err
}

const getPurchaseAnalytics = `-- name: GetPurchaseAnalytics :one
SELECT id, organization_id, store_id, supplier_id, product_id, category_id, date, month, quarter, year, units_purchased, total_cost, discounts, taxes, net_cost, orders, total_orders, total_quantity, total_amount, discounts_received, taxes_paid, net_amount, average_order_value, metadata, created_at, updated_at FROM purchase_analytics
WHERE id = $1
`

func (q *Queries) GetPurchaseAnalytics(ctx context.Context, id int32) (PurchaseAnalytic, error) {
	row := q.db.QueryRow(ctx, getPurchaseAnalytics, id)
	var i PurchaseAnalytic
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.StoreID,
		&i.SupplierID,
		&i.ProductID,
		&i.CategoryID,
		&i.Date,
		&i.Month,
		&i.Quarter,
		&i.Year,
		&i.UnitsPurchased,
		&i.TotalCost,
		&i.Discounts,
		&i.Taxes,
		&i.NetCost,
		&i.Orders,
		&i.TotalOrders,
		&i.TotalQuantity,
		&i.TotalAmount,
		&i.DiscountsReceived,
		&i.TaxesPaid,
		&i.NetAmount,
		&i.AverageOrderValue,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPurchaseAnalyticsByDateRange = `-- name: GetPurchaseAnalyticsByDateRange :many
SELECT id, organization_id, store_id, supplier_id, product_id, category_id, date, month, quarter, year, units_purchased, total_cost, discounts, taxes, net_cost, orders, total_orders, total_quantity, total_amount, discounts_received, taxes_paid, net_amount, average_order_value, metadata, created_at, updated_at FROM purchase_analytics
WHERE organization_id = $1
  AND date >= $2 AND date <= $3
ORDER BY date DESC
`

type GetPurchaseAnalyticsByDateRangeParams struct {
	OrganizationID int32       `json:"organization_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

func (q *Queries) GetPurchaseAnalyticsByDateRange(ctx context.Context, arg GetPurchaseAnalyticsByDateRangeParams) ([]PurchaseAnalytic, error) {
	rows, err := q.db.Query(ctx, getPurchaseAnalyticsByDateRange, arg.OrganizationID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PurchaseAnalytic
	for rows.Next() {
		var i PurchaseAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.SupplierID,
			&i.ProductID,
			&i.CategoryID,
			&i.Date,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.UnitsPurchased,
			&i.TotalCost,
			&i.Discounts,
			&i.Taxes,
			&i.NetCost,
			&i.Orders,
			&i.TotalOrders,
			&i.TotalQuantity,
			&i.TotalAmount,
			&i.DiscountsReceived,
			&i.TaxesPaid,
			&i.NetAmount,
			&i.AverageOrderValue,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseAnalyticsByProduct = `-- name: GetPurchaseAnalyticsByProduct :many
SELECT id, organization_id, store_id, supplier_id, product_id, category_id, date, month, quarter, year, units_purchased, total_cost, discounts, taxes, net_cost, orders, total_orders, total_quantity, total_amount, discounts_received, taxes_paid, net_amount, average_order_value, metadata, created_at, updated_at FROM purchase_analytics
WHERE organization_id = $1 AND product_id = $2
  AND date >= $3 AND date <= $4
ORDER BY date DESC
`

type GetPurchaseAnalyticsByProductParams struct {
	OrganizationID int32       `json:"organization_id"`
	ProductID      pgtype.Int4 `json:"product_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

func (q *Queries) GetPurchaseAnalyticsByProduct(ctx context.Context, arg GetPurchaseAnalyticsByProductParams) ([]PurchaseAnalytic, error) {
	rows, err := q.db.Query(ctx, getPurchaseAnalyticsByProduct,
		arg.OrganizationID,
		arg.ProductID,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PurchaseAnalytic
	for rows.Next() {
		var i PurchaseAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.SupplierID,
			&i.ProductID,
			&i.CategoryID,
			&i.Date,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.UnitsPurchased,
			&i.TotalCost,
			&i.Discounts,
			&i.Taxes,
			&i.NetCost,
			&i.Orders,
			&i.TotalOrders,
			&i.TotalQuantity,
			&i.TotalAmount,
			&i.DiscountsReceived,
			&i.TaxesPaid,
			&i.NetAmount,
			&i.AverageOrderValue,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseAnalyticsByStore = `-- name: GetPurchaseAnalyticsByStore :many
SELECT id, organization_id, store_id, supplier_id, product_id, category_id, date, month, quarter, year, units_purchased, total_cost, discounts, taxes, net_cost, orders, total_orders, total_quantity, total_amount, discounts_received, taxes_paid, net_amount, average_order_value, metadata, created_at, updated_at FROM purchase_analytics
WHERE organization_id = $1 AND store_id = $2
  AND date >= $3 AND date <= $4
ORDER BY date DESC
`

type GetPurchaseAnalyticsByStoreParams struct {
	OrganizationID int32       `json:"organization_id"`
	StoreID        pgtype.Int4 `json:"store_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

func (q *Queries) GetPurchaseAnalyticsByStore(ctx context.Context, arg GetPurchaseAnalyticsByStoreParams) ([]PurchaseAnalytic, error) {
	rows, err := q.db.Query(ctx, getPurchaseAnalyticsByStore,
		arg.OrganizationID,
		arg.StoreID,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PurchaseAnalytic
	for rows.Next() {
		var i PurchaseAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.SupplierID,
			&i.ProductID,
			&i.CategoryID,
			&i.Date,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.UnitsPurchased,
			&i.TotalCost,
			&i.Discounts,
			&i.Taxes,
			&i.NetCost,
			&i.Orders,
			&i.TotalOrders,
			&i.TotalQuantity,
			&i.TotalAmount,
			&i.DiscountsReceived,
			&i.TaxesPaid,
			&i.NetAmount,
			&i.AverageOrderValue,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseAnalyticsBySupplier = `-- name: GetPurchaseAnalyticsBySupplier :many
SELECT id, organization_id, store_id, supplier_id, product_id, category_id, date, month, quarter, year, units_purchased, total_cost, discounts, taxes, net_cost, orders, total_orders, total_quantity, total_amount, discounts_received, taxes_paid, net_amount, average_order_value, metadata, created_at, updated_at FROM purchase_analytics
WHERE organization_id = $1 AND supplier_id = $2
  AND date >= $3 AND date <= $4
ORDER BY date DESC
`

type GetPurchaseAnalyticsBySupplierParams struct {
	OrganizationID int32       `json:"organization_id"`
	SupplierID     pgtype.Int4 `json:"supplier_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

func (q *Queries) GetPurchaseAnalyticsBySupplier(ctx context.Context, arg GetPurchaseAnalyticsBySupplierParams) ([]PurchaseAnalytic, error) {
	rows, err := q.db.Query(ctx, getPurchaseAnalyticsBySupplier,
		arg.OrganizationID,
		arg.SupplierID,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PurchaseAnalytic
	for rows.Next() {
		var i PurchaseAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.SupplierID,
			&i.ProductID,
			&i.CategoryID,
			&i.Date,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.UnitsPurchased,
			&i.TotalCost,
			&i.Discounts,
			&i.Taxes,
			&i.NetCost,
			&i.Orders,
			&i.TotalOrders,
			&i.TotalQuantity,
			&i.TotalAmount,
			&i.DiscountsReceived,
			&i.TaxesPaid,
			&i.NetAmount,
			&i.AverageOrderValue,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseSummaryByMonth = `-- name: GetPurchaseSummaryByMonth :many
SELECT 
    year,
    month,
    SUM(total_orders) AS total_orders,
    SUM(total_quantity) AS total_quantity,
    SUM(total_amount) AS total_amount,
    SUM(net_amount) AS net_amount
FROM purchase_analytics
WHERE organization_id = $1
  AND date >= $2 AND date <= $3
GROUP BY year, month
ORDER BY year DESC, month DESC
`

type GetPurchaseSummaryByMonthParams struct {
	OrganizationID int32       `json:"organization_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

type GetPurchaseSummaryByMonthRow struct {
	Year          pgtype.Int4 `json:"year"`
	Month         pgtype.Int4 `json:"month"`
	TotalOrders   int64       `json:"total_orders"`
	TotalQuantity int64       `json:"total_quantity"`
	TotalAmount   int64       `json:"total_amount"`
	NetAmount     int64       `json:"net_amount"`
}

func (q *Queries) GetPurchaseSummaryByMonth(ctx context.Context, arg GetPurchaseSummaryByMonthParams) ([]GetPurchaseSummaryByMonthRow, error) {
	rows, err := q.db.Query(ctx, getPurchaseSummaryByMonth, arg.OrganizationID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPurchaseSummaryByMonthRow
	for rows.Next() {
		var i GetPurchaseSummaryByMonthRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalOrders,
			&i.TotalQuantity,
			&i.TotalAmount,
			&i.NetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSuppliersByPurchaseAmount = `-- name: GetTopSuppliersByPurchaseAmount :many
SELECT 
    supplier_id,
    SUM(net_amount) AS total_purchase_amount,
    SUM(total_orders) AS total_orders
FROM purchase_analytics
WHERE organization_id = $1
  AND date >= $2 AND date <= $3
  AND supplier_id IS NOT NULL
GROUP BY supplier_id
ORDER BY total_purchase_amount DESC
LIMIT $4
`

type GetTopSuppliersByPurchaseAmountParams struct {
	OrganizationID int32       `json:"organization_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
	Limit          int32       `json:"limit"`
}

type GetTopSuppliersByPurchaseAmountRow struct {
	SupplierID          pgtype.Int4 `json:"supplier_id"`
	TotalPurchaseAmount int64       `json:"total_purchase_amount"`
	TotalOrders         int64       `json:"total_orders"`
}

func (q *Queries) GetTopSuppliersByPurchaseAmount(ctx context.Context, arg GetTopSuppliersByPurchaseAmountParams) ([]GetTopSuppliersByPurchaseAmountRow, error) {
	rows, err := q.db.Query(ctx, getTopSuppliersByPurchaseAmount,
		arg.OrganizationID,
		arg.Date,
		arg.Date_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSuppliersByPurchaseAmountRow
	for rows.Next() {
		var i GetTopSuppliersByPurchaseAmountRow
		if err := rows.Scan(&i.SupplierID, &i.TotalPurchaseAmount, &i.TotalOrders); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPurchaseAnalytics = `-- name: ListPurchaseAnalytics :many
SELECT id, organization_id, store_id, supplier_id, product_id, category_id, date, month, quarter, year, units_purchased, total_cost, discounts, taxes, net_cost, orders, total_orders, total_quantity, total_amount, discounts_received, taxes_paid, net_amount, average_order_value, metadata, created_at, updated_at FROM purchase_analytics
WHERE organization_id = $1
ORDER BY date DESC
LIMIT $2 OFFSET $3
`

type ListPurchaseAnalyticsParams struct {
	OrganizationID int32 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

func (q *Queries) ListPurchaseAnalytics(ctx context.Context, arg ListPurchaseAnalyticsParams) ([]PurchaseAnalytic, error) {
	rows, err := q.db.Query(ctx, listPurchaseAnalytics, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PurchaseAnalytic
	for rows.Next() {
		var i PurchaseAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.SupplierID,
			&i.ProductID,
			&i.CategoryID,
			&i.Date,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.UnitsPurchased,
			&i.TotalCost,
			&i.Discounts,
			&i.Taxes,
			&i.NetCost,
			&i.Orders,
			&i.TotalOrders,
			&i.TotalQuantity,
			&i.TotalAmount,
			&i.DiscountsReceived,
			&i.TaxesPaid,
			&i.NetAmount,
			&i.AverageOrderValue,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePurchaseAnalytics = `-- name: UpdatePurchaseAnalytics :one
UPDATE purchase_analytics
SET 
    total_orders = $2,
    total_quantity = $3,
    total_amount = $4,
    discounts_received = $5,
    taxes_paid = $6,
    net_amount = $7,
    metadata = $8
WHERE id = $1
RETURNING id, organization_id, store_id, supplier_id, product_id, category_id, date, month, quarter, year, units_purchased, total_cost, discounts, taxes, net_cost, orders, total_orders, total_quantity, total_amount, discounts_received, taxes_paid, net_amount, average_order_value, metadata, created_at, updated_at
`

type UpdatePurchaseAnalyticsParams struct {
	ID                int32          `json:"id"`
	TotalOrders       pgtype.Int4    `json:"total_orders"`
	TotalQuantity     pgtype.Numeric `json:"total_quantity"`
	TotalAmount       pgtype.Numeric `json:"total_amount"`
	DiscountsReceived pgtype.Numeric `json:"discounts_received"`
	TaxesPaid         pgtype.Numeric `json:"taxes_paid"`
	NetAmount         pgtype.Numeric `json:"net_amount"`
	Metadata          []byte         `json:"metadata"`
}

func (q *Queries) UpdatePurchaseAnalytics(ctx context.Context, arg UpdatePurchaseAnalyticsParams) (PurchaseAnalytic, error) {
	row := q.db.QueryRow(ctx, updatePurchaseAnalytics,
		arg.ID,
		arg.TotalOrders,
		arg.TotalQuantity,
		arg.TotalAmount,
		arg.DiscountsReceived,
		arg.TaxesPaid,
		arg.NetAmount,
		arg.Metadata,
	)
	var i PurchaseAnalytic
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.StoreID,
		&i.SupplierID,
		&i.ProductID,
		&i.CategoryID,
		&i.Date,
		&i.Month,
		&i.Quarter,
		&i.Year,
		&i.UnitsPurchased,
		&i.TotalCost,
		&i.Discounts,
		&i.Taxes,
		&i.NetCost,
		&i.Orders,
		&i.TotalOrders,
		&i.TotalQuantity,
		&i.TotalAmount,
		&i.DiscountsReceived,
		&i.TaxesPaid,
		&i.NetAmount,
		&i.AverageOrderValue,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
