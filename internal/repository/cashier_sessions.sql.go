// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cashier_sessions.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const closeCashierSession = `-- name: CloseCashierSession :one
UPDATE cashier_sessions
SET 
    closing_time     = CURRENT_TIMESTAMP,
    closing_balance  = $2,
    expected_balance = $3,
    variance         = $4,
    status           = 'closed',
    metadata         = jsonb_set(
        jsonb_set(metadata, '{closing_note}', to_jsonb($5::text)),
        '{closed_by}', to_jsonb($6::bigint)
    )
WHERE id = $1
  AND status = 'open'
RETURNING id, session_number, opening_time, closing_time, variance, status
`

type CloseCashierSessionParams struct {
	ID              int32          `json:"id"`
	ClosingBalance  pgtype.Numeric `json:"closing_balance"`
	ExpectedBalance pgtype.Numeric `json:"expected_balance"`
	Variance        pgtype.Numeric `json:"variance"`
	Column5         string         `json:"column_5"`
	Column6         int64          `json:"column_6"`
}

type CloseCashierSessionRow struct {
	ID            int32            `json:"id"`
	SessionNumber string           `json:"session_number"`
	OpeningTime   pgtype.Timestamp `json:"opening_time"`
	ClosingTime   pgtype.Timestamp `json:"closing_time"`
	Variance      pgtype.Numeric   `json:"variance"`
	Status        pgtype.Text      `json:"status"`
}

func (q *Queries) CloseCashierSession(ctx context.Context, arg CloseCashierSessionParams) (CloseCashierSessionRow, error) {
	row := q.db.QueryRow(ctx, closeCashierSession,
		arg.ID,
		arg.ClosingBalance,
		arg.ExpectedBalance,
		arg.Variance,
		arg.Column5,
		arg.Column6,
	)
	var i CloseCashierSessionRow
	err := row.Scan(
		&i.ID,
		&i.SessionNumber,
		&i.OpeningTime,
		&i.ClosingTime,
		&i.Variance,
		&i.Status,
	)
	return i, err
}

const getActiveCashierSession = `-- name: GetActiveCashierSession :one
SELECT 
    cs.id, cs.cashier_id, cs.pos_terminal_id, cs.session_number, cs.opening_time, cs.closing_time, cs.opening_balance, cs.closing_balance, cs.expected_balance, cs.variance, cs.status, cs.metadata, cs.created_at,
    c.cashier_code,
    u.first_name || ' ' || u.last_name AS cashier_name,
    t.terminal_name,
    t.terminal_code
FROM cashier_sessions cs
JOIN cashiers      c ON cs.cashier_id      = c.id
JOIN users         u ON c.user_id          = u.id
JOIN pos_terminals t ON cs.pos_terminal_id = t.id
WHERE cs.cashier_id = $1
  AND cs.status = 'open'
  AND cs.closing_time IS NULL
ORDER BY cs.opening_time DESC
LIMIT 1
`

type GetActiveCashierSessionRow struct {
	ID              int32            `json:"id"`
	CashierID       int32            `json:"cashier_id"`
	PosTerminalID   int32            `json:"pos_terminal_id"`
	SessionNumber   string           `json:"session_number"`
	OpeningTime     pgtype.Timestamp `json:"opening_time"`
	ClosingTime     pgtype.Timestamp `json:"closing_time"`
	OpeningBalance  pgtype.Numeric   `json:"opening_balance"`
	ClosingBalance  pgtype.Numeric   `json:"closing_balance"`
	ExpectedBalance pgtype.Numeric   `json:"expected_balance"`
	Variance        pgtype.Numeric   `json:"variance"`
	Status          pgtype.Text      `json:"status"`
	Metadata        []byte           `json:"metadata"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	CashierCode     string           `json:"cashier_code"`
	CashierName     interface{}      `json:"cashier_name"`
	TerminalName    pgtype.Text      `json:"terminal_name"`
	TerminalCode    string           `json:"terminal_code"`
}

func (q *Queries) GetActiveCashierSession(ctx context.Context, cashierID int32) (GetActiveCashierSessionRow, error) {
	row := q.db.QueryRow(ctx, getActiveCashierSession, cashierID)
	var i GetActiveCashierSessionRow
	err := row.Scan(
		&i.ID,
		&i.CashierID,
		&i.PosTerminalID,
		&i.SessionNumber,
		&i.OpeningTime,
		&i.ClosingTime,
		&i.OpeningBalance,
		&i.ClosingBalance,
		&i.ExpectedBalance,
		&i.Variance,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.CashierCode,
		&i.CashierName,
		&i.TerminalName,
		&i.TerminalCode,
	)
	return i, err
}

const getSessionSummary = `-- name: GetSessionSummary :one
SELECT 
    cs.id,
    cs.session_number,
    cs.opening_time,
    cs.closing_time,
    cs.opening_balance,
    cs.closing_balance,
    cs.expected_balance,
    cs.variance,
    COUNT(t.id) AS transaction_count,
    COALESCE(SUM(t.total_amount), 0) AS total_sales,
    COALESCE(SUM(t.discount_amount), 0) AS total_discounts_given
FROM cashier_sessions cs
LEFT JOIN pos_transactions t 
    ON t.cashier_session_id = cs.id 
   AND t.status = 'completed'
WHERE cs.id = $1
GROUP BY cs.id
`

type GetSessionSummaryRow struct {
	ID                  int32            `json:"id"`
	SessionNumber       string           `json:"session_number"`
	OpeningTime         pgtype.Timestamp `json:"opening_time"`
	ClosingTime         pgtype.Timestamp `json:"closing_time"`
	OpeningBalance      pgtype.Numeric   `json:"opening_balance"`
	ClosingBalance      pgtype.Numeric   `json:"closing_balance"`
	ExpectedBalance     pgtype.Numeric   `json:"expected_balance"`
	Variance            pgtype.Numeric   `json:"variance"`
	TransactionCount    int64            `json:"transaction_count"`
	TotalSales          interface{}      `json:"total_sales"`
	TotalDiscountsGiven interface{}      `json:"total_discounts_given"`
}

func (q *Queries) GetSessionSummary(ctx context.Context, id int32) (GetSessionSummaryRow, error) {
	row := q.db.QueryRow(ctx, getSessionSummary, id)
	var i GetSessionSummaryRow
	err := row.Scan(
		&i.ID,
		&i.SessionNumber,
		&i.OpeningTime,
		&i.ClosingTime,
		&i.OpeningBalance,
		&i.ClosingBalance,
		&i.ExpectedBalance,
		&i.Variance,
		&i.TransactionCount,
		&i.TotalSales,
		&i.TotalDiscountsGiven,
	)
	return i, err
}

const openCashierSession = `-- name: OpenCashierSession :one
INSERT INTO cashier_sessions (
    cashier_id,
    pos_terminal_id,
    session_number,
    opening_time,
    opening_balance,
    status
) VALUES (
    $1, $2, $3, CURRENT_TIMESTAMP, $4, 'open'
) RETURNING id, session_number, opening_time, status
`

type OpenCashierSessionParams struct {
	CashierID      int32          `json:"cashier_id"`
	PosTerminalID  int32          `json:"pos_terminal_id"`
	SessionNumber  string         `json:"session_number"`
	OpeningBalance pgtype.Numeric `json:"opening_balance"`
}

type OpenCashierSessionRow struct {
	ID            int32            `json:"id"`
	SessionNumber string           `json:"session_number"`
	OpeningTime   pgtype.Timestamp `json:"opening_time"`
	Status        pgtype.Text      `json:"status"`
}

func (q *Queries) OpenCashierSession(ctx context.Context, arg OpenCashierSessionParams) (OpenCashierSessionRow, error) {
	row := q.db.QueryRow(ctx, openCashierSession,
		arg.CashierID,
		arg.PosTerminalID,
		arg.SessionNumber,
		arg.OpeningBalance,
	)
	var i OpenCashierSessionRow
	err := row.Scan(
		&i.ID,
		&i.SessionNumber,
		&i.OpeningTime,
		&i.Status,
	)
	return i, err
}
