// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product_batches.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const adjustBatchQuantity = `-- name: AdjustBatchQuantity :one
UPDATE product_batches
SET quantity_available = quantity_available + $2
WHERE id = $1
RETURNING id, product_id, product_variant_id, batch_number, manufacturing_date, expiry_date, store_id, quantity_available, status, metadata, created_at, updated_at
`

type AdjustBatchQuantityParams struct {
	ID                int32          `json:"id"`
	QuantityAvailable pgtype.Numeric `json:"quantity_available"`
}

func (q *Queries) AdjustBatchQuantity(ctx context.Context, arg AdjustBatchQuantityParams) (ProductBatch, error) {
	row := q.db.QueryRow(ctx, adjustBatchQuantity, arg.ID, arg.QuantityAvailable)
	var i ProductBatch
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.BatchNumber,
		&i.ManufacturingDate,
		&i.ExpiryDate,
		&i.StoreID,
		&i.QuantityAvailable,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProductBatch = `-- name: CreateProductBatch :one

INSERT INTO product_batches (
    product_id, product_variant_id, batch_number,
    manufacturing_date, expiry_date, store_id,
    quantity_available, status, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, product_id, product_variant_id, batch_number, manufacturing_date, expiry_date, store_id, quantity_available, status, metadata, created_at, updated_at
`

type CreateProductBatchParams struct {
	ProductID         int32          `json:"product_id"`
	ProductVariantID  pgtype.Int4    `json:"product_variant_id"`
	BatchNumber       string         `json:"batch_number"`
	ManufacturingDate pgtype.Date    `json:"manufacturing_date"`
	ExpiryDate        pgtype.Date    `json:"expiry_date"`
	StoreID           pgtype.Int4    `json:"store_id"`
	QuantityAvailable pgtype.Numeric `json:"quantity_available"`
	Status            pgtype.Text    `json:"status"`
	Metadata          []byte         `json:"metadata"`
}

// =====================================================
// PRODUCT BATCHES
// =====================================================
func (q *Queries) CreateProductBatch(ctx context.Context, arg CreateProductBatchParams) (ProductBatch, error) {
	row := q.db.QueryRow(ctx, createProductBatch,
		arg.ProductID,
		arg.ProductVariantID,
		arg.BatchNumber,
		arg.ManufacturingDate,
		arg.ExpiryDate,
		arg.StoreID,
		arg.QuantityAvailable,
		arg.Status,
		arg.Metadata,
	)
	var i ProductBatch
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.BatchNumber,
		&i.ManufacturingDate,
		&i.ExpiryDate,
		&i.StoreID,
		&i.QuantityAvailable,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProductBatch = `-- name: DeleteProductBatch :exec
DELETE FROM product_batches WHERE id = $1
`

func (q *Queries) DeleteProductBatch(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProductBatch, id)
	return err
}

const expireBatches = `-- name: ExpireBatches :exec
UPDATE product_batches
SET status = 'expired'
WHERE expiry_date < CURRENT_DATE
  AND status = 'active'
`

func (q *Queries) ExpireBatches(ctx context.Context) error {
	_, err := q.db.Exec(ctx, expireBatches)
	return err
}

const getAvailableBatches = `-- name: GetAvailableBatches :many
SELECT id, product_id, product_variant_id, batch_number, manufacturing_date, expiry_date, store_id, quantity_available, status, metadata, created_at, updated_at FROM product_batches
WHERE product_id = $1
  AND product_variant_id = COALESCE($3, product_variant_id)
  AND store_id = $2
  AND status = 'active'
  AND quantity_available > 0
ORDER BY expiry_date NULLS LAST, manufacturing_date
`

type GetAvailableBatchesParams struct {
	ProductID        int32       `json:"product_id"`
	StoreID          pgtype.Int4 `json:"store_id"`
	ProductVariantID pgtype.Int4 `json:"product_variant_id"`
}

func (q *Queries) GetAvailableBatches(ctx context.Context, arg GetAvailableBatchesParams) ([]ProductBatch, error) {
	rows, err := q.db.Query(ctx, getAvailableBatches, arg.ProductID, arg.StoreID, arg.ProductVariantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductBatch
	for rows.Next() {
		var i ProductBatch
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.BatchNumber,
			&i.ManufacturingDate,
			&i.ExpiryDate,
			&i.StoreID,
			&i.QuantityAvailable,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatchStockSummary = `-- name: GetBatchStockSummary :many

SELECT 
    p.id as product_id,
    p.name as product_name,
    p.sku as product_sku,
    pb.batch_number,
    pb.expiry_date,
    s.name as store_name,
    pb.quantity_available,
    pb.status
FROM product_batches pb
INNER JOIN products p ON pb.product_id = p.id
INNER JOIN stores s ON pb.store_id = s.id
WHERE s.organization_id = $1
  AND pb.quantity_available > 0
ORDER BY pb.expiry_date NULLS LAST, p.name
`

type GetBatchStockSummaryRow struct {
	ProductID         int32          `json:"product_id"`
	ProductName       string         `json:"product_name"`
	ProductSku        string         `json:"product_sku"`
	BatchNumber       string         `json:"batch_number"`
	ExpiryDate        pgtype.Date    `json:"expiry_date"`
	StoreName         string         `json:"store_name"`
	QuantityAvailable pgtype.Numeric `json:"quantity_available"`
	Status            pgtype.Text    `json:"status"`
}

// =====================================================
// BATCH AND SERIAL NUMBER REPORTS
// =====================================================
func (q *Queries) GetBatchStockSummary(ctx context.Context, organizationID int32) ([]GetBatchStockSummaryRow, error) {
	rows, err := q.db.Query(ctx, getBatchStockSummary, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBatchStockSummaryRow
	for rows.Next() {
		var i GetBatchStockSummaryRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.ProductSku,
			&i.BatchNumber,
			&i.ExpiryDate,
			&i.StoreName,
			&i.QuantityAvailable,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredBatches = `-- name: GetExpiredBatches :many
SELECT 
    pb.id, pb.product_id, pb.product_variant_id, pb.batch_number, pb.manufacturing_date, pb.expiry_date, pb.store_id, pb.quantity_available, pb.status, pb.metadata, pb.created_at, pb.updated_at,
    p.name as product_name,
    p.sku as product_sku,
    s.name as store_name
FROM product_batches pb
INNER JOIN products p ON pb.product_id = p.id
LEFT JOIN stores s ON pb.store_id = s.id
WHERE pb.store_id = COALESCE($1, pb.store_id)
  AND pb.status = 'active'
  AND pb.expiry_date IS NOT NULL
  AND pb.expiry_date < CURRENT_DATE
ORDER BY pb.expiry_date, p.name
`

type GetExpiredBatchesRow struct {
	ID                int32            `json:"id"`
	ProductID         int32            `json:"product_id"`
	ProductVariantID  pgtype.Int4      `json:"product_variant_id"`
	BatchNumber       string           `json:"batch_number"`
	ManufacturingDate pgtype.Date      `json:"manufacturing_date"`
	ExpiryDate        pgtype.Date      `json:"expiry_date"`
	StoreID           pgtype.Int4      `json:"store_id"`
	QuantityAvailable pgtype.Numeric   `json:"quantity_available"`
	Status            pgtype.Text      `json:"status"`
	Metadata          []byte           `json:"metadata"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	ProductName       string           `json:"product_name"`
	ProductSku        string           `json:"product_sku"`
	StoreName         pgtype.Text      `json:"store_name"`
}

func (q *Queries) GetExpiredBatches(ctx context.Context, storeID pgtype.Int4) ([]GetExpiredBatchesRow, error) {
	rows, err := q.db.Query(ctx, getExpiredBatches, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpiredBatchesRow
	for rows.Next() {
		var i GetExpiredBatchesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.BatchNumber,
			&i.ManufacturingDate,
			&i.ExpiryDate,
			&i.StoreID,
			&i.QuantityAvailable,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductSku,
			&i.StoreName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiringSoonBatches = `-- name: GetExpiringSoonBatches :many
SELECT 
    pb.id, pb.product_id, pb.product_variant_id, pb.batch_number, pb.manufacturing_date, pb.expiry_date, pb.store_id, pb.quantity_available, pb.status, pb.metadata, pb.created_at, pb.updated_at,
    p.name as product_name,
    p.sku as product_sku,
    s.name as store_name
FROM product_batches pb
INNER JOIN products p ON pb.product_id = p.id
LEFT JOIN stores s ON pb.store_id = s.id
WHERE pb.store_id = COALESCE($2, pb.store_id)
  AND pb.status = 'active'
  AND pb.quantity_available > 0
  AND pb.expiry_date IS NOT NULL
  AND pb.expiry_date <= CURRENT_DATE + $1::interval
ORDER BY pb.expiry_date, p.name
`

type GetExpiringSoonBatchesParams struct {
	Column1 pgtype.Interval `json:"column_1"`
	StoreID pgtype.Int4     `json:"store_id"`
}

type GetExpiringSoonBatchesRow struct {
	ID                int32            `json:"id"`
	ProductID         int32            `json:"product_id"`
	ProductVariantID  pgtype.Int4      `json:"product_variant_id"`
	BatchNumber       string           `json:"batch_number"`
	ManufacturingDate pgtype.Date      `json:"manufacturing_date"`
	ExpiryDate        pgtype.Date      `json:"expiry_date"`
	StoreID           pgtype.Int4      `json:"store_id"`
	QuantityAvailable pgtype.Numeric   `json:"quantity_available"`
	Status            pgtype.Text      `json:"status"`
	Metadata          []byte           `json:"metadata"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	ProductName       string           `json:"product_name"`
	ProductSku        string           `json:"product_sku"`
	StoreName         pgtype.Text      `json:"store_name"`
}

func (q *Queries) GetExpiringSoonBatches(ctx context.Context, arg GetExpiringSoonBatchesParams) ([]GetExpiringSoonBatchesRow, error) {
	rows, err := q.db.Query(ctx, getExpiringSoonBatches, arg.Column1, arg.StoreID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpiringSoonBatchesRow
	for rows.Next() {
		var i GetExpiringSoonBatchesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.BatchNumber,
			&i.ManufacturingDate,
			&i.ExpiryDate,
			&i.StoreID,
			&i.QuantityAvailable,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductSku,
			&i.StoreName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiryCalendar = `-- name: GetExpiryCalendar :many
SELECT 
    DATE_TRUNC('month', pb.expiry_date)::date as expiry_month,
    COUNT(DISTINCT pb.id) as batch_count,
    COUNT(DISTINCT pb.product_id) as product_count,
    SUM(pb.quantity_available) as total_quantity
FROM product_batches pb
WHERE pb.store_id = COALESCE($1, pb.store_id)
  AND pb.status = 'active'
  AND pb.expiry_date IS NOT NULL
  AND pb.expiry_date >= CURRENT_DATE
GROUP BY expiry_month
ORDER BY expiry_month
`

type GetExpiryCalendarRow struct {
	ExpiryMonth   pgtype.Date `json:"expiry_month"`
	BatchCount    int64       `json:"batch_count"`
	ProductCount  int64       `json:"product_count"`
	TotalQuantity int64       `json:"total_quantity"`
}

func (q *Queries) GetExpiryCalendar(ctx context.Context, storeID pgtype.Int4) ([]GetExpiryCalendarRow, error) {
	rows, err := q.db.Query(ctx, getExpiryCalendar, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpiryCalendarRow
	for rows.Next() {
		var i GetExpiryCalendarRow
		if err := rows.Scan(
			&i.ExpiryMonth,
			&i.BatchCount,
			&i.ProductCount,
			&i.TotalQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNearExpiryProducts = `-- name: GetNearExpiryProducts :many
SELECT 
    p.id,
    p.sku,
    p.name,
    pb.batch_number,
    pb.expiry_date,
    pb.quantity_available,
    s.name as store_name,
    pb.expiry_date - CURRENT_DATE as days_until_expiry
FROM product_batches pb
INNER JOIN products p ON pb.product_id = p.id
INNER JOIN stores s ON pb.store_id = s.id
WHERE pb.status = 'active'
  AND pb.quantity_available > 0
  AND pb.expiry_date IS NOT NULL
  AND pb.expiry_date BETWEEN CURRENT_DATE AND CURRENT_DATE + $1::interval
  AND s.organization_id = $2
ORDER BY pb.expiry_date, p.name
`

type GetNearExpiryProductsParams struct {
	Column1        pgtype.Interval `json:"column_1"`
	OrganizationID int32           `json:"organization_id"`
}

type GetNearExpiryProductsRow struct {
	ID                int32          `json:"id"`
	Sku               string         `json:"sku"`
	Name              string         `json:"name"`
	BatchNumber       string         `json:"batch_number"`
	ExpiryDate        pgtype.Date    `json:"expiry_date"`
	QuantityAvailable pgtype.Numeric `json:"quantity_available"`
	StoreName         string         `json:"store_name"`
	DaysUntilExpiry   int32          `json:"days_until_expiry"`
}

func (q *Queries) GetNearExpiryProducts(ctx context.Context, arg GetNearExpiryProductsParams) ([]GetNearExpiryProductsRow, error) {
	rows, err := q.db.Query(ctx, getNearExpiryProducts, arg.Column1, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNearExpiryProductsRow
	for rows.Next() {
		var i GetNearExpiryProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Sku,
			&i.Name,
			&i.BatchNumber,
			&i.ExpiryDate,
			&i.QuantityAvailable,
			&i.StoreName,
			&i.DaysUntilExpiry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductBatch = `-- name: GetProductBatch :one
SELECT id, product_id, product_variant_id, batch_number, manufacturing_date, expiry_date, store_id, quantity_available, status, metadata, created_at, updated_at FROM product_batches WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProductBatch(ctx context.Context, id int32) (ProductBatch, error) {
	row := q.db.QueryRow(ctx, getProductBatch, id)
	var i ProductBatch
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.BatchNumber,
		&i.ManufacturingDate,
		&i.ExpiryDate,
		&i.StoreID,
		&i.QuantityAvailable,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductBatchByNumber = `-- name: GetProductBatchByNumber :one
SELECT id, product_id, product_variant_id, batch_number, manufacturing_date, expiry_date, store_id, quantity_available, status, metadata, created_at, updated_at FROM product_batches
WHERE product_id = $1
  AND batch_number = $2
  AND store_id = COALESCE($3, store_id)
LIMIT 1
`

type GetProductBatchByNumberParams struct {
	ProductID   int32       `json:"product_id"`
	BatchNumber string      `json:"batch_number"`
	StoreID     pgtype.Int4 `json:"store_id"`
}

func (q *Queries) GetProductBatchByNumber(ctx context.Context, arg GetProductBatchByNumberParams) (ProductBatch, error) {
	row := q.db.QueryRow(ctx, getProductBatchByNumber, arg.ProductID, arg.BatchNumber, arg.StoreID)
	var i ProductBatch
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.BatchNumber,
		&i.ManufacturingDate,
		&i.ExpiryDate,
		&i.StoreID,
		&i.QuantityAvailable,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSerialNumberHistory = `-- name: GetSerialNumberHistory :many

SELECT 
    sm.id, sm.movement_type, sm.reference_type, sm.reference_id, sm.product_id, sm.product_variant_id, sm.from_store_id, sm.to_store_id, sm.from_location_id, sm.to_location_id, sm.quantity, sm.uom_id, sm.batch_number, sm.serial_number, sm.movement_date, sm.posted_by, sm.status, sm.cost_per_unit, sm.total_value, sm.metadata, sm.created_at,
    p.name as product_name,
    p.sku as product_sku,
    from_store.name as from_store_name,
    to_store.name as to_store_name
FROM stock_movements sm
INNER JOIN products p ON sm.product_id = p.id
LEFT JOIN stores from_store ON sm.from_store_id = from_store.id
LEFT JOIN stores to_store ON sm.to_store_id = to_store.id
WHERE sm.serial_number = $1
ORDER BY sm.movement_date DESC
`

type GetSerialNumberHistoryRow struct {
	ID               int32            `json:"id"`
	MovementType     string           `json:"movement_type"`
	ReferenceType    pgtype.Text      `json:"reference_type"`
	ReferenceID      pgtype.Int4      `json:"reference_id"`
	ProductID        int32            `json:"product_id"`
	ProductVariantID pgtype.Int4      `json:"product_variant_id"`
	FromStoreID      pgtype.Int4      `json:"from_store_id"`
	ToStoreID        pgtype.Int4      `json:"to_store_id"`
	FromLocationID   pgtype.Int4      `json:"from_location_id"`
	ToLocationID     pgtype.Int4      `json:"to_location_id"`
	Quantity         pgtype.Numeric   `json:"quantity"`
	UomID            pgtype.Int4      `json:"uom_id"`
	BatchNumber      pgtype.Text      `json:"batch_number"`
	SerialNumber     pgtype.Text      `json:"serial_number"`
	MovementDate     pgtype.Timestamp `json:"movement_date"`
	PostedBy         pgtype.Int4      `json:"posted_by"`
	Status           pgtype.Text      `json:"status"`
	CostPerUnit      pgtype.Numeric   `json:"cost_per_unit"`
	TotalValue       pgtype.Numeric   `json:"total_value"`
	Metadata         []byte           `json:"metadata"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	ProductName      string           `json:"product_name"`
	ProductSku       string           `json:"product_sku"`
	FromStoreName    pgtype.Text      `json:"from_store_name"`
	ToStoreName      pgtype.Text      `json:"to_store_name"`
}

// =====================================================
// PRODUCT SERIAL NUMBERS
// Note: Product serial number queries are in product_serial_numbers_query.sql
// =====================================================
func (q *Queries) GetSerialNumberHistory(ctx context.Context, serialNumber pgtype.Text) ([]GetSerialNumberHistoryRow, error) {
	rows, err := q.db.Query(ctx, getSerialNumberHistory, serialNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSerialNumberHistoryRow
	for rows.Next() {
		var i GetSerialNumberHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.MovementType,
			&i.ReferenceType,
			&i.ReferenceID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.FromStoreID,
			&i.ToStoreID,
			&i.FromLocationID,
			&i.ToLocationID,
			&i.Quantity,
			&i.UomID,
			&i.BatchNumber,
			&i.SerialNumber,
			&i.MovementDate,
			&i.PostedBy,
			&i.Status,
			&i.CostPerUnit,
			&i.TotalValue,
			&i.Metadata,
			&i.CreatedAt,
			&i.ProductName,
			&i.ProductSku,
			&i.FromStoreName,
			&i.ToStoreName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSerialNumberStockSummary = `-- name: GetSerialNumberStockSummary :many
SELECT 
    p.id as product_id,
    p.name as product_name,
    p.sku as product_sku,
    s.name as store_name,
    psn.status,
    COUNT(*) as count
FROM product_serial_numbers psn
INNER JOIN products p ON psn.product_id = p.id
LEFT JOIN stores s ON psn.current_store_id = s.id
WHERE p.organization_id = $1
GROUP BY p.id, p.name, p.sku, s.name, psn.status
ORDER BY p.name, s.name
`

type GetSerialNumberStockSummaryRow struct {
	ProductID   int32       `json:"product_id"`
	ProductName string      `json:"product_name"`
	ProductSku  string      `json:"product_sku"`
	StoreName   pgtype.Text `json:"store_name"`
	Status      pgtype.Text `json:"status"`
	Count       int64       `json:"count"`
}

func (q *Queries) GetSerialNumberStockSummary(ctx context.Context, organizationID int32) ([]GetSerialNumberStockSummaryRow, error) {
	rows, err := q.db.Query(ctx, getSerialNumberStockSummary, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSerialNumberStockSummaryRow
	for rows.Next() {
		var i GetSerialNumberStockSummaryRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.ProductSku,
			&i.StoreName,
			&i.Status,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBatchesByStore = `-- name: ListBatchesByStore :many
SELECT 
    pb.id, pb.product_id, pb.product_variant_id, pb.batch_number, pb.manufacturing_date, pb.expiry_date, pb.store_id, pb.quantity_available, pb.status, pb.metadata, pb.created_at, pb.updated_at,
    p.name as product_name,
    p.sku as product_sku
FROM product_batches pb
INNER JOIN products p ON pb.product_id = p.id
WHERE pb.store_id = $1
  AND pb.status = 'active'
  AND pb.quantity_available > 0
ORDER BY p.name, pb.expiry_date NULLS LAST
`

type ListBatchesByStoreRow struct {
	ID                int32            `json:"id"`
	ProductID         int32            `json:"product_id"`
	ProductVariantID  pgtype.Int4      `json:"product_variant_id"`
	BatchNumber       string           `json:"batch_number"`
	ManufacturingDate pgtype.Date      `json:"manufacturing_date"`
	ExpiryDate        pgtype.Date      `json:"expiry_date"`
	StoreID           pgtype.Int4      `json:"store_id"`
	QuantityAvailable pgtype.Numeric   `json:"quantity_available"`
	Status            pgtype.Text      `json:"status"`
	Metadata          []byte           `json:"metadata"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	ProductName       string           `json:"product_name"`
	ProductSku        string           `json:"product_sku"`
}

func (q *Queries) ListBatchesByStore(ctx context.Context, storeID pgtype.Int4) ([]ListBatchesByStoreRow, error) {
	rows, err := q.db.Query(ctx, listBatchesByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBatchesByStoreRow
	for rows.Next() {
		var i ListBatchesByStoreRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.BatchNumber,
			&i.ManufacturingDate,
			&i.ExpiryDate,
			&i.StoreID,
			&i.QuantityAvailable,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductSku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductBatches = `-- name: ListProductBatches :many
SELECT 
    pb.id, pb.product_id, pb.product_variant_id, pb.batch_number, pb.manufacturing_date, pb.expiry_date, pb.store_id, pb.quantity_available, pb.status, pb.metadata, pb.created_at, pb.updated_at,
    p.name as product_name,
    p.sku as product_sku,
    s.name as store_name,
    s.code as store_code
FROM product_batches pb
INNER JOIN products p ON pb.product_id = p.id
LEFT JOIN stores s ON pb.store_id = s.id
WHERE pb.product_id = $1
  AND pb.product_variant_id = COALESCE($2, pb.product_variant_id)
  AND pb.store_id = COALESCE($3, pb.store_id)
  AND pb.status = COALESCE($4, pb.status)
ORDER BY pb.expiry_date NULLS LAST, pb.manufacturing_date DESC
`

type ListProductBatchesParams struct {
	ProductID        int32       `json:"product_id"`
	ProductVariantID pgtype.Int4 `json:"product_variant_id"`
	StoreID          pgtype.Int4 `json:"store_id"`
	Status           pgtype.Text `json:"status"`
}

type ListProductBatchesRow struct {
	ID                int32            `json:"id"`
	ProductID         int32            `json:"product_id"`
	ProductVariantID  pgtype.Int4      `json:"product_variant_id"`
	BatchNumber       string           `json:"batch_number"`
	ManufacturingDate pgtype.Date      `json:"manufacturing_date"`
	ExpiryDate        pgtype.Date      `json:"expiry_date"`
	StoreID           pgtype.Int4      `json:"store_id"`
	QuantityAvailable pgtype.Numeric   `json:"quantity_available"`
	Status            pgtype.Text      `json:"status"`
	Metadata          []byte           `json:"metadata"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	ProductName       string           `json:"product_name"`
	ProductSku        string           `json:"product_sku"`
	StoreName         pgtype.Text      `json:"store_name"`
	StoreCode         pgtype.Text      `json:"store_code"`
}

func (q *Queries) ListProductBatches(ctx context.Context, arg ListProductBatchesParams) ([]ListProductBatchesRow, error) {
	rows, err := q.db.Query(ctx, listProductBatches,
		arg.ProductID,
		arg.ProductVariantID,
		arg.StoreID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductBatchesRow
	for rows.Next() {
		var i ListProductBatchesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.BatchNumber,
			&i.ManufacturingDate,
			&i.ExpiryDate,
			&i.StoreID,
			&i.QuantityAvailable,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductSku,
			&i.StoreName,
			&i.StoreCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductBatch = `-- name: UpdateProductBatch :one
UPDATE product_batches
SET 
    quantity_available = COALESCE($1, quantity_available),
    status = COALESCE($2, status),
    metadata = COALESCE($3, metadata)
WHERE id = $4
RETURNING id, product_id, product_variant_id, batch_number, manufacturing_date, expiry_date, store_id, quantity_available, status, metadata, created_at, updated_at
`

type UpdateProductBatchParams struct {
	QuantityAvailable pgtype.Numeric `json:"quantity_available"`
	Status            pgtype.Text    `json:"status"`
	Metadata          []byte         `json:"metadata"`
	ID                int32          `json:"id"`
}

func (q *Queries) UpdateProductBatch(ctx context.Context, arg UpdateProductBatchParams) (ProductBatch, error) {
	row := q.db.QueryRow(ctx, updateProductBatch,
		arg.QuantityAvailable,
		arg.Status,
		arg.Metadata,
		arg.ID,
	)
	var i ProductBatch
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.BatchNumber,
		&i.ManufacturingDate,
		&i.ExpiryDate,
		&i.StoreID,
		&i.QuantityAvailable,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
