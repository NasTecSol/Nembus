// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: customers_query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
    organization_id,
    customer_code,
    name,
    customer_type,
    price_list_id,
    credit_limit,
    outstanding_balance,
    is_active,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, organization_id, customer_code, name, email, phone, address, customer_type, price_list_id, credit_limit, outstanding_balance, loyalty_points, is_active, metadata, created_at, updated_at
`

type CreateCustomerParams struct {
	OrganizationID     int32          `json:"organization_id"`
	CustomerCode       string         `json:"customer_code"`
	Name               string         `json:"name"`
	CustomerType       pgtype.Text    `json:"customer_type"`
	PriceListID        pgtype.Int4    `json:"price_list_id"`
	CreditLimit        pgtype.Numeric `json:"credit_limit"`
	OutstandingBalance pgtype.Numeric `json:"outstanding_balance"`
	IsActive           pgtype.Bool    `json:"is_active"`
	Metadata           []byte         `json:"metadata"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.OrganizationID,
		arg.CustomerCode,
		arg.Name,
		arg.CustomerType,
		arg.PriceListID,
		arg.CreditLimit,
		arg.OutstandingBalance,
		arg.IsActive,
		arg.Metadata,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.CustomerCode,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CustomerType,
		&i.PriceListID,
		&i.CreditLimit,
		&i.OutstandingBalance,
		&i.LoyaltyPoints,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customers
WHERE id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCustomer, id)
	return err
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, organization_id, customer_code, name, email, phone, address, customer_type, price_list_id, credit_limit, outstanding_balance, loyalty_points, is_active, metadata, created_at, updated_at FROM customers
WHERE id = $1
`

func (q *Queries) GetCustomer(ctx context.Context, id int32) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.CustomerCode,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CustomerType,
		&i.PriceListID,
		&i.CreditLimit,
		&i.OutstandingBalance,
		&i.LoyaltyPoints,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerByCode = `-- name: GetCustomerByCode :one
SELECT id, organization_id, customer_code, name, email, phone, address, customer_type, price_list_id, credit_limit, outstanding_balance, loyalty_points, is_active, metadata, created_at, updated_at FROM customers
WHERE organization_id = $1 AND customer_code = $2
`

type GetCustomerByCodeParams struct {
	OrganizationID int32  `json:"organization_id"`
	CustomerCode   string `json:"customer_code"`
}

func (q *Queries) GetCustomerByCode(ctx context.Context, arg GetCustomerByCodeParams) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByCode, arg.OrganizationID, arg.CustomerCode)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.CustomerCode,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CustomerType,
		&i.PriceListID,
		&i.CreditLimit,
		&i.OutstandingBalance,
		&i.LoyaltyPoints,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerCreditStatus = `-- name: GetCustomerCreditStatus :one
SELECT 
    id,
    name,
    credit_limit,
    outstanding_balance,
    (credit_limit - outstanding_balance) AS available_credit
FROM customers
WHERE id = $1
`

type GetCustomerCreditStatusRow struct {
	ID                 int32          `json:"id"`
	Name               string         `json:"name"`
	CreditLimit        pgtype.Numeric `json:"credit_limit"`
	OutstandingBalance pgtype.Numeric `json:"outstanding_balance"`
	AvailableCredit    int32          `json:"available_credit"`
}

func (q *Queries) GetCustomerCreditStatus(ctx context.Context, id int32) (GetCustomerCreditStatusRow, error) {
	row := q.db.QueryRow(ctx, getCustomerCreditStatus, id)
	var i GetCustomerCreditStatusRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreditLimit,
		&i.OutstandingBalance,
		&i.AvailableCredit,
	)
	return i, err
}

const getCustomersWithOutstandingBalance = `-- name: GetCustomersWithOutstandingBalance :many
SELECT id, organization_id, customer_code, name, email, phone, address, customer_type, price_list_id, credit_limit, outstanding_balance, loyalty_points, is_active, metadata, created_at, updated_at FROM customers
WHERE organization_id = $1 
  AND outstanding_balance > 0
  AND is_active = true
ORDER BY outstanding_balance DESC
`

func (q *Queries) GetCustomersWithOutstandingBalance(ctx context.Context, organizationID int32) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getCustomersWithOutstandingBalance, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.CustomerCode,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CustomerType,
			&i.PriceListID,
			&i.CreditLimit,
			&i.OutstandingBalance,
			&i.LoyaltyPoints,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveCustomers = `-- name: ListActiveCustomers :many
SELECT id, organization_id, customer_code, name, email, phone, address, customer_type, price_list_id, credit_limit, outstanding_balance, loyalty_points, is_active, metadata, created_at, updated_at FROM customers
WHERE organization_id = $1 AND is_active = true
ORDER BY name
`

func (q *Queries) ListActiveCustomers(ctx context.Context, organizationID int32) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listActiveCustomers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.CustomerCode,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CustomerType,
			&i.PriceListID,
			&i.CreditLimit,
			&i.OutstandingBalance,
			&i.LoyaltyPoints,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, organization_id, customer_code, name, email, phone, address, customer_type, price_list_id, credit_limit, outstanding_balance, loyalty_points, is_active, metadata, created_at, updated_at FROM customers
WHERE organization_id = $1
ORDER BY name
`

func (q *Queries) ListCustomers(ctx context.Context, organizationID int32) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listCustomers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.CustomerCode,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CustomerType,
			&i.PriceListID,
			&i.CreditLimit,
			&i.OutstandingBalance,
			&i.LoyaltyPoints,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomersByType = `-- name: ListCustomersByType :many
SELECT id, organization_id, customer_code, name, email, phone, address, customer_type, price_list_id, credit_limit, outstanding_balance, loyalty_points, is_active, metadata, created_at, updated_at FROM customers
WHERE organization_id = $1 AND customer_type = $2
ORDER BY name
`

type ListCustomersByTypeParams struct {
	OrganizationID int32       `json:"organization_id"`
	CustomerType   pgtype.Text `json:"customer_type"`
}

func (q *Queries) ListCustomersByType(ctx context.Context, arg ListCustomersByTypeParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listCustomersByType, arg.OrganizationID, arg.CustomerType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.CustomerCode,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CustomerType,
			&i.PriceListID,
			&i.CreditLimit,
			&i.OutstandingBalance,
			&i.LoyaltyPoints,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCustomers = `-- name: SearchCustomers :many
SELECT id, organization_id, customer_code, name, email, phone, address, customer_type, price_list_id, credit_limit, outstanding_balance, loyalty_points, is_active, metadata, created_at, updated_at FROM customers
WHERE organization_id = $1 
  AND (name ILIKE $2 OR customer_code ILIKE $2)
ORDER BY name
LIMIT $3
`

type SearchCustomersParams struct {
	OrganizationID int32  `json:"organization_id"`
	Name           string `json:"name"`
	Limit          int32  `json:"limit"`
}

func (q *Queries) SearchCustomers(ctx context.Context, arg SearchCustomersParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, searchCustomers, arg.OrganizationID, arg.Name, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.CustomerCode,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CustomerType,
			&i.PriceListID,
			&i.CreditLimit,
			&i.OutstandingBalance,
			&i.LoyaltyPoints,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleCustomerActive = `-- name: ToggleCustomerActive :one
UPDATE customers
SET is_active = $2
WHERE id = $1
RETURNING id, organization_id, customer_code, name, email, phone, address, customer_type, price_list_id, credit_limit, outstanding_balance, loyalty_points, is_active, metadata, created_at, updated_at
`

type ToggleCustomerActiveParams struct {
	ID       int32       `json:"id"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) ToggleCustomerActive(ctx context.Context, arg ToggleCustomerActiveParams) (Customer, error) {
	row := q.db.QueryRow(ctx, toggleCustomerActive, arg.ID, arg.IsActive)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.CustomerCode,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CustomerType,
		&i.PriceListID,
		&i.CreditLimit,
		&i.OutstandingBalance,
		&i.LoyaltyPoints,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customers
SET 
    name = $2,
    customer_type = $3,
    price_list_id = $4,
    credit_limit = $5,
    is_active = $6,
    metadata = $7
WHERE id = $1
RETURNING id, organization_id, customer_code, name, email, phone, address, customer_type, price_list_id, credit_limit, outstanding_balance, loyalty_points, is_active, metadata, created_at, updated_at
`

type UpdateCustomerParams struct {
	ID           int32          `json:"id"`
	Name         string         `json:"name"`
	CustomerType pgtype.Text    `json:"customer_type"`
	PriceListID  pgtype.Int4    `json:"price_list_id"`
	CreditLimit  pgtype.Numeric `json:"credit_limit"`
	IsActive     pgtype.Bool    `json:"is_active"`
	Metadata     []byte         `json:"metadata"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomer,
		arg.ID,
		arg.Name,
		arg.CustomerType,
		arg.PriceListID,
		arg.CreditLimit,
		arg.IsActive,
		arg.Metadata,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.CustomerCode,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CustomerType,
		&i.PriceListID,
		&i.CreditLimit,
		&i.OutstandingBalance,
		&i.LoyaltyPoints,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCustomerBalance = `-- name: UpdateCustomerBalance :one
UPDATE customers
SET outstanding_balance = outstanding_balance + $2
WHERE id = $1
RETURNING id, organization_id, customer_code, name, email, phone, address, customer_type, price_list_id, credit_limit, outstanding_balance, loyalty_points, is_active, metadata, created_at, updated_at
`

type UpdateCustomerBalanceParams struct {
	ID                 int32          `json:"id"`
	OutstandingBalance pgtype.Numeric `json:"outstanding_balance"`
}

func (q *Queries) UpdateCustomerBalance(ctx context.Context, arg UpdateCustomerBalanceParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomerBalance, arg.ID, arg.OutstandingBalance)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.CustomerCode,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CustomerType,
		&i.PriceListID,
		&i.CreditLimit,
		&i.OutstandingBalance,
		&i.LoyaltyPoints,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
