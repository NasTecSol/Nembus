// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stores.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countStores = `-- name: CountStores :one
SELECT COUNT(*) FROM stores
WHERE organization_id = $1
  AND is_active = COALESCE($2, is_active)
`

type CountStoresParams struct {
	OrganizationID int32       `json:"organization_id"`
	IsActive       pgtype.Bool `json:"is_active"`
}

func (q *Queries) CountStores(ctx context.Context, arg CountStoresParams) (int64, error) {
	row := q.db.QueryRow(ctx, countStores, arg.OrganizationID, arg.IsActive)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStore = `-- name: CreateStore :one

INSERT INTO stores (
    organization_id, parent_store_id, name, code, store_type,
    is_warehouse, is_pos_enabled, timezone, is_active, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, organization_id, parent_store_id, name, code, store_type, is_warehouse, is_pos_enabled, timezone, is_active, metadata, created_at, updated_at
`

type CreateStoreParams struct {
	OrganizationID int32       `json:"organization_id"`
	ParentStoreID  pgtype.Int4 `json:"parent_store_id"`
	Name           string      `json:"name"`
	Code           string      `json:"code"`
	StoreType      pgtype.Text `json:"store_type"`
	IsWarehouse    pgtype.Bool `json:"is_warehouse"`
	IsPosEnabled   pgtype.Bool `json:"is_pos_enabled"`
	Timezone       pgtype.Text `json:"timezone"`
	IsActive       pgtype.Bool `json:"is_active"`
	Metadata       []byte      `json:"metadata"`
}

// =====================================================
// STORES
// =====================================================
func (q *Queries) CreateStore(ctx context.Context, arg CreateStoreParams) (Store, error) {
	row := q.db.QueryRow(ctx, createStore,
		arg.OrganizationID,
		arg.ParentStoreID,
		arg.Name,
		arg.Code,
		arg.StoreType,
		arg.IsWarehouse,
		arg.IsPosEnabled,
		arg.Timezone,
		arg.IsActive,
		arg.Metadata,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ParentStoreID,
		&i.Name,
		&i.Code,
		&i.StoreType,
		&i.IsWarehouse,
		&i.IsPosEnabled,
		&i.Timezone,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteStore = `-- name: DeleteStore :exec
DELETE FROM stores WHERE id = $1
`

func (q *Queries) DeleteStore(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteStore, id)
	return err
}

const getStorageLocationHierarchy = `-- name: GetStorageLocationHierarchy :many

WITH RECURSIVE location_tree AS (
    -- Base case: top-level locations
    SELECT 
        id, store_id, code, name, location_type,
        parent_location_id, is_active, metadata,
        1 as level,
        ARRAY[id] as path
    FROM storage_locations sl_base
    WHERE sl_base.store_id = $1 AND sl_base.parent_location_id IS NULL
    
    UNION ALL
    
    -- Recursive case: child locations
    SELECT 
        sl.id, sl.store_id, sl.code, sl.name, sl.location_type,
        sl.parent_location_id, sl.is_active, sl.metadata,
        lt.level + 1,
        lt.path || sl.id
    FROM storage_locations sl
    INNER JOIN location_tree lt ON sl.parent_location_id = lt.id
)
SELECT 
    tree_data.id, tree_data.store_id, tree_data.code, tree_data.name, tree_data.location_type,
    tree_data.parent_location_id, tree_data.is_active, tree_data.metadata,
    tree_data.level, tree_data.path
FROM (
    SELECT id, store_id, code, name, location_type, parent_location_id, is_active, metadata, level, path FROM location_tree
) AS tree_data
WHERE CASE 
    WHEN $2 IS NULL THEN true
    ELSE tree_data.is_active = $2
END
ORDER BY tree_data.path
`

type GetStorageLocationHierarchyParams struct {
	StoreID        int32       `json:"store_id"`
	FilterIsActive interface{} `json:"filter_is_active"`
}

type GetStorageLocationHierarchyRow struct {
	ID               int32       `json:"id"`
	StoreID          int32       `json:"store_id"`
	Code             string      `json:"code"`
	Name             string      `json:"name"`
	LocationType     pgtype.Text `json:"location_type"`
	ParentLocationID pgtype.Int4 `json:"parent_location_id"`
	IsActive         pgtype.Bool `json:"is_active"`
	Metadata         []byte      `json:"metadata"`
	Level            int32       `json:"level"`
	Path             interface{} `json:"path"`
}

// =====================================================
// STORAGE LOCATIONS
// Note: Storage location queries are in storage_locations_query.sql
// =====================================================
func (q *Queries) GetStorageLocationHierarchy(ctx context.Context, arg GetStorageLocationHierarchyParams) ([]GetStorageLocationHierarchyRow, error) {
	rows, err := q.db.Query(ctx, getStorageLocationHierarchy, arg.StoreID, arg.FilterIsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStorageLocationHierarchyRow
	for rows.Next() {
		var i GetStorageLocationHierarchyRow
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Code,
			&i.Name,
			&i.LocationType,
			&i.ParentLocationID,
			&i.IsActive,
			&i.Metadata,
			&i.Level,
			&i.Path,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStore = `-- name: GetStore :one
SELECT id, organization_id, parent_store_id, name, code, store_type, is_warehouse, is_pos_enabled, timezone, is_active, metadata, created_at, updated_at FROM stores WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStore(ctx context.Context, id int32) (Store, error) {
	row := q.db.QueryRow(ctx, getStore, id)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ParentStoreID,
		&i.Name,
		&i.Code,
		&i.StoreType,
		&i.IsWarehouse,
		&i.IsPosEnabled,
		&i.Timezone,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStoreByCode = `-- name: GetStoreByCode :one
SELECT id, organization_id, parent_store_id, name, code, store_type, is_warehouse, is_pos_enabled, timezone, is_active, metadata, created_at, updated_at FROM stores 
WHERE organization_id = $1 AND code = $2 
LIMIT 1
`

type GetStoreByCodeParams struct {
	OrganizationID int32  `json:"organization_id"`
	Code           string `json:"code"`
}

func (q *Queries) GetStoreByCode(ctx context.Context, arg GetStoreByCodeParams) (Store, error) {
	row := q.db.QueryRow(ctx, getStoreByCode, arg.OrganizationID, arg.Code)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ParentStoreID,
		&i.Name,
		&i.Code,
		&i.StoreType,
		&i.IsWarehouse,
		&i.IsPosEnabled,
		&i.Timezone,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPOSEnabledStores = `-- name: ListPOSEnabledStores :many
SELECT id, organization_id, parent_store_id, name, code, store_type, is_warehouse, is_pos_enabled, timezone, is_active, metadata, created_at, updated_at FROM stores
WHERE organization_id = $1
  AND is_pos_enabled = true
  AND is_active = true
ORDER BY name
`

func (q *Queries) ListPOSEnabledStores(ctx context.Context, organizationID int32) ([]Store, error) {
	rows, err := q.db.Query(ctx, listPOSEnabledStores, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Store
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ParentStoreID,
			&i.Name,
			&i.Code,
			&i.StoreType,
			&i.IsWarehouse,
			&i.IsPosEnabled,
			&i.Timezone,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStores = `-- name: ListStores :many
SELECT id, organization_id, parent_store_id, name, code, store_type, is_warehouse, is_pos_enabled, timezone, is_active, metadata, created_at, updated_at FROM stores
WHERE organization_id = $1
  AND is_active = COALESCE($4, is_active)
  AND store_type = COALESCE($5, store_type)
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListStoresParams struct {
	OrganizationID int32       `json:"organization_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	IsActive       pgtype.Bool `json:"is_active"`
	StoreType      pgtype.Text `json:"store_type"`
}

func (q *Queries) ListStores(ctx context.Context, arg ListStoresParams) ([]Store, error) {
	rows, err := q.db.Query(ctx, listStores,
		arg.OrganizationID,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
		arg.StoreType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Store
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ParentStoreID,
			&i.Name,
			&i.Code,
			&i.StoreType,
			&i.IsWarehouse,
			&i.IsPosEnabled,
			&i.Timezone,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoresByParent = `-- name: ListStoresByParent :many
SELECT id, organization_id, parent_store_id, name, code, store_type, is_warehouse, is_pos_enabled, timezone, is_active, metadata, created_at, updated_at FROM stores
WHERE parent_store_id = $1 
  AND is_active = COALESCE($2, is_active)
ORDER BY name
`

type ListStoresByParentParams struct {
	ParentStoreID pgtype.Int4 `json:"parent_store_id"`
	IsActive      pgtype.Bool `json:"is_active"`
}

func (q *Queries) ListStoresByParent(ctx context.Context, arg ListStoresByParentParams) ([]Store, error) {
	rows, err := q.db.Query(ctx, listStoresByParent, arg.ParentStoreID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Store
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ParentStoreID,
			&i.Name,
			&i.Code,
			&i.StoreType,
			&i.IsWarehouse,
			&i.IsPosEnabled,
			&i.Timezone,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWarehouseStores = `-- name: ListWarehouseStores :many
SELECT id, organization_id, parent_store_id, name, code, store_type, is_warehouse, is_pos_enabled, timezone, is_active, metadata, created_at, updated_at FROM stores
WHERE organization_id = $1
  AND is_warehouse = true
  AND is_active = true
ORDER BY name
`

func (q *Queries) ListWarehouseStores(ctx context.Context, organizationID int32) ([]Store, error) {
	rows, err := q.db.Query(ctx, listWarehouseStores, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Store
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ParentStoreID,
			&i.Name,
			&i.Code,
			&i.StoreType,
			&i.IsWarehouse,
			&i.IsPosEnabled,
			&i.Timezone,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStore = `-- name: UpdateStore :one
UPDATE stores
SET 
    parent_store_id = COALESCE($1, parent_store_id),
    name = COALESCE($2, name),
    store_type = COALESCE($3, store_type),
    is_warehouse = COALESCE($4, is_warehouse),
    is_pos_enabled = COALESCE($5, is_pos_enabled),
    timezone = COALESCE($6, timezone),
    is_active = COALESCE($7, is_active),
    metadata = COALESCE($8, metadata)
WHERE id = $9
RETURNING id, organization_id, parent_store_id, name, code, store_type, is_warehouse, is_pos_enabled, timezone, is_active, metadata, created_at, updated_at
`

type UpdateStoreParams struct {
	ParentStoreID pgtype.Int4 `json:"parent_store_id"`
	Name          pgtype.Text `json:"name"`
	StoreType     pgtype.Text `json:"store_type"`
	IsWarehouse   pgtype.Bool `json:"is_warehouse"`
	IsPosEnabled  pgtype.Bool `json:"is_pos_enabled"`
	Timezone      pgtype.Text `json:"timezone"`
	IsActive      pgtype.Bool `json:"is_active"`
	Metadata      []byte      `json:"metadata"`
	ID            int32       `json:"id"`
}

func (q *Queries) UpdateStore(ctx context.Context, arg UpdateStoreParams) (Store, error) {
	row := q.db.QueryRow(ctx, updateStore,
		arg.ParentStoreID,
		arg.Name,
		arg.StoreType,
		arg.IsWarehouse,
		arg.IsPosEnabled,
		arg.Timezone,
		arg.IsActive,
		arg.Metadata,
		arg.ID,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ParentStoreID,
		&i.Name,
		&i.Code,
		&i.StoreType,
		&i.IsWarehouse,
		&i.IsPosEnabled,
		&i.Timezone,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
