// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory_stock.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLowStockProducts = `-- name: GetLowStockProducts :many
SELECT 
    s.product_id,
    p.sku,
    p.name,
    s.store_id,
    st.name AS store_name,
    s.quantity_available,
    s.reorder_level,
    s.reorder_quantity,
    s.max_stock_level
FROM inventory_stock s
JOIN products p ON s.product_id = p.id
JOIN stores st ON s.store_id = st.id
WHERE s.quantity_available <= s.reorder_level
  AND s.quantity_available > 0
  AND p.is_active = true
  AND p.track_inventory = true
ORDER BY s.quantity_available ASC, p.name
LIMIT 50
`

type GetLowStockProductsRow struct {
	ProductID         int32          `json:"product_id"`
	Sku               string         `json:"sku"`
	Name              string         `json:"name"`
	StoreID           int32          `json:"store_id"`
	StoreName         string         `json:"store_name"`
	QuantityAvailable pgtype.Numeric `json:"quantity_available"`
	ReorderLevel      pgtype.Numeric `json:"reorder_level"`
	ReorderQuantity   pgtype.Numeric `json:"reorder_quantity"`
	MaxStockLevel     pgtype.Numeric `json:"max_stock_level"`
}

func (q *Queries) GetLowStockProducts(ctx context.Context) ([]GetLowStockProductsRow, error) {
	rows, err := q.db.Query(ctx, getLowStockProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLowStockProductsRow
	for rows.Next() {
		var i GetLowStockProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Sku,
			&i.Name,
			&i.StoreID,
			&i.StoreName,
			&i.QuantityAvailable,
			&i.ReorderLevel,
			&i.ReorderQuantity,
			&i.MaxStockLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockValuationByStore = `-- name: GetStockValuationByStore :many
SELECT 
    s.store_id,
    st.name AS store_name,
    COUNT(DISTINCT s.product_id) AS unique_products,
    SUM(s.quantity_on_hand * COALESCE((
        SELECT AVG(pp.price)
        FROM product_prices pp
        WHERE pp.product_id = s.product_id
          AND pp.is_active = true
    ), 0)) AS total_stock_value
FROM inventory_stock s
JOIN stores st ON s.store_id = st.id
WHERE st.organization_id = $1
GROUP BY s.store_id, st.name
ORDER BY total_stock_value DESC
`

type GetStockValuationByStoreRow struct {
	StoreID         int32  `json:"store_id"`
	StoreName       string `json:"store_name"`
	UniqueProducts  int64  `json:"unique_products"`
	TotalStockValue int64  `json:"total_stock_value"`
}

func (q *Queries) GetStockValuationByStore(ctx context.Context, orgID int32) ([]GetStockValuationByStoreRow, error) {
	rows, err := q.db.Query(ctx, getStockValuationByStore, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStockValuationByStoreRow
	for rows.Next() {
		var i GetStockValuationByStoreRow
		if err := rows.Scan(
			&i.StoreID,
			&i.StoreName,
			&i.UniqueProducts,
			&i.TotalStockValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
