// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stock_counts_query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveStockCount = `-- name: ApproveStockCount :one
UPDATE stock_counts
SET 
    status = 'approved',
    approved_by = $2
WHERE id = $1
RETURNING id, count_number, store_id, storage_location_id, count_type, status, scheduled_date, started_at, completed_at, counted_by, approved_by, metadata, created_at
`

type ApproveStockCountParams struct {
	ID         int32       `json:"id"`
	ApprovedBy pgtype.Int4 `json:"approved_by"`
}

func (q *Queries) ApproveStockCount(ctx context.Context, arg ApproveStockCountParams) (StockCount, error) {
	row := q.db.QueryRow(ctx, approveStockCount, arg.ID, arg.ApprovedBy)
	var i StockCount
	err := row.Scan(
		&i.ID,
		&i.CountNumber,
		&i.StoreID,
		&i.StorageLocationID,
		&i.CountType,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CountedBy,
		&i.ApprovedBy,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const completeStockCount = `-- name: CompleteStockCount :one
UPDATE stock_counts
SET 
    status = 'completed',
    completed_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, count_number, store_id, storage_location_id, count_type, status, scheduled_date, started_at, completed_at, counted_by, approved_by, metadata, created_at
`

func (q *Queries) CompleteStockCount(ctx context.Context, id int32) (StockCount, error) {
	row := q.db.QueryRow(ctx, completeStockCount, id)
	var i StockCount
	err := row.Scan(
		&i.ID,
		&i.CountNumber,
		&i.StoreID,
		&i.StorageLocationID,
		&i.CountType,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CountedBy,
		&i.ApprovedBy,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createStockCount = `-- name: CreateStockCount :one
INSERT INTO stock_counts (
    count_number,
    store_id,
    count_type,
    status,
    scheduled_date,
    counted_by,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, count_number, store_id, storage_location_id, count_type, status, scheduled_date, started_at, completed_at, counted_by, approved_by, metadata, created_at
`

type CreateStockCountParams struct {
	CountNumber   string      `json:"count_number"`
	StoreID       int32       `json:"store_id"`
	CountType     pgtype.Text `json:"count_type"`
	Status        pgtype.Text `json:"status"`
	ScheduledDate pgtype.Date `json:"scheduled_date"`
	CountedBy     pgtype.Int4 `json:"counted_by"`
	Metadata      []byte      `json:"metadata"`
}

func (q *Queries) CreateStockCount(ctx context.Context, arg CreateStockCountParams) (StockCount, error) {
	row := q.db.QueryRow(ctx, createStockCount,
		arg.CountNumber,
		arg.StoreID,
		arg.CountType,
		arg.Status,
		arg.ScheduledDate,
		arg.CountedBy,
		arg.Metadata,
	)
	var i StockCount
	err := row.Scan(
		&i.ID,
		&i.CountNumber,
		&i.StoreID,
		&i.StorageLocationID,
		&i.CountType,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CountedBy,
		&i.ApprovedBy,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createStockCountLine = `-- name: CreateStockCountLine :one
INSERT INTO stock_count_lines (
    stock_count_id,
    product_id,
    product_variant_id,
    storage_location_id,
    system_quantity,
    counted_quantity,
    variance,
    variance_value,
    batch_number,
    serial_number,
    counted_at,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, stock_count_id, product_id, product_variant_id, storage_location_id, expected_quantity, system_quantity, counted_quantity, variance, variance_value, counted_at, uom_id, batch_number, serial_number, metadata, created_at
`

type CreateStockCountLineParams struct {
	StockCountID      int32            `json:"stock_count_id"`
	ProductID         int32            `json:"product_id"`
	ProductVariantID  pgtype.Int4      `json:"product_variant_id"`
	StorageLocationID pgtype.Int4      `json:"storage_location_id"`
	SystemQuantity    pgtype.Numeric   `json:"system_quantity"`
	CountedQuantity   pgtype.Numeric   `json:"counted_quantity"`
	Variance          pgtype.Numeric   `json:"variance"`
	VarianceValue     pgtype.Numeric   `json:"variance_value"`
	BatchNumber       pgtype.Text      `json:"batch_number"`
	SerialNumber      pgtype.Text      `json:"serial_number"`
	CountedAt         pgtype.Timestamp `json:"counted_at"`
	Metadata          []byte           `json:"metadata"`
}

func (q *Queries) CreateStockCountLine(ctx context.Context, arg CreateStockCountLineParams) (StockCountLine, error) {
	row := q.db.QueryRow(ctx, createStockCountLine,
		arg.StockCountID,
		arg.ProductID,
		arg.ProductVariantID,
		arg.StorageLocationID,
		arg.SystemQuantity,
		arg.CountedQuantity,
		arg.Variance,
		arg.VarianceValue,
		arg.BatchNumber,
		arg.SerialNumber,
		arg.CountedAt,
		arg.Metadata,
	)
	var i StockCountLine
	err := row.Scan(
		&i.ID,
		&i.StockCountID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.StorageLocationID,
		&i.ExpectedQuantity,
		&i.SystemQuantity,
		&i.CountedQuantity,
		&i.Variance,
		&i.VarianceValue,
		&i.CountedAt,
		&i.UomID,
		&i.BatchNumber,
		&i.SerialNumber,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const deleteStockCount = `-- name: DeleteStockCount :exec
DELETE FROM stock_counts
WHERE id = $1
`

func (q *Queries) DeleteStockCount(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteStockCount, id)
	return err
}

const deleteStockCountLine = `-- name: DeleteStockCountLine :exec
DELETE FROM stock_count_lines
WHERE id = $1
`

func (q *Queries) DeleteStockCountLine(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteStockCountLine, id)
	return err
}

const getStockCount = `-- name: GetStockCount :one
SELECT id, count_number, store_id, storage_location_id, count_type, status, scheduled_date, started_at, completed_at, counted_by, approved_by, metadata, created_at FROM stock_counts
WHERE id = $1
`

func (q *Queries) GetStockCount(ctx context.Context, id int32) (StockCount, error) {
	row := q.db.QueryRow(ctx, getStockCount, id)
	var i StockCount
	err := row.Scan(
		&i.ID,
		&i.CountNumber,
		&i.StoreID,
		&i.StorageLocationID,
		&i.CountType,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CountedBy,
		&i.ApprovedBy,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getStockCountByNumber = `-- name: GetStockCountByNumber :one
SELECT id, count_number, store_id, storage_location_id, count_type, status, scheduled_date, started_at, completed_at, counted_by, approved_by, metadata, created_at FROM stock_counts
WHERE count_number = $1
`

func (q *Queries) GetStockCountByNumber(ctx context.Context, countNumber string) (StockCount, error) {
	row := q.db.QueryRow(ctx, getStockCountByNumber, countNumber)
	var i StockCount
	err := row.Scan(
		&i.ID,
		&i.CountNumber,
		&i.StoreID,
		&i.StorageLocationID,
		&i.CountType,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CountedBy,
		&i.ApprovedBy,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getStockCountLine = `-- name: GetStockCountLine :one
SELECT id, stock_count_id, product_id, product_variant_id, storage_location_id, expected_quantity, system_quantity, counted_quantity, variance, variance_value, counted_at, uom_id, batch_number, serial_number, metadata, created_at FROM stock_count_lines
WHERE id = $1
`

func (q *Queries) GetStockCountLine(ctx context.Context, id int32) (StockCountLine, error) {
	row := q.db.QueryRow(ctx, getStockCountLine, id)
	var i StockCountLine
	err := row.Scan(
		&i.ID,
		&i.StockCountID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.StorageLocationID,
		&i.ExpectedQuantity,
		&i.SystemQuantity,
		&i.CountedQuantity,
		&i.Variance,
		&i.VarianceValue,
		&i.CountedAt,
		&i.UomID,
		&i.BatchNumber,
		&i.SerialNumber,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getStockCountSummary = `-- name: GetStockCountSummary :one
SELECT 
    COUNT(*) AS total_lines,
    SUM(CASE WHEN variance != 0 THEN 1 ELSE 0 END) AS lines_with_variance,
    SUM(variance_value) AS total_variance_value,
    SUM(CASE WHEN variance > 0 THEN variance_value ELSE 0 END) AS positive_variance,
    SUM(CASE WHEN variance < 0 THEN variance_value ELSE 0 END) AS negative_variance
FROM stock_count_lines
WHERE stock_count_id = $1
`

type GetStockCountSummaryRow struct {
	TotalLines         int64 `json:"total_lines"`
	LinesWithVariance  int64 `json:"lines_with_variance"`
	TotalVarianceValue int64 `json:"total_variance_value"`
	PositiveVariance   int64 `json:"positive_variance"`
	NegativeVariance   int64 `json:"negative_variance"`
}

func (q *Queries) GetStockCountSummary(ctx context.Context, stockCountID int32) (GetStockCountSummaryRow, error) {
	row := q.db.QueryRow(ctx, getStockCountSummary, stockCountID)
	var i GetStockCountSummaryRow
	err := row.Scan(
		&i.TotalLines,
		&i.LinesWithVariance,
		&i.TotalVarianceValue,
		&i.PositiveVariance,
		&i.NegativeVariance,
	)
	return i, err
}

const listStockCountLines = `-- name: ListStockCountLines :many
SELECT id, stock_count_id, product_id, product_variant_id, storage_location_id, expected_quantity, system_quantity, counted_quantity, variance, variance_value, counted_at, uom_id, batch_number, serial_number, metadata, created_at FROM stock_count_lines
WHERE stock_count_id = $1
ORDER BY id
`

func (q *Queries) ListStockCountLines(ctx context.Context, stockCountID int32) ([]StockCountLine, error) {
	rows, err := q.db.Query(ctx, listStockCountLines, stockCountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StockCountLine
	for rows.Next() {
		var i StockCountLine
		if err := rows.Scan(
			&i.ID,
			&i.StockCountID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.StorageLocationID,
			&i.ExpectedQuantity,
			&i.SystemQuantity,
			&i.CountedQuantity,
			&i.Variance,
			&i.VarianceValue,
			&i.CountedAt,
			&i.UomID,
			&i.BatchNumber,
			&i.SerialNumber,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStockCounts = `-- name: ListStockCounts :many
SELECT id, count_number, store_id, storage_location_id, count_type, status, scheduled_date, started_at, completed_at, counted_by, approved_by, metadata, created_at FROM stock_counts
ORDER BY created_at DESC
`

func (q *Queries) ListStockCounts(ctx context.Context) ([]StockCount, error) {
	rows, err := q.db.Query(ctx, listStockCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StockCount
	for rows.Next() {
		var i StockCount
		if err := rows.Scan(
			&i.ID,
			&i.CountNumber,
			&i.StoreID,
			&i.StorageLocationID,
			&i.CountType,
			&i.Status,
			&i.ScheduledDate,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CountedBy,
			&i.ApprovedBy,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStockCountsByStatus = `-- name: ListStockCountsByStatus :many
SELECT id, count_number, store_id, storage_location_id, count_type, status, scheduled_date, started_at, completed_at, counted_by, approved_by, metadata, created_at FROM stock_counts
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) ListStockCountsByStatus(ctx context.Context, status pgtype.Text) ([]StockCount, error) {
	rows, err := q.db.Query(ctx, listStockCountsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StockCount
	for rows.Next() {
		var i StockCount
		if err := rows.Scan(
			&i.ID,
			&i.CountNumber,
			&i.StoreID,
			&i.StorageLocationID,
			&i.CountType,
			&i.Status,
			&i.ScheduledDate,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CountedBy,
			&i.ApprovedBy,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStockCountsByStore = `-- name: ListStockCountsByStore :many
SELECT id, count_number, store_id, storage_location_id, count_type, status, scheduled_date, started_at, completed_at, counted_by, approved_by, metadata, created_at FROM stock_counts
WHERE store_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListStockCountsByStore(ctx context.Context, storeID int32) ([]StockCount, error) {
	rows, err := q.db.Query(ctx, listStockCountsByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StockCount
	for rows.Next() {
		var i StockCount
		if err := rows.Scan(
			&i.ID,
			&i.CountNumber,
			&i.StoreID,
			&i.StorageLocationID,
			&i.CountType,
			&i.Status,
			&i.ScheduledDate,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CountedBy,
			&i.ApprovedBy,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startStockCount = `-- name: StartStockCount :one
UPDATE stock_counts
SET 
    status = 'in_progress',
    started_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, count_number, store_id, storage_location_id, count_type, status, scheduled_date, started_at, completed_at, counted_by, approved_by, metadata, created_at
`

func (q *Queries) StartStockCount(ctx context.Context, id int32) (StockCount, error) {
	row := q.db.QueryRow(ctx, startStockCount, id)
	var i StockCount
	err := row.Scan(
		&i.ID,
		&i.CountNumber,
		&i.StoreID,
		&i.StorageLocationID,
		&i.CountType,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CountedBy,
		&i.ApprovedBy,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const updateStockCount = `-- name: UpdateStockCount :one
UPDATE stock_counts
SET 
    status = $2,
    metadata = $3
WHERE id = $1
RETURNING id, count_number, store_id, storage_location_id, count_type, status, scheduled_date, started_at, completed_at, counted_by, approved_by, metadata, created_at
`

type UpdateStockCountParams struct {
	ID       int32       `json:"id"`
	Status   pgtype.Text `json:"status"`
	Metadata []byte      `json:"metadata"`
}

func (q *Queries) UpdateStockCount(ctx context.Context, arg UpdateStockCountParams) (StockCount, error) {
	row := q.db.QueryRow(ctx, updateStockCount, arg.ID, arg.Status, arg.Metadata)
	var i StockCount
	err := row.Scan(
		&i.ID,
		&i.CountNumber,
		&i.StoreID,
		&i.StorageLocationID,
		&i.CountType,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CountedBy,
		&i.ApprovedBy,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const updateStockCountLine = `-- name: UpdateStockCountLine :one
UPDATE stock_count_lines
SET 
    counted_quantity = $2,
    variance = $3,
    variance_value = $4,
    counted_at = $5
WHERE id = $1
RETURNING id, stock_count_id, product_id, product_variant_id, storage_location_id, expected_quantity, system_quantity, counted_quantity, variance, variance_value, counted_at, uom_id, batch_number, serial_number, metadata, created_at
`

type UpdateStockCountLineParams struct {
	ID              int32            `json:"id"`
	CountedQuantity pgtype.Numeric   `json:"counted_quantity"`
	Variance        pgtype.Numeric   `json:"variance"`
	VarianceValue   pgtype.Numeric   `json:"variance_value"`
	CountedAt       pgtype.Timestamp `json:"counted_at"`
}

func (q *Queries) UpdateStockCountLine(ctx context.Context, arg UpdateStockCountLineParams) (StockCountLine, error) {
	row := q.db.QueryRow(ctx, updateStockCountLine,
		arg.ID,
		arg.CountedQuantity,
		arg.Variance,
		arg.VarianceValue,
		arg.CountedAt,
	)
	var i StockCountLine
	err := row.Scan(
		&i.ID,
		&i.StockCountID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.StorageLocationID,
		&i.ExpectedQuantity,
		&i.SystemQuantity,
		&i.CountedQuantity,
		&i.Variance,
		&i.VarianceValue,
		&i.CountedAt,
		&i.UomID,
		&i.BatchNumber,
		&i.SerialNumber,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}
