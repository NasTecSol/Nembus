// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: suppliers_query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSupplier = `-- name: CreateSupplier :one
INSERT INTO suppliers (
    organization_id,
    name,
    code,
    supplier_type,
    payment_terms,
    credit_limit,
    is_active,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, organization_id, code, name, supplier_type, credit_limit, contact_person, email, phone, address, currency_code, payment_terms, tax_id, is_active, metadata, created_at, updated_at
`

type CreateSupplierParams struct {
	OrganizationID int32          `json:"organization_id"`
	Name           string         `json:"name"`
	Code           string         `json:"code"`
	SupplierType   pgtype.Text    `json:"supplier_type"`
	PaymentTerms   pgtype.Text    `json:"payment_terms"`
	CreditLimit    pgtype.Numeric `json:"credit_limit"`
	IsActive       pgtype.Bool    `json:"is_active"`
	Metadata       []byte         `json:"metadata"`
}

func (q *Queries) CreateSupplier(ctx context.Context, arg CreateSupplierParams) (Supplier, error) {
	row := q.db.QueryRow(ctx, createSupplier,
		arg.OrganizationID,
		arg.Name,
		arg.Code,
		arg.SupplierType,
		arg.PaymentTerms,
		arg.CreditLimit,
		arg.IsActive,
		arg.Metadata,
	)
	var i Supplier
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Code,
		&i.Name,
		&i.SupplierType,
		&i.CreditLimit,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CurrencyCode,
		&i.PaymentTerms,
		&i.TaxID,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSupplier = `-- name: DeleteSupplier :exec
DELETE FROM suppliers
WHERE id = $1
`

func (q *Queries) DeleteSupplier(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteSupplier, id)
	return err
}

const getSupplier = `-- name: GetSupplier :one
SELECT id, organization_id, code, name, supplier_type, credit_limit, contact_person, email, phone, address, currency_code, payment_terms, tax_id, is_active, metadata, created_at, updated_at FROM suppliers
WHERE id = $1
`

func (q *Queries) GetSupplier(ctx context.Context, id int32) (Supplier, error) {
	row := q.db.QueryRow(ctx, getSupplier, id)
	var i Supplier
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Code,
		&i.Name,
		&i.SupplierType,
		&i.CreditLimit,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CurrencyCode,
		&i.PaymentTerms,
		&i.TaxID,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSupplierByCode = `-- name: GetSupplierByCode :one
SELECT id, organization_id, code, name, supplier_type, credit_limit, contact_person, email, phone, address, currency_code, payment_terms, tax_id, is_active, metadata, created_at, updated_at FROM suppliers
WHERE organization_id = $1 AND code = $2
`

type GetSupplierByCodeParams struct {
	OrganizationID int32  `json:"organization_id"`
	Code           string `json:"code"`
}

func (q *Queries) GetSupplierByCode(ctx context.Context, arg GetSupplierByCodeParams) (Supplier, error) {
	row := q.db.QueryRow(ctx, getSupplierByCode, arg.OrganizationID, arg.Code)
	var i Supplier
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Code,
		&i.Name,
		&i.SupplierType,
		&i.CreditLimit,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CurrencyCode,
		&i.PaymentTerms,
		&i.TaxID,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveSuppliers = `-- name: ListActiveSuppliers :many
SELECT id, organization_id, code, name, supplier_type, credit_limit, contact_person, email, phone, address, currency_code, payment_terms, tax_id, is_active, metadata, created_at, updated_at FROM suppliers
WHERE organization_id = $1 AND is_active = true
ORDER BY name
`

func (q *Queries) ListActiveSuppliers(ctx context.Context, organizationID int32) ([]Supplier, error) {
	rows, err := q.db.Query(ctx, listActiveSuppliers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supplier
	for rows.Next() {
		var i Supplier
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Code,
			&i.Name,
			&i.SupplierType,
			&i.CreditLimit,
			&i.ContactPerson,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CurrencyCode,
			&i.PaymentTerms,
			&i.TaxID,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSuppliers = `-- name: ListSuppliers :many
SELECT id, organization_id, code, name, supplier_type, credit_limit, contact_person, email, phone, address, currency_code, payment_terms, tax_id, is_active, metadata, created_at, updated_at FROM suppliers
WHERE organization_id = $1
ORDER BY name
`

func (q *Queries) ListSuppliers(ctx context.Context, organizationID int32) ([]Supplier, error) {
	rows, err := q.db.Query(ctx, listSuppliers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supplier
	for rows.Next() {
		var i Supplier
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Code,
			&i.Name,
			&i.SupplierType,
			&i.CreditLimit,
			&i.ContactPerson,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CurrencyCode,
			&i.PaymentTerms,
			&i.TaxID,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSuppliersByType = `-- name: ListSuppliersByType :many
SELECT id, organization_id, code, name, supplier_type, credit_limit, contact_person, email, phone, address, currency_code, payment_terms, tax_id, is_active, metadata, created_at, updated_at FROM suppliers
WHERE organization_id = $1 AND supplier_type = $2
ORDER BY name
`

type ListSuppliersByTypeParams struct {
	OrganizationID int32       `json:"organization_id"`
	SupplierType   pgtype.Text `json:"supplier_type"`
}

func (q *Queries) ListSuppliersByType(ctx context.Context, arg ListSuppliersByTypeParams) ([]Supplier, error) {
	rows, err := q.db.Query(ctx, listSuppliersByType, arg.OrganizationID, arg.SupplierType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supplier
	for rows.Next() {
		var i Supplier
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Code,
			&i.Name,
			&i.SupplierType,
			&i.CreditLimit,
			&i.ContactPerson,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CurrencyCode,
			&i.PaymentTerms,
			&i.TaxID,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSuppliers = `-- name: SearchSuppliers :many
SELECT id, organization_id, code, name, supplier_type, credit_limit, contact_person, email, phone, address, currency_code, payment_terms, tax_id, is_active, metadata, created_at, updated_at FROM suppliers
WHERE organization_id = $1 
  AND (name ILIKE $2 OR code ILIKE $2)
ORDER BY name
LIMIT $3
`

type SearchSuppliersParams struct {
	OrganizationID int32  `json:"organization_id"`
	Name           string `json:"name"`
	Limit          int32  `json:"limit"`
}

func (q *Queries) SearchSuppliers(ctx context.Context, arg SearchSuppliersParams) ([]Supplier, error) {
	rows, err := q.db.Query(ctx, searchSuppliers, arg.OrganizationID, arg.Name, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supplier
	for rows.Next() {
		var i Supplier
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Code,
			&i.Name,
			&i.SupplierType,
			&i.CreditLimit,
			&i.ContactPerson,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CurrencyCode,
			&i.PaymentTerms,
			&i.TaxID,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleSupplierActive = `-- name: ToggleSupplierActive :one
UPDATE suppliers
SET is_active = $2
WHERE id = $1
RETURNING id, organization_id, code, name, supplier_type, credit_limit, contact_person, email, phone, address, currency_code, payment_terms, tax_id, is_active, metadata, created_at, updated_at
`

type ToggleSupplierActiveParams struct {
	ID       int32       `json:"id"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) ToggleSupplierActive(ctx context.Context, arg ToggleSupplierActiveParams) (Supplier, error) {
	row := q.db.QueryRow(ctx, toggleSupplierActive, arg.ID, arg.IsActive)
	var i Supplier
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Code,
		&i.Name,
		&i.SupplierType,
		&i.CreditLimit,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CurrencyCode,
		&i.PaymentTerms,
		&i.TaxID,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSupplier = `-- name: UpdateSupplier :one
UPDATE suppliers
SET 
    name = $2,
    supplier_type = $3,
    payment_terms = $4,
    credit_limit = $5,
    is_active = $6,
    metadata = $7
WHERE id = $1
RETURNING id, organization_id, code, name, supplier_type, credit_limit, contact_person, email, phone, address, currency_code, payment_terms, tax_id, is_active, metadata, created_at, updated_at
`

type UpdateSupplierParams struct {
	ID           int32          `json:"id"`
	Name         string         `json:"name"`
	SupplierType pgtype.Text    `json:"supplier_type"`
	PaymentTerms pgtype.Text    `json:"payment_terms"`
	CreditLimit  pgtype.Numeric `json:"credit_limit"`
	IsActive     pgtype.Bool    `json:"is_active"`
	Metadata     []byte         `json:"metadata"`
}

func (q *Queries) UpdateSupplier(ctx context.Context, arg UpdateSupplierParams) (Supplier, error) {
	row := q.db.QueryRow(ctx, updateSupplier,
		arg.ID,
		arg.Name,
		arg.SupplierType,
		arg.PaymentTerms,
		arg.CreditLimit,
		arg.IsActive,
		arg.Metadata,
	)
	var i Supplier
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Code,
		&i.Name,
		&i.SupplierType,
		&i.CreditLimit,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CurrencyCode,
		&i.PaymentTerms,
		&i.TaxID,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
