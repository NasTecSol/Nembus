// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product_categories.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCategoryWithPath = `-- name: GetCategoryWithPath :one
WITH RECURSIVE cat_path AS (
    SELECT pc.id, pc.parent_category_id, pc.name, pc.code, ARRAY[pc.id] AS path
    FROM product_categories pc
    WHERE pc.id = $1
    
    UNION ALL
    
    SELECT c.id, c.parent_category_id, c.name, c.code, cp.path || c.id
    FROM product_categories c
    INNER JOIN cat_path cp ON c.id = cp.parent_category_id
),
filtered_path AS (
    SELECT id, name, code, parent_category_id, path
    FROM cat_path
    WHERE id = $1
)
SELECT 
    fp.id, fp.name, fp.code, fp.parent_category_id,
    array_length(fp.path, 1) - 1 AS depth,
    parent_cat.name AS parent_name
FROM filtered_path fp
LEFT JOIN product_categories parent_cat ON parent_cat.id = (fp.path[array_length(fp.path,1)-2])
`

type GetCategoryWithPathRow struct {
	ID               int32       `json:"id"`
	Name             string      `json:"name"`
	Code             string      `json:"code"`
	ParentCategoryID pgtype.Int4 `json:"parent_category_id"`
	Depth            int32       `json:"depth"`
	ParentName       pgtype.Text `json:"parent_name"`
}

func (q *Queries) GetCategoryWithPath(ctx context.Context, id int32) (GetCategoryWithPathRow, error) {
	row := q.db.QueryRow(ctx, getCategoryWithPath, id)
	var i GetCategoryWithPathRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.ParentCategoryID,
		&i.Depth,
		&i.ParentName,
	)
	return i, err
}

const getLeafCategories = `-- name: GetLeafCategories :many
SELECT c.id, c.parent_category_id, c.name, c.code, c.description, c.category_level, c.is_active, c.metadata, c.created_at, c.updated_at
FROM product_categories c
WHERE c.is_active = true
  AND NOT EXISTS (
      SELECT 1 FROM product_categories child 
      WHERE child.parent_category_id = c.id AND child.is_active = true
  )
ORDER BY c.name
`

func (q *Queries) GetLeafCategories(ctx context.Context) ([]ProductCategory, error) {
	rows, err := q.db.Query(ctx, getLeafCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductCategory
	for rows.Next() {
		var i ProductCategory
		if err := rows.Scan(
			&i.ID,
			&i.ParentCategoryID,
			&i.Name,
			&i.Code,
			&i.Description,
			&i.CategoryLevel,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriesWithUsageCount = `-- name: ListCategoriesWithUsageCount :many
SELECT 
    c.id, c.name, c.code, c.parent_category_id, c.is_active,
    COUNT(p.id) AS product_count
FROM product_categories c
LEFT JOIN products p ON p.category_id = c.id AND p.is_active = true
WHERE c.is_active = $1
GROUP BY c.id
ORDER BY product_count DESC, c.name
LIMIT $2
`

type ListCategoriesWithUsageCountParams struct {
	ActiveOnly pgtype.Bool `json:"active_only"`
	Limit      int32       `json:"limit"`
}

type ListCategoriesWithUsageCountRow struct {
	ID               int32       `json:"id"`
	Name             string      `json:"name"`
	Code             string      `json:"code"`
	ParentCategoryID pgtype.Int4 `json:"parent_category_id"`
	IsActive         pgtype.Bool `json:"is_active"`
	ProductCount     int64       `json:"product_count"`
}

func (q *Queries) ListCategoriesWithUsageCount(ctx context.Context, arg ListCategoriesWithUsageCountParams) ([]ListCategoriesWithUsageCountRow, error) {
	rows, err := q.db.Query(ctx, listCategoriesWithUsageCount, arg.ActiveOnly, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoriesWithUsageCountRow
	for rows.Next() {
		var i ListCategoriesWithUsageCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.ParentCategoryID,
			&i.IsActive,
			&i.ProductCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
