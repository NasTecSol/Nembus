// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pos_products.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPOSCategories = `-- name: GetPOSCategories :many
SELECT category_id, category_code, category_name, parent_category_id, parent_category_name, product_count, in_stock_count, category_metadata FROM vw_pos_categories
`

func (q *Queries) GetPOSCategories(ctx context.Context) ([]VwPosCategory, error) {
	rows, err := q.db.Query(ctx, getPOSCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VwPosCategory
	for rows.Next() {
		var i VwPosCategory
		if err := rows.Scan(
			&i.CategoryID,
			&i.CategoryCode,
			&i.CategoryName,
			&i.ParentCategoryID,
			&i.ParentCategoryName,
			&i.ProductCount,
			&i.InStockCount,
			&i.CategoryMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPOSProductByBarcode = `-- name: GetPOSProductByBarcode :one
SELECT
    cat.product_id, cat.sku, cat.product_name, cat.description, cat.product_type, cat.category_id, cat.category_name, cat.category_code, cat.parent_category_id, cat.parent_category_name, cat.brand_id, cat.brand_name, cat.uom_id, cat.uom_code, cat.uom_name, cat.decimal_places, cat.barcode, cat.barcode_type, cat.tax_category_id, cat.tax_category_name, cat.tax_rate, cat.tax_is_inclusive, cat.retail_price, cat.retail_price_id, cat.promo_price, cat.promo_price_id, cat.promo_min_quantity, cat.promo_valid_from, cat.promo_valid_to, cat.promotion_name, cat.discount_percent, cat.effective_price, cat.has_active_promotion, cat.is_active, cat.is_sellable, cat.is_serialized, cat.is_batch_managed, cat.allow_decimal_quantity, cat.track_inventory, cat.product_metadata,
    COALESCE(inv.quantity_available, 0.0)::numeric as quantity_available,
    CASE WHEN COALESCE(inv.quantity_available, 0) > 0 THEN true ELSE false END as is_in_stock
FROM vw_pos_product_catalog cat
LEFT JOIN inventory_stock inv
    ON cat.product_id = inv.product_id
    AND inv.store_id = $1
WHERE cat.barcode = $2
LIMIT 1
`

type GetPOSProductByBarcodeParams struct {
	StoreID int32       `json:"store_id"`
	Barcode pgtype.Text `json:"barcode"`
}

type GetPOSProductByBarcodeRow struct {
	ProductID            int32          `json:"product_id"`
	Sku                  string         `json:"sku"`
	ProductName          string         `json:"product_name"`
	Description          pgtype.Text    `json:"description"`
	ProductType          pgtype.Text    `json:"product_type"`
	CategoryID           pgtype.Int4    `json:"category_id"`
	CategoryName         pgtype.Text    `json:"category_name"`
	CategoryCode         pgtype.Text    `json:"category_code"`
	ParentCategoryID     pgtype.Int4    `json:"parent_category_id"`
	ParentCategoryName   pgtype.Text    `json:"parent_category_name"`
	BrandID              pgtype.Int4    `json:"brand_id"`
	BrandName            pgtype.Text    `json:"brand_name"`
	UomID                pgtype.Int4    `json:"uom_id"`
	UomCode              pgtype.Text    `json:"uom_code"`
	UomName              pgtype.Text    `json:"uom_name"`
	DecimalPlaces        pgtype.Int4    `json:"decimal_places"`
	Barcode              pgtype.Text    `json:"barcode"`
	BarcodeType          pgtype.Text    `json:"barcode_type"`
	TaxCategoryID        pgtype.Int4    `json:"tax_category_id"`
	TaxCategoryName      pgtype.Text    `json:"tax_category_name"`
	TaxRate              pgtype.Numeric `json:"tax_rate"`
	TaxIsInclusive       pgtype.Bool    `json:"tax_is_inclusive"`
	RetailPrice          pgtype.Numeric `json:"retail_price"`
	RetailPriceID        pgtype.Int4    `json:"retail_price_id"`
	PromoPrice           pgtype.Numeric `json:"promo_price"`
	PromoPriceID         pgtype.Int4    `json:"promo_price_id"`
	PromoMinQuantity     pgtype.Numeric `json:"promo_min_quantity"`
	PromoValidFrom       pgtype.Date    `json:"promo_valid_from"`
	PromoValidTo         pgtype.Date    `json:"promo_valid_to"`
	PromotionName        pgtype.Text    `json:"promotion_name"`
	DiscountPercent      pgtype.Text    `json:"discount_percent"`
	EffectivePrice       pgtype.Numeric `json:"effective_price"`
	HasActivePromotion   bool           `json:"has_active_promotion"`
	IsActive             pgtype.Bool    `json:"is_active"`
	IsSellable           pgtype.Bool    `json:"is_sellable"`
	IsSerialized         pgtype.Bool    `json:"is_serialized"`
	IsBatchManaged       pgtype.Bool    `json:"is_batch_managed"`
	AllowDecimalQuantity pgtype.Bool    `json:"allow_decimal_quantity"`
	TrackInventory       pgtype.Bool    `json:"track_inventory"`
	ProductMetadata      []byte         `json:"product_metadata"`
	QuantityAvailable    pgtype.Numeric `json:"quantity_available"`
	IsInStock            bool           `json:"is_in_stock"`
}

func (q *Queries) GetPOSProductByBarcode(ctx context.Context, arg GetPOSProductByBarcodeParams) (GetPOSProductByBarcodeRow, error) {
	row := q.db.QueryRow(ctx, getPOSProductByBarcode, arg.StoreID, arg.Barcode)
	var i GetPOSProductByBarcodeRow
	err := row.Scan(
		&i.ProductID,
		&i.Sku,
		&i.ProductName,
		&i.Description,
		&i.ProductType,
		&i.CategoryID,
		&i.CategoryName,
		&i.CategoryCode,
		&i.ParentCategoryID,
		&i.ParentCategoryName,
		&i.BrandID,
		&i.BrandName,
		&i.UomID,
		&i.UomCode,
		&i.UomName,
		&i.DecimalPlaces,
		&i.Barcode,
		&i.BarcodeType,
		&i.TaxCategoryID,
		&i.TaxCategoryName,
		&i.TaxRate,
		&i.TaxIsInclusive,
		&i.RetailPrice,
		&i.RetailPriceID,
		&i.PromoPrice,
		&i.PromoPriceID,
		&i.PromoMinQuantity,
		&i.PromoValidFrom,
		&i.PromoValidTo,
		&i.PromotionName,
		&i.DiscountPercent,
		&i.EffectivePrice,
		&i.HasActivePromotion,
		&i.IsActive,
		&i.IsSellable,
		&i.IsSerialized,
		&i.IsBatchManaged,
		&i.AllowDecimalQuantity,
		&i.TrackInventory,
		&i.ProductMetadata,
		&i.QuantityAvailable,
		&i.IsInStock,
	)
	return i, err
}

const getPOSProductByID = `-- name: GetPOSProductByID :one
SELECT
    cat.product_id, cat.sku, cat.product_name, cat.description, cat.product_type, cat.category_id, cat.category_name, cat.category_code, cat.parent_category_id, cat.parent_category_name, cat.brand_id, cat.brand_name, cat.uom_id, cat.uom_code, cat.uom_name, cat.decimal_places, cat.barcode, cat.barcode_type, cat.tax_category_id, cat.tax_category_name, cat.tax_rate, cat.tax_is_inclusive, cat.retail_price, cat.retail_price_id, cat.promo_price, cat.promo_price_id, cat.promo_min_quantity, cat.promo_valid_from, cat.promo_valid_to, cat.promotion_name, cat.discount_percent, cat.effective_price, cat.has_active_promotion, cat.is_active, cat.is_sellable, cat.is_serialized, cat.is_batch_managed, cat.allow_decimal_quantity, cat.track_inventory, cat.product_metadata,
    COALESCE(inv.quantity_available, 0.0)::numeric as quantity_available,
    CASE WHEN COALESCE(inv.quantity_available, 0) > 0 THEN true ELSE false END as is_in_stock
FROM vw_pos_product_catalog cat
LEFT JOIN inventory_stock inv
    ON cat.product_id = inv.product_id
    AND inv.store_id = $1
WHERE cat.product_id = $2
LIMIT 1
`

type GetPOSProductByIDParams struct {
	StoreID   int32 `json:"store_id"`
	ProductID int32 `json:"product_id"`
}

type GetPOSProductByIDRow struct {
	ProductID            int32          `json:"product_id"`
	Sku                  string         `json:"sku"`
	ProductName          string         `json:"product_name"`
	Description          pgtype.Text    `json:"description"`
	ProductType          pgtype.Text    `json:"product_type"`
	CategoryID           pgtype.Int4    `json:"category_id"`
	CategoryName         pgtype.Text    `json:"category_name"`
	CategoryCode         pgtype.Text    `json:"category_code"`
	ParentCategoryID     pgtype.Int4    `json:"parent_category_id"`
	ParentCategoryName   pgtype.Text    `json:"parent_category_name"`
	BrandID              pgtype.Int4    `json:"brand_id"`
	BrandName            pgtype.Text    `json:"brand_name"`
	UomID                pgtype.Int4    `json:"uom_id"`
	UomCode              pgtype.Text    `json:"uom_code"`
	UomName              pgtype.Text    `json:"uom_name"`
	DecimalPlaces        pgtype.Int4    `json:"decimal_places"`
	Barcode              pgtype.Text    `json:"barcode"`
	BarcodeType          pgtype.Text    `json:"barcode_type"`
	TaxCategoryID        pgtype.Int4    `json:"tax_category_id"`
	TaxCategoryName      pgtype.Text    `json:"tax_category_name"`
	TaxRate              pgtype.Numeric `json:"tax_rate"`
	TaxIsInclusive       pgtype.Bool    `json:"tax_is_inclusive"`
	RetailPrice          pgtype.Numeric `json:"retail_price"`
	RetailPriceID        pgtype.Int4    `json:"retail_price_id"`
	PromoPrice           pgtype.Numeric `json:"promo_price"`
	PromoPriceID         pgtype.Int4    `json:"promo_price_id"`
	PromoMinQuantity     pgtype.Numeric `json:"promo_min_quantity"`
	PromoValidFrom       pgtype.Date    `json:"promo_valid_from"`
	PromoValidTo         pgtype.Date    `json:"promo_valid_to"`
	PromotionName        pgtype.Text    `json:"promotion_name"`
	DiscountPercent      pgtype.Text    `json:"discount_percent"`
	EffectivePrice       pgtype.Numeric `json:"effective_price"`
	HasActivePromotion   bool           `json:"has_active_promotion"`
	IsActive             pgtype.Bool    `json:"is_active"`
	IsSellable           pgtype.Bool    `json:"is_sellable"`
	IsSerialized         pgtype.Bool    `json:"is_serialized"`
	IsBatchManaged       pgtype.Bool    `json:"is_batch_managed"`
	AllowDecimalQuantity pgtype.Bool    `json:"allow_decimal_quantity"`
	TrackInventory       pgtype.Bool    `json:"track_inventory"`
	ProductMetadata      []byte         `json:"product_metadata"`
	QuantityAvailable    pgtype.Numeric `json:"quantity_available"`
	IsInStock            bool           `json:"is_in_stock"`
}

func (q *Queries) GetPOSProductByID(ctx context.Context, arg GetPOSProductByIDParams) (GetPOSProductByIDRow, error) {
	row := q.db.QueryRow(ctx, getPOSProductByID, arg.StoreID, arg.ProductID)
	var i GetPOSProductByIDRow
	err := row.Scan(
		&i.ProductID,
		&i.Sku,
		&i.ProductName,
		&i.Description,
		&i.ProductType,
		&i.CategoryID,
		&i.CategoryName,
		&i.CategoryCode,
		&i.ParentCategoryID,
		&i.ParentCategoryName,
		&i.BrandID,
		&i.BrandName,
		&i.UomID,
		&i.UomCode,
		&i.UomName,
		&i.DecimalPlaces,
		&i.Barcode,
		&i.BarcodeType,
		&i.TaxCategoryID,
		&i.TaxCategoryName,
		&i.TaxRate,
		&i.TaxIsInclusive,
		&i.RetailPrice,
		&i.RetailPriceID,
		&i.PromoPrice,
		&i.PromoPriceID,
		&i.PromoMinQuantity,
		&i.PromoValidFrom,
		&i.PromoValidTo,
		&i.PromotionName,
		&i.DiscountPercent,
		&i.EffectivePrice,
		&i.HasActivePromotion,
		&i.IsActive,
		&i.IsSellable,
		&i.IsSerialized,
		&i.IsBatchManaged,
		&i.AllowDecimalQuantity,
		&i.TrackInventory,
		&i.ProductMetadata,
		&i.QuantityAvailable,
		&i.IsInStock,
	)
	return i, err
}

const getPOSProductsWithStock = `-- name: GetPOSProductsWithStock :many
SELECT
    cat.product_id, cat.sku, cat.product_name, cat.description, cat.product_type, cat.category_id, cat.category_name, cat.category_code, cat.parent_category_id, cat.parent_category_name, cat.brand_id, cat.brand_name, cat.uom_id, cat.uom_code, cat.uom_name, cat.decimal_places, cat.barcode, cat.barcode_type, cat.tax_category_id, cat.tax_category_name, cat.tax_rate, cat.tax_is_inclusive, cat.retail_price, cat.retail_price_id, cat.promo_price, cat.promo_price_id, cat.promo_min_quantity, cat.promo_valid_from, cat.promo_valid_to, cat.promotion_name, cat.discount_percent, cat.effective_price, cat.has_active_promotion, cat.is_active, cat.is_sellable, cat.is_serialized, cat.is_batch_managed, cat.allow_decimal_quantity, cat.track_inventory, cat.product_metadata,
    COALESCE(inv.quantity_available, 0.0)::numeric as quantity_available,
    COALESCE(inv.quantity_on_hand, 0.0)::numeric as quantity_on_hand,
    COALESCE(inv.quantity_allocated, 0.0)::numeric as quantity_allocated,
    CASE WHEN COALESCE(inv.quantity_available, 0) > 0 THEN true ELSE false END as is_in_stock,
    CASE
        WHEN COALESCE(inv.quantity_available, 0) <= COALESCE(inv.reorder_level, 0)
             AND COALESCE(inv.quantity_available, 0) > 0
        THEN true
        ELSE false
    END as is_low_stock,
    COALESCE(inv.reorder_level, 0.0)::numeric as reorder_level
FROM vw_pos_product_catalog cat
LEFT JOIN inventory_stock inv
    ON cat.product_id = inv.product_id
    AND inv.store_id = $1
WHERE
    ($2::int IS NULL OR cat.category_id = $2)
    AND ($3::text IS NULL
         OR cat.product_name ILIKE '%' || $3 || '%'
         OR cat.sku ILIKE '%' || $3 || '%'
         OR cat.barcode ILIKE '%' || $3 || '%')
    AND ($4::boolean = true OR COALESCE(inv.quantity_available, 0) > 0)
ORDER BY cat.category_name, cat.product_name
`

type GetPOSProductsWithStockParams struct {
	StoreID           int32       `json:"store_id"`
	CategoryID        pgtype.Int4 `json:"category_id"`
	SearchTerm        pgtype.Text `json:"search_term"`
	IncludeOutOfStock bool        `json:"include_out_of_stock"`
}

type GetPOSProductsWithStockRow struct {
	ProductID            int32          `json:"product_id"`
	Sku                  string         `json:"sku"`
	ProductName          string         `json:"product_name"`
	Description          pgtype.Text    `json:"description"`
	ProductType          pgtype.Text    `json:"product_type"`
	CategoryID           pgtype.Int4    `json:"category_id"`
	CategoryName         pgtype.Text    `json:"category_name"`
	CategoryCode         pgtype.Text    `json:"category_code"`
	ParentCategoryID     pgtype.Int4    `json:"parent_category_id"`
	ParentCategoryName   pgtype.Text    `json:"parent_category_name"`
	BrandID              pgtype.Int4    `json:"brand_id"`
	BrandName            pgtype.Text    `json:"brand_name"`
	UomID                pgtype.Int4    `json:"uom_id"`
	UomCode              pgtype.Text    `json:"uom_code"`
	UomName              pgtype.Text    `json:"uom_name"`
	DecimalPlaces        pgtype.Int4    `json:"decimal_places"`
	Barcode              pgtype.Text    `json:"barcode"`
	BarcodeType          pgtype.Text    `json:"barcode_type"`
	TaxCategoryID        pgtype.Int4    `json:"tax_category_id"`
	TaxCategoryName      pgtype.Text    `json:"tax_category_name"`
	TaxRate              pgtype.Numeric `json:"tax_rate"`
	TaxIsInclusive       pgtype.Bool    `json:"tax_is_inclusive"`
	RetailPrice          pgtype.Numeric `json:"retail_price"`
	RetailPriceID        pgtype.Int4    `json:"retail_price_id"`
	PromoPrice           pgtype.Numeric `json:"promo_price"`
	PromoPriceID         pgtype.Int4    `json:"promo_price_id"`
	PromoMinQuantity     pgtype.Numeric `json:"promo_min_quantity"`
	PromoValidFrom       pgtype.Date    `json:"promo_valid_from"`
	PromoValidTo         pgtype.Date    `json:"promo_valid_to"`
	PromotionName        pgtype.Text    `json:"promotion_name"`
	DiscountPercent      pgtype.Text    `json:"discount_percent"`
	EffectivePrice       pgtype.Numeric `json:"effective_price"`
	HasActivePromotion   bool           `json:"has_active_promotion"`
	IsActive             pgtype.Bool    `json:"is_active"`
	IsSellable           pgtype.Bool    `json:"is_sellable"`
	IsSerialized         pgtype.Bool    `json:"is_serialized"`
	IsBatchManaged       pgtype.Bool    `json:"is_batch_managed"`
	AllowDecimalQuantity pgtype.Bool    `json:"allow_decimal_quantity"`
	TrackInventory       pgtype.Bool    `json:"track_inventory"`
	ProductMetadata      []byte         `json:"product_metadata"`
	QuantityAvailable    pgtype.Numeric `json:"quantity_available"`
	QuantityOnHand       pgtype.Numeric `json:"quantity_on_hand"`
	QuantityAllocated    pgtype.Numeric `json:"quantity_allocated"`
	IsInStock            bool           `json:"is_in_stock"`
	IsLowStock           bool           `json:"is_low_stock"`
	ReorderLevel         pgtype.Numeric `json:"reorder_level"`
}

func (q *Queries) GetPOSProductsWithStock(ctx context.Context, arg GetPOSProductsWithStockParams) ([]GetPOSProductsWithStockRow, error) {
	rows, err := q.db.Query(ctx, getPOSProductsWithStock,
		arg.StoreID,
		arg.CategoryID,
		arg.SearchTerm,
		arg.IncludeOutOfStock,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPOSProductsWithStockRow
	for rows.Next() {
		var i GetPOSProductsWithStockRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Sku,
			&i.ProductName,
			&i.Description,
			&i.ProductType,
			&i.CategoryID,
			&i.CategoryName,
			&i.CategoryCode,
			&i.ParentCategoryID,
			&i.ParentCategoryName,
			&i.BrandID,
			&i.BrandName,
			&i.UomID,
			&i.UomCode,
			&i.UomName,
			&i.DecimalPlaces,
			&i.Barcode,
			&i.BarcodeType,
			&i.TaxCategoryID,
			&i.TaxCategoryName,
			&i.TaxRate,
			&i.TaxIsInclusive,
			&i.RetailPrice,
			&i.RetailPriceID,
			&i.PromoPrice,
			&i.PromoPriceID,
			&i.PromoMinQuantity,
			&i.PromoValidFrom,
			&i.PromoValidTo,
			&i.PromotionName,
			&i.DiscountPercent,
			&i.EffectivePrice,
			&i.HasActivePromotion,
			&i.IsActive,
			&i.IsSellable,
			&i.IsSerialized,
			&i.IsBatchManaged,
			&i.AllowDecimalQuantity,
			&i.TrackInventory,
			&i.ProductMetadata,
			&i.QuantityAvailable,
			&i.QuantityOnHand,
			&i.QuantityAllocated,
			&i.IsInStock,
			&i.IsLowStock,
			&i.ReorderLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPOSPromotedProducts = `-- name: GetPOSPromotedProducts :many
SELECT
    cat.product_id, cat.sku, cat.product_name, cat.description, cat.product_type, cat.category_id, cat.category_name, cat.category_code, cat.parent_category_id, cat.parent_category_name, cat.brand_id, cat.brand_name, cat.uom_id, cat.uom_code, cat.uom_name, cat.decimal_places, cat.barcode, cat.barcode_type, cat.tax_category_id, cat.tax_category_name, cat.tax_rate, cat.tax_is_inclusive, cat.retail_price, cat.retail_price_id, cat.promo_price, cat.promo_price_id, cat.promo_min_quantity, cat.promo_valid_from, cat.promo_valid_to, cat.promotion_name, cat.discount_percent, cat.effective_price, cat.has_active_promotion, cat.is_active, cat.is_sellable, cat.is_serialized, cat.is_batch_managed, cat.allow_decimal_quantity, cat.track_inventory, cat.product_metadata,
    (cat.retail_price - cat.promo_price)::numeric as discount_amount,
    COALESCE(inv.quantity_available, 0.0)::numeric as quantity_available,
    CASE WHEN COALESCE(inv.quantity_available, 0) > 0 THEN true ELSE false END as is_in_stock
FROM vw_pos_product_catalog cat
LEFT JOIN inventory_stock inv
    ON cat.product_id = inv.product_id
    AND ($1::int IS NULL OR inv.store_id = $1)
WHERE cat.has_active_promotion = true
  AND ($1::int IS NULL OR COALESCE(inv.quantity_available, 0) > 0)
ORDER BY discount_amount DESC
`

type GetPOSPromotedProductsRow struct {
	ProductID            int32          `json:"product_id"`
	Sku                  string         `json:"sku"`
	ProductName          string         `json:"product_name"`
	Description          pgtype.Text    `json:"description"`
	ProductType          pgtype.Text    `json:"product_type"`
	CategoryID           pgtype.Int4    `json:"category_id"`
	CategoryName         pgtype.Text    `json:"category_name"`
	CategoryCode         pgtype.Text    `json:"category_code"`
	ParentCategoryID     pgtype.Int4    `json:"parent_category_id"`
	ParentCategoryName   pgtype.Text    `json:"parent_category_name"`
	BrandID              pgtype.Int4    `json:"brand_id"`
	BrandName            pgtype.Text    `json:"brand_name"`
	UomID                pgtype.Int4    `json:"uom_id"`
	UomCode              pgtype.Text    `json:"uom_code"`
	UomName              pgtype.Text    `json:"uom_name"`
	DecimalPlaces        pgtype.Int4    `json:"decimal_places"`
	Barcode              pgtype.Text    `json:"barcode"`
	BarcodeType          pgtype.Text    `json:"barcode_type"`
	TaxCategoryID        pgtype.Int4    `json:"tax_category_id"`
	TaxCategoryName      pgtype.Text    `json:"tax_category_name"`
	TaxRate              pgtype.Numeric `json:"tax_rate"`
	TaxIsInclusive       pgtype.Bool    `json:"tax_is_inclusive"`
	RetailPrice          pgtype.Numeric `json:"retail_price"`
	RetailPriceID        pgtype.Int4    `json:"retail_price_id"`
	PromoPrice           pgtype.Numeric `json:"promo_price"`
	PromoPriceID         pgtype.Int4    `json:"promo_price_id"`
	PromoMinQuantity     pgtype.Numeric `json:"promo_min_quantity"`
	PromoValidFrom       pgtype.Date    `json:"promo_valid_from"`
	PromoValidTo         pgtype.Date    `json:"promo_valid_to"`
	PromotionName        pgtype.Text    `json:"promotion_name"`
	DiscountPercent      pgtype.Text    `json:"discount_percent"`
	EffectivePrice       pgtype.Numeric `json:"effective_price"`
	HasActivePromotion   bool           `json:"has_active_promotion"`
	IsActive             pgtype.Bool    `json:"is_active"`
	IsSellable           pgtype.Bool    `json:"is_sellable"`
	IsSerialized         pgtype.Bool    `json:"is_serialized"`
	IsBatchManaged       pgtype.Bool    `json:"is_batch_managed"`
	AllowDecimalQuantity pgtype.Bool    `json:"allow_decimal_quantity"`
	TrackInventory       pgtype.Bool    `json:"track_inventory"`
	ProductMetadata      []byte         `json:"product_metadata"`
	DiscountAmount       pgtype.Numeric `json:"discount_amount"`
	QuantityAvailable    pgtype.Numeric `json:"quantity_available"`
	IsInStock            bool           `json:"is_in_stock"`
}

func (q *Queries) GetPOSPromotedProducts(ctx context.Context, storeID pgtype.Int4) ([]GetPOSPromotedProductsRow, error) {
	rows, err := q.db.Query(ctx, getPOSPromotedProducts, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPOSPromotedProductsRow
	for rows.Next() {
		var i GetPOSPromotedProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Sku,
			&i.ProductName,
			&i.Description,
			&i.ProductType,
			&i.CategoryID,
			&i.CategoryName,
			&i.CategoryCode,
			&i.ParentCategoryID,
			&i.ParentCategoryName,
			&i.BrandID,
			&i.BrandName,
			&i.UomID,
			&i.UomCode,
			&i.UomName,
			&i.DecimalPlaces,
			&i.Barcode,
			&i.BarcodeType,
			&i.TaxCategoryID,
			&i.TaxCategoryName,
			&i.TaxRate,
			&i.TaxIsInclusive,
			&i.RetailPrice,
			&i.RetailPriceID,
			&i.PromoPrice,
			&i.PromoPriceID,
			&i.PromoMinQuantity,
			&i.PromoValidFrom,
			&i.PromoValidTo,
			&i.PromotionName,
			&i.DiscountPercent,
			&i.EffectivePrice,
			&i.HasActivePromotion,
			&i.IsActive,
			&i.IsSellable,
			&i.IsSerialized,
			&i.IsBatchManaged,
			&i.AllowDecimalQuantity,
			&i.TrackInventory,
			&i.ProductMetadata,
			&i.DiscountAmount,
			&i.QuantityAvailable,
			&i.IsInStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPOSProducts = `-- name: SearchPOSProducts :many
SELECT
    cat.product_id, cat.sku, cat.product_name, cat.description, cat.product_type, cat.category_id, cat.category_name, cat.category_code, cat.parent_category_id, cat.parent_category_name, cat.brand_id, cat.brand_name, cat.uom_id, cat.uom_code, cat.uom_name, cat.decimal_places, cat.barcode, cat.barcode_type, cat.tax_category_id, cat.tax_category_name, cat.tax_rate, cat.tax_is_inclusive, cat.retail_price, cat.retail_price_id, cat.promo_price, cat.promo_price_id, cat.promo_min_quantity, cat.promo_valid_from, cat.promo_valid_to, cat.promotion_name, cat.discount_percent, cat.effective_price, cat.has_active_promotion, cat.is_active, cat.is_sellable, cat.is_serialized, cat.is_batch_managed, cat.allow_decimal_quantity, cat.track_inventory, cat.product_metadata,
    COALESCE(inv.quantity_available, 0.0)::numeric as quantity_available,
    CASE WHEN COALESCE(inv.quantity_available, 0) > 0 THEN true ELSE false END as is_in_stock,
    CASE
        WHEN cat.sku ILIKE $1 THEN 100
        WHEN cat.product_name ILIKE $1 THEN 90
        WHEN cat.barcode = $1 THEN 95
        WHEN cat.sku ILIKE $1 || '%' THEN 80
        WHEN cat.product_name ILIKE $1 || '%' THEN 70
        WHEN cat.sku ILIKE '%' || $1 || '%' THEN 60
        WHEN cat.product_name ILIKE '%' || $1 || '%' THEN 50
        ELSE 40
    END as relevance_score
FROM vw_pos_product_catalog cat
LEFT JOIN inventory_stock inv
    ON cat.product_id = inv.product_id
    AND inv.store_id = $2
WHERE
    (cat.product_name ILIKE '%' || $1 || '%'
     OR cat.sku ILIKE '%' || $1 || '%'
     OR cat.barcode ILIKE '%' || $1 || '%'
     OR (CASE WHEN $1::text ~ '^\d+$' THEN cat.product_id = $1::int ELSE false END))
ORDER BY relevance_score DESC, cat.product_name
LIMIT $3
`

type SearchPOSProductsParams struct {
	SearchTerm string `json:"search_term"`
	StoreID    int32  `json:"store_id"`
	LimitCount int32  `json:"limit_count"`
}

type SearchPOSProductsRow struct {
	ProductID            int32          `json:"product_id"`
	Sku                  string         `json:"sku"`
	ProductName          string         `json:"product_name"`
	Description          pgtype.Text    `json:"description"`
	ProductType          pgtype.Text    `json:"product_type"`
	CategoryID           pgtype.Int4    `json:"category_id"`
	CategoryName         pgtype.Text    `json:"category_name"`
	CategoryCode         pgtype.Text    `json:"category_code"`
	ParentCategoryID     pgtype.Int4    `json:"parent_category_id"`
	ParentCategoryName   pgtype.Text    `json:"parent_category_name"`
	BrandID              pgtype.Int4    `json:"brand_id"`
	BrandName            pgtype.Text    `json:"brand_name"`
	UomID                pgtype.Int4    `json:"uom_id"`
	UomCode              pgtype.Text    `json:"uom_code"`
	UomName              pgtype.Text    `json:"uom_name"`
	DecimalPlaces        pgtype.Int4    `json:"decimal_places"`
	Barcode              pgtype.Text    `json:"barcode"`
	BarcodeType          pgtype.Text    `json:"barcode_type"`
	TaxCategoryID        pgtype.Int4    `json:"tax_category_id"`
	TaxCategoryName      pgtype.Text    `json:"tax_category_name"`
	TaxRate              pgtype.Numeric `json:"tax_rate"`
	TaxIsInclusive       pgtype.Bool    `json:"tax_is_inclusive"`
	RetailPrice          pgtype.Numeric `json:"retail_price"`
	RetailPriceID        pgtype.Int4    `json:"retail_price_id"`
	PromoPrice           pgtype.Numeric `json:"promo_price"`
	PromoPriceID         pgtype.Int4    `json:"promo_price_id"`
	PromoMinQuantity     pgtype.Numeric `json:"promo_min_quantity"`
	PromoValidFrom       pgtype.Date    `json:"promo_valid_from"`
	PromoValidTo         pgtype.Date    `json:"promo_valid_to"`
	PromotionName        pgtype.Text    `json:"promotion_name"`
	DiscountPercent      pgtype.Text    `json:"discount_percent"`
	EffectivePrice       pgtype.Numeric `json:"effective_price"`
	HasActivePromotion   bool           `json:"has_active_promotion"`
	IsActive             pgtype.Bool    `json:"is_active"`
	IsSellable           pgtype.Bool    `json:"is_sellable"`
	IsSerialized         pgtype.Bool    `json:"is_serialized"`
	IsBatchManaged       pgtype.Bool    `json:"is_batch_managed"`
	AllowDecimalQuantity pgtype.Bool    `json:"allow_decimal_quantity"`
	TrackInventory       pgtype.Bool    `json:"track_inventory"`
	ProductMetadata      []byte         `json:"product_metadata"`
	QuantityAvailable    pgtype.Numeric `json:"quantity_available"`
	IsInStock            bool           `json:"is_in_stock"`
	RelevanceScore       int32          `json:"relevance_score"`
}

func (q *Queries) SearchPOSProducts(ctx context.Context, arg SearchPOSProductsParams) ([]SearchPOSProductsRow, error) {
	rows, err := q.db.Query(ctx, searchPOSProducts, arg.SearchTerm, arg.StoreID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchPOSProductsRow
	for rows.Next() {
		var i SearchPOSProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Sku,
			&i.ProductName,
			&i.Description,
			&i.ProductType,
			&i.CategoryID,
			&i.CategoryName,
			&i.CategoryCode,
			&i.ParentCategoryID,
			&i.ParentCategoryName,
			&i.BrandID,
			&i.BrandName,
			&i.UomID,
			&i.UomCode,
			&i.UomName,
			&i.DecimalPlaces,
			&i.Barcode,
			&i.BarcodeType,
			&i.TaxCategoryID,
			&i.TaxCategoryName,
			&i.TaxRate,
			&i.TaxIsInclusive,
			&i.RetailPrice,
			&i.RetailPriceID,
			&i.PromoPrice,
			&i.PromoPriceID,
			&i.PromoMinQuantity,
			&i.PromoValidFrom,
			&i.PromoValidTo,
			&i.PromotionName,
			&i.DiscountPercent,
			&i.EffectivePrice,
			&i.HasActivePromotion,
			&i.IsActive,
			&i.IsSellable,
			&i.IsSerialized,
			&i.IsBatchManaged,
			&i.AllowDecimalQuantity,
			&i.TrackInventory,
			&i.ProductMetadata,
			&i.QuantityAvailable,
			&i.IsInStock,
			&i.RelevanceScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
