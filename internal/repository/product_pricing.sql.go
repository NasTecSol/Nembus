// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product_pricing.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkUpdatePrices = `-- name: BulkUpdatePrices :exec
UPDATE product_prices
SET price = price * (1 + $2 / 100.0)
WHERE price_list_id = $1
  AND is_active = true
`

type BulkUpdatePricesParams struct {
	PriceListID int32       `json:"price_list_id"`
	Column2     interface{} `json:"column_2"`
}

func (q *Queries) BulkUpdatePrices(ctx context.Context, arg BulkUpdatePricesParams) error {
	_, err := q.db.Exec(ctx, bulkUpdatePrices, arg.PriceListID, arg.Column2)
	return err
}

const createProductPrice = `-- name: CreateProductPrice :one


INSERT INTO product_prices (
    product_id, product_variant_id, price_list_id, uom_id,
    price, min_quantity, max_quantity, valid_from, valid_to,
    is_active, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, product_id, product_variant_id, price_list_id, uom_id, price, min_quantity, max_quantity, valid_from, valid_to, is_active, metadata, created_at, updated_at
`

type CreateProductPriceParams struct {
	ProductID        int32          `json:"product_id"`
	ProductVariantID pgtype.Int4    `json:"product_variant_id"`
	PriceListID      int32          `json:"price_list_id"`
	UomID            pgtype.Int4    `json:"uom_id"`
	Price            pgtype.Numeric `json:"price"`
	MinQuantity      pgtype.Numeric `json:"min_quantity"`
	MaxQuantity      pgtype.Numeric `json:"max_quantity"`
	ValidFrom        pgtype.Date    `json:"valid_from"`
	ValidTo          pgtype.Date    `json:"valid_to"`
	IsActive         pgtype.Bool    `json:"is_active"`
	Metadata         []byte         `json:"metadata"`
}

// =====================================================
// PRICE LISTS
// Note: Price list queries are in price_lists_query.sql
// =====================================================
// =====================================================
// PRODUCT PRICES
// =====================================================
func (q *Queries) CreateProductPrice(ctx context.Context, arg CreateProductPriceParams) (ProductPrice, error) {
	row := q.db.QueryRow(ctx, createProductPrice,
		arg.ProductID,
		arg.ProductVariantID,
		arg.PriceListID,
		arg.UomID,
		arg.Price,
		arg.MinQuantity,
		arg.MaxQuantity,
		arg.ValidFrom,
		arg.ValidTo,
		arg.IsActive,
		arg.Metadata,
	)
	var i ProductPrice
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.PriceListID,
		&i.UomID,
		&i.Price,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.ValidFrom,
		&i.ValidTo,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProductPrice = `-- name: DeleteProductPrice :exec
DELETE FROM product_prices WHERE id = $1
`

func (q *Queries) DeleteProductPrice(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProductPrice, id)
	return err
}

const expirePrices = `-- name: ExpirePrices :exec
UPDATE product_prices
SET valid_to = CURRENT_DATE - INTERVAL '1 day'
WHERE price_list_id = $1
  AND is_active = true
  AND (valid_to IS NULL OR valid_to > CURRENT_DATE)
`

func (q *Queries) ExpirePrices(ctx context.Context, priceListID int32) error {
	_, err := q.db.Exec(ctx, expirePrices, priceListID)
	return err
}

const getEffectivePrice = `-- name: GetEffectivePrice :one
SELECT pp.id, pp.product_id, pp.product_variant_id, pp.price_list_id, pp.uom_id, pp.price, pp.min_quantity, pp.max_quantity, pp.valid_from, pp.valid_to, pp.is_active, pp.metadata, pp.created_at, pp.updated_at FROM product_prices pp
WHERE pp.product_id = $1
  AND pp.product_variant_id = COALESCE($4, pp.product_variant_id)
  AND pp.price_list_id = $2
  AND pp.is_active = true
  AND (pp.valid_from IS NULL OR pp.valid_from <= CURRENT_DATE)
  AND (pp.valid_to IS NULL OR pp.valid_to >= CURRENT_DATE)
  AND pp.min_quantity <= $3
  AND (pp.max_quantity IS NULL OR pp.max_quantity >= $3)
ORDER BY pp.min_quantity DESC
LIMIT 1
`

type GetEffectivePriceParams struct {
	ProductID        int32          `json:"product_id"`
	PriceListID      int32          `json:"price_list_id"`
	MinQuantity      pgtype.Numeric `json:"min_quantity"`
	ProductVariantID pgtype.Int4    `json:"product_variant_id"`
}

func (q *Queries) GetEffectivePrice(ctx context.Context, arg GetEffectivePriceParams) (ProductPrice, error) {
	row := q.db.QueryRow(ctx, getEffectivePrice,
		arg.ProductID,
		arg.PriceListID,
		arg.MinQuantity,
		arg.ProductVariantID,
	)
	var i ProductPrice
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.PriceListID,
		&i.UomID,
		&i.Price,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.ValidFrom,
		&i.ValidTo,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPriceComparison = `-- name: GetPriceComparison :many
SELECT 
    pl.id as price_list_id,
    pl.name as price_list_name,
    pl.code as price_list_code,
    pp.price,
    pp.min_quantity,
    pp.valid_from,
    pp.valid_to
FROM price_lists pl
LEFT JOIN product_prices pp ON pl.id = pp.price_list_id 
    AND pp.product_id = $1
    AND pp.is_active = true
WHERE pl.is_active = true
ORDER BY pl.name
`

type GetPriceComparisonRow struct {
	PriceListID   int32          `json:"price_list_id"`
	PriceListName string         `json:"price_list_name"`
	PriceListCode string         `json:"price_list_code"`
	Price         pgtype.Numeric `json:"price"`
	MinQuantity   pgtype.Numeric `json:"min_quantity"`
	ValidFrom     pgtype.Date    `json:"valid_from"`
	ValidTo       pgtype.Date    `json:"valid_to"`
}

func (q *Queries) GetPriceComparison(ctx context.Context, productID int32) ([]GetPriceComparisonRow, error) {
	rows, err := q.db.Query(ctx, getPriceComparison, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPriceComparisonRow
	for rows.Next() {
		var i GetPriceComparisonRow
		if err := rows.Scan(
			&i.PriceListID,
			&i.PriceListName,
			&i.PriceListCode,
			&i.Price,
			&i.MinQuantity,
			&i.ValidFrom,
			&i.ValidTo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductPrice = `-- name: GetProductPrice :one
SELECT id, product_id, product_variant_id, price_list_id, uom_id, price, min_quantity, max_quantity, valid_from, valid_to, is_active, metadata, created_at, updated_at FROM product_prices WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProductPrice(ctx context.Context, id int32) (ProductPrice, error) {
	row := q.db.QueryRow(ctx, getProductPrice, id)
	var i ProductPrice
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.PriceListID,
		&i.UomID,
		&i.Price,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.ValidFrom,
		&i.ValidTo,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductPriceForList = `-- name: GetProductPriceForList :one
SELECT pp.id, pp.product_id, pp.product_variant_id, pp.price_list_id, pp.uom_id, pp.price, pp.min_quantity, pp.max_quantity, pp.valid_from, pp.valid_to, pp.is_active, pp.metadata, pp.created_at, pp.updated_at FROM product_prices pp
WHERE pp.product_id = $1
  AND pp.product_variant_id = COALESCE($3, pp.product_variant_id)
  AND pp.price_list_id = $2
  AND pp.uom_id = COALESCE($4, pp.uom_id)
  AND pp.is_active = true
  AND (pp.valid_from IS NULL OR pp.valid_from <= CURRENT_DATE)
  AND (pp.valid_to IS NULL OR pp.valid_to >= CURRENT_DATE)
  AND pp.min_quantity <= COALESCE($5, 1)
  AND (pp.max_quantity IS NULL OR pp.max_quantity >= COALESCE($5, 1))
ORDER BY pp.min_quantity DESC
LIMIT 1
`

type GetProductPriceForListParams struct {
	ProductID        int32          `json:"product_id"`
	PriceListID      int32          `json:"price_list_id"`
	ProductVariantID pgtype.Int4    `json:"product_variant_id"`
	UomID            pgtype.Int4    `json:"uom_id"`
	Quantity         pgtype.Numeric `json:"quantity"`
}

func (q *Queries) GetProductPriceForList(ctx context.Context, arg GetProductPriceForListParams) (ProductPrice, error) {
	row := q.db.QueryRow(ctx, getProductPriceForList,
		arg.ProductID,
		arg.PriceListID,
		arg.ProductVariantID,
		arg.UomID,
		arg.Quantity,
	)
	var i ProductPrice
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.PriceListID,
		&i.UomID,
		&i.Price,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.ValidFrom,
		&i.ValidTo,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductWithPricing = `-- name: GetProductWithPricing :one

SELECT 
    p.id, p.organization_id, p.sku, p.name, p.description, p.category_id, p.brand_id, p.base_uom_id, p.product_type, p.tax_category_id, p.is_serialized, p.is_batch_managed, p.is_active, p.is_sellable, p.is_purchasable, p.allow_decimal_quantity, p.track_inventory, p.metadata, p.created_at, p.updated_at,
    json_agg(DISTINCT jsonb_build_object(
        'price_list_id', pl.id,
        'price_list_name', pl.name,
        'price_list_code', pl.code,
        'price', pp.price,
        'min_quantity', pp.min_quantity,
        'max_quantity', pp.max_quantity
    )) FILTER (WHERE pp.id IS NOT NULL) as prices
FROM products p
LEFT JOIN product_prices pp ON p.id = pp.product_id AND pp.is_active = true
LEFT JOIN price_lists pl ON pp.price_list_id = pl.id
WHERE p.id = $1
GROUP BY p.id
`

type GetProductWithPricingRow struct {
	ID                   int32            `json:"id"`
	OrganizationID       int32            `json:"organization_id"`
	Sku                  string           `json:"sku"`
	Name                 string           `json:"name"`
	Description          pgtype.Text      `json:"description"`
	CategoryID           pgtype.Int4      `json:"category_id"`
	BrandID              pgtype.Int4      `json:"brand_id"`
	BaseUomID            pgtype.Int4      `json:"base_uom_id"`
	ProductType          pgtype.Text      `json:"product_type"`
	TaxCategoryID        pgtype.Int4      `json:"tax_category_id"`
	IsSerialized         pgtype.Bool      `json:"is_serialized"`
	IsBatchManaged       pgtype.Bool      `json:"is_batch_managed"`
	IsActive             pgtype.Bool      `json:"is_active"`
	IsSellable           pgtype.Bool      `json:"is_sellable"`
	IsPurchasable        pgtype.Bool      `json:"is_purchasable"`
	AllowDecimalQuantity pgtype.Bool      `json:"allow_decimal_quantity"`
	TrackInventory       pgtype.Bool      `json:"track_inventory"`
	Metadata             []byte           `json:"metadata"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
	Prices               []byte           `json:"prices"`
}

// =====================================================
// PRODUCT PRICING QUERIES
// =====================================================
func (q *Queries) GetProductWithPricing(ctx context.Context, id int32) (GetProductWithPricingRow, error) {
	row := q.db.QueryRow(ctx, getProductWithPricing, id)
	var i GetProductWithPricingRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.BrandID,
		&i.BaseUomID,
		&i.ProductType,
		&i.TaxCategoryID,
		&i.IsSerialized,
		&i.IsBatchManaged,
		&i.IsActive,
		&i.IsSellable,
		&i.IsPurchasable,
		&i.AllowDecimalQuantity,
		&i.TrackInventory,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Prices,
	)
	return i, err
}

const listPricesByPriceList = `-- name: ListPricesByPriceList :many
SELECT 
    pp.id, pp.product_id, pp.product_variant_id, pp.price_list_id, pp.uom_id, pp.price, pp.min_quantity, pp.max_quantity, pp.valid_from, pp.valid_to, pp.is_active, pp.metadata, pp.created_at, pp.updated_at,
    p.name as product_name,
    p.sku as product_sku,
    pv.variant_name,
    pv.variant_sku
FROM product_prices pp
INNER JOIN products p ON pp.product_id = p.id
LEFT JOIN product_variants pv ON pp.product_variant_id = pv.id
WHERE pp.price_list_id = $1
  AND pp.is_active = true
ORDER BY p.name
`

type ListPricesByPriceListRow struct {
	ID               int32            `json:"id"`
	ProductID        int32            `json:"product_id"`
	ProductVariantID pgtype.Int4      `json:"product_variant_id"`
	PriceListID      int32            `json:"price_list_id"`
	UomID            pgtype.Int4      `json:"uom_id"`
	Price            pgtype.Numeric   `json:"price"`
	MinQuantity      pgtype.Numeric   `json:"min_quantity"`
	MaxQuantity      pgtype.Numeric   `json:"max_quantity"`
	ValidFrom        pgtype.Date      `json:"valid_from"`
	ValidTo          pgtype.Date      `json:"valid_to"`
	IsActive         pgtype.Bool      `json:"is_active"`
	Metadata         []byte           `json:"metadata"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	ProductName      string           `json:"product_name"`
	ProductSku       string           `json:"product_sku"`
	VariantName      pgtype.Text      `json:"variant_name"`
	VariantSku       pgtype.Text      `json:"variant_sku"`
}

func (q *Queries) ListPricesByPriceList(ctx context.Context, priceListID int32) ([]ListPricesByPriceListRow, error) {
	rows, err := q.db.Query(ctx, listPricesByPriceList, priceListID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPricesByPriceListRow
	for rows.Next() {
		var i ListPricesByPriceListRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.PriceListID,
			&i.UomID,
			&i.Price,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductSku,
			&i.VariantName,
			&i.VariantSku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductPrices = `-- name: ListProductPrices :many
SELECT 
    pp.id, pp.product_id, pp.product_variant_id, pp.price_list_id, pp.uom_id, pp.price, pp.min_quantity, pp.max_quantity, pp.valid_from, pp.valid_to, pp.is_active, pp.metadata, pp.created_at, pp.updated_at,
    pl.name as price_list_name,
    pl.code as price_list_code,
    uom.name as uom_name,
    uom.code as uom_code
FROM product_prices pp
INNER JOIN price_lists pl ON pp.price_list_id = pl.id
LEFT JOIN units_of_measure uom ON pp.uom_id = uom.id
WHERE pp.product_id = $1
  AND pp.product_variant_id = COALESCE($2, pp.product_variant_id)
  AND pp.is_active = COALESCE($3, pp.is_active)
ORDER BY pl.name, pp.min_quantity
`

type ListProductPricesParams struct {
	ProductID        int32       `json:"product_id"`
	ProductVariantID pgtype.Int4 `json:"product_variant_id"`
	IsActive         pgtype.Bool `json:"is_active"`
}

type ListProductPricesRow struct {
	ID               int32            `json:"id"`
	ProductID        int32            `json:"product_id"`
	ProductVariantID pgtype.Int4      `json:"product_variant_id"`
	PriceListID      int32            `json:"price_list_id"`
	UomID            pgtype.Int4      `json:"uom_id"`
	Price            pgtype.Numeric   `json:"price"`
	MinQuantity      pgtype.Numeric   `json:"min_quantity"`
	MaxQuantity      pgtype.Numeric   `json:"max_quantity"`
	ValidFrom        pgtype.Date      `json:"valid_from"`
	ValidTo          pgtype.Date      `json:"valid_to"`
	IsActive         pgtype.Bool      `json:"is_active"`
	Metadata         []byte           `json:"metadata"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	PriceListName    string           `json:"price_list_name"`
	PriceListCode    string           `json:"price_list_code"`
	UomName          pgtype.Text      `json:"uom_name"`
	UomCode          pgtype.Text      `json:"uom_code"`
}

func (q *Queries) ListProductPrices(ctx context.Context, arg ListProductPricesParams) ([]ListProductPricesRow, error) {
	rows, err := q.db.Query(ctx, listProductPrices, arg.ProductID, arg.ProductVariantID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductPricesRow
	for rows.Next() {
		var i ListProductPricesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.PriceListID,
			&i.UomID,
			&i.Price,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PriceListName,
			&i.PriceListCode,
			&i.UomName,
			&i.UomCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProductsWithPrices = `-- name: SearchProductsWithPrices :many
SELECT 
    p.id,
    p.sku,
    p.name,
    p.description,
    pc.name as category_name,
    b.name as brand_name,
    pp.price,
    pl.name as price_list_name
FROM products p
LEFT JOIN product_categories pc ON p.category_id = pc.id
LEFT JOIN brands b ON p.brand_id = b.id
LEFT JOIN product_prices pp ON p.id = pp.product_id 
    AND pp.price_list_id = $2
    AND pp.is_active = true
LEFT JOIN price_lists pl ON pp.price_list_id = pl.id
WHERE p.organization_id = $1
  AND p.is_active = true
  AND p.is_sellable = true
  AND (
    p.sku ILIKE '%' || $3 || '%' OR
    p.name ILIKE '%' || $3 || '%'
  )
ORDER BY p.name
LIMIT $4 OFFSET $5
`

type SearchProductsWithPricesParams struct {
	OrganizationID int32       `json:"organization_id"`
	PriceListID    int32       `json:"price_list_id"`
	Column3        pgtype.Text `json:"column_3"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type SearchProductsWithPricesRow struct {
	ID            int32          `json:"id"`
	Sku           string         `json:"sku"`
	Name          string         `json:"name"`
	Description   pgtype.Text    `json:"description"`
	CategoryName  pgtype.Text    `json:"category_name"`
	BrandName     pgtype.Text    `json:"brand_name"`
	Price         pgtype.Numeric `json:"price"`
	PriceListName pgtype.Text    `json:"price_list_name"`
}

func (q *Queries) SearchProductsWithPrices(ctx context.Context, arg SearchProductsWithPricesParams) ([]SearchProductsWithPricesRow, error) {
	rows, err := q.db.Query(ctx, searchProductsWithPrices,
		arg.OrganizationID,
		arg.PriceListID,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductsWithPricesRow
	for rows.Next() {
		var i SearchProductsWithPricesRow
		if err := rows.Scan(
			&i.ID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryName,
			&i.BrandName,
			&i.Price,
			&i.PriceListName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductPrice = `-- name: UpdateProductPrice :one
UPDATE product_prices
SET 
    price = COALESCE($1, price),
    min_quantity = COALESCE($2, min_quantity),
    max_quantity = COALESCE($3, max_quantity),
    valid_from = COALESCE($4, valid_from),
    valid_to = COALESCE($5, valid_to),
    is_active = COALESCE($6, is_active),
    metadata = COALESCE($7, metadata)
WHERE id = $8
RETURNING id, product_id, product_variant_id, price_list_id, uom_id, price, min_quantity, max_quantity, valid_from, valid_to, is_active, metadata, created_at, updated_at
`

type UpdateProductPriceParams struct {
	Price       pgtype.Numeric `json:"price"`
	MinQuantity pgtype.Numeric `json:"min_quantity"`
	MaxQuantity pgtype.Numeric `json:"max_quantity"`
	ValidFrom   pgtype.Date    `json:"valid_from"`
	ValidTo     pgtype.Date    `json:"valid_to"`
	IsActive    pgtype.Bool    `json:"is_active"`
	Metadata    []byte         `json:"metadata"`
	ID          int32          `json:"id"`
}

func (q *Queries) UpdateProductPrice(ctx context.Context, arg UpdateProductPriceParams) (ProductPrice, error) {
	row := q.db.QueryRow(ctx, updateProductPrice,
		arg.Price,
		arg.MinQuantity,
		arg.MaxQuantity,
		arg.ValidFrom,
		arg.ValidTo,
		arg.IsActive,
		arg.Metadata,
		arg.ID,
	)
	var i ProductPrice
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.PriceListID,
		&i.UomID,
		&i.Price,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.ValidFrom,
		&i.ValidTo,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
