// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: restaurant_orders.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRestaurantOrder = `-- name: CreateRestaurantOrder :one
INSERT INTO restaurant_orders (
    store_id, table_id, cashier_id, cashier_session_id, customer_id, order_number, order_source, status, subtotal, discount_amount, tax_amount, total_amount, amount_paid, change_given, notes, pos_transaction_id, metadata, ordered_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
)
RETURNING id, store_id, table_id, cashier_id, cashier_session_id, customer_id, order_number, order_source, status, subtotal, discount_amount, tax_amount, total_amount, amount_paid, change_given, notes, pos_transaction_id, ordered_at, confirmed_at, served_at, paid_at, metadata, created_at, updated_at
`

type CreateRestaurantOrderParams struct {
	StoreID          int32            `json:"store_id"`
	TableID          pgtype.Int4      `json:"table_id"`
	CashierID        pgtype.Int4      `json:"cashier_id"`
	CashierSessionID pgtype.Int4      `json:"cashier_session_id"`
	CustomerID       pgtype.Int4      `json:"customer_id"`
	OrderNumber      string           `json:"order_number"`
	OrderSource      string           `json:"order_source"`
	Status           string           `json:"status"`
	Subtotal         pgtype.Numeric   `json:"subtotal"`
	DiscountAmount   pgtype.Numeric   `json:"discount_amount"`
	TaxAmount        pgtype.Numeric   `json:"tax_amount"`
	TotalAmount      pgtype.Numeric   `json:"total_amount"`
	AmountPaid       pgtype.Numeric   `json:"amount_paid"`
	ChangeGiven      pgtype.Numeric   `json:"change_given"`
	Notes            pgtype.Text      `json:"notes"`
	PosTransactionID pgtype.Int4      `json:"pos_transaction_id"`
	Metadata         []byte           `json:"metadata"`
	OrderedAt        pgtype.Timestamp `json:"ordered_at"`
}

func (q *Queries) CreateRestaurantOrder(ctx context.Context, arg CreateRestaurantOrderParams) (RestaurantOrder, error) {
	row := q.db.QueryRow(ctx, createRestaurantOrder,
		arg.StoreID,
		arg.TableID,
		arg.CashierID,
		arg.CashierSessionID,
		arg.CustomerID,
		arg.OrderNumber,
		arg.OrderSource,
		arg.Status,
		arg.Subtotal,
		arg.DiscountAmount,
		arg.TaxAmount,
		arg.TotalAmount,
		arg.AmountPaid,
		arg.ChangeGiven,
		arg.Notes,
		arg.PosTransactionID,
		arg.Metadata,
		arg.OrderedAt,
	)
	var i RestaurantOrder
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.TableID,
		&i.CashierID,
		&i.CashierSessionID,
		&i.CustomerID,
		&i.OrderNumber,
		&i.OrderSource,
		&i.Status,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.AmountPaid,
		&i.ChangeGiven,
		&i.Notes,
		&i.PosTransactionID,
		&i.OrderedAt,
		&i.ConfirmedAt,
		&i.ServedAt,
		&i.PaidAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRestaurantOrder = `-- name: DeleteRestaurantOrder :exec
DELETE FROM restaurant_orders
WHERE id = $1
`

func (q *Queries) DeleteRestaurantOrder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRestaurantOrder, id)
	return err
}

const getRestaurantOrder = `-- name: GetRestaurantOrder :one

SELECT id, store_id, table_id, cashier_id, cashier_session_id, customer_id, order_number, order_source, status, subtotal, discount_amount, tax_amount, total_amount, amount_paid, change_given, notes, pos_transaction_id, ordered_at, confirmed_at, served_at, paid_at, metadata, created_at, updated_at FROM restaurant_orders
WHERE id = $1 LIMIT 1
`

// restaurant_orders.sql
func (q *Queries) GetRestaurantOrder(ctx context.Context, id int32) (RestaurantOrder, error) {
	row := q.db.QueryRow(ctx, getRestaurantOrder, id)
	var i RestaurantOrder
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.TableID,
		&i.CashierID,
		&i.CashierSessionID,
		&i.CustomerID,
		&i.OrderNumber,
		&i.OrderSource,
		&i.Status,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.AmountPaid,
		&i.ChangeGiven,
		&i.Notes,
		&i.PosTransactionID,
		&i.OrderedAt,
		&i.ConfirmedAt,
		&i.ServedAt,
		&i.PaidAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRestaurantOrderByNumber = `-- name: GetRestaurantOrderByNumber :one
SELECT id, store_id, table_id, cashier_id, cashier_session_id, customer_id, order_number, order_source, status, subtotal, discount_amount, tax_amount, total_amount, amount_paid, change_given, notes, pos_transaction_id, ordered_at, confirmed_at, served_at, paid_at, metadata, created_at, updated_at FROM restaurant_orders
WHERE store_id = $1 AND order_number = $2 LIMIT 1
`

type GetRestaurantOrderByNumberParams struct {
	StoreID     int32  `json:"store_id"`
	OrderNumber string `json:"order_number"`
}

func (q *Queries) GetRestaurantOrderByNumber(ctx context.Context, arg GetRestaurantOrderByNumberParams) (RestaurantOrder, error) {
	row := q.db.QueryRow(ctx, getRestaurantOrderByNumber, arg.StoreID, arg.OrderNumber)
	var i RestaurantOrder
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.TableID,
		&i.CashierID,
		&i.CashierSessionID,
		&i.CustomerID,
		&i.OrderNumber,
		&i.OrderSource,
		&i.Status,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.AmountPaid,
		&i.ChangeGiven,
		&i.Notes,
		&i.PosTransactionID,
		&i.OrderedAt,
		&i.ConfirmedAt,
		&i.ServedAt,
		&i.PaidAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRestaurantOrders = `-- name: ListRestaurantOrders :many
SELECT id, store_id, table_id, cashier_id, cashier_session_id, customer_id, order_number, order_source, status, subtotal, discount_amount, tax_amount, total_amount, amount_paid, change_given, notes, pos_transaction_id, ordered_at, confirmed_at, served_at, paid_at, metadata, created_at, updated_at FROM restaurant_orders
WHERE store_id = $1
ORDER BY ordered_at DESC
`

func (q *Queries) ListRestaurantOrders(ctx context.Context, storeID int32) ([]RestaurantOrder, error) {
	rows, err := q.db.Query(ctx, listRestaurantOrders, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RestaurantOrder
	for rows.Next() {
		var i RestaurantOrder
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.TableID,
			&i.CashierID,
			&i.CashierSessionID,
			&i.CustomerID,
			&i.OrderNumber,
			&i.OrderSource,
			&i.Status,
			&i.Subtotal,
			&i.DiscountAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.AmountPaid,
			&i.ChangeGiven,
			&i.Notes,
			&i.PosTransactionID,
			&i.OrderedAt,
			&i.ConfirmedAt,
			&i.ServedAt,
			&i.PaidAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRestaurantOrder = `-- name: UpdateRestaurantOrder :one
UPDATE restaurant_orders
SET
    table_id = $2,
    cashier_id = $3,
    cashier_session_id = $4,
    customer_id = $5,
    status = $6,
    subtotal = $7,
    discount_amount = $8,
    tax_amount = $9,
    total_amount = $10,
    amount_paid = $11,
    change_given = $12,
    notes = $13,
    pos_transaction_id = $14,
    confirmed_at = $15,
    served_at = $16,
    paid_at = $17,
    metadata = $18,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, store_id, table_id, cashier_id, cashier_session_id, customer_id, order_number, order_source, status, subtotal, discount_amount, tax_amount, total_amount, amount_paid, change_given, notes, pos_transaction_id, ordered_at, confirmed_at, served_at, paid_at, metadata, created_at, updated_at
`

type UpdateRestaurantOrderParams struct {
	ID               int32            `json:"id"`
	TableID          pgtype.Int4      `json:"table_id"`
	CashierID        pgtype.Int4      `json:"cashier_id"`
	CashierSessionID pgtype.Int4      `json:"cashier_session_id"`
	CustomerID       pgtype.Int4      `json:"customer_id"`
	Status           string           `json:"status"`
	Subtotal         pgtype.Numeric   `json:"subtotal"`
	DiscountAmount   pgtype.Numeric   `json:"discount_amount"`
	TaxAmount        pgtype.Numeric   `json:"tax_amount"`
	TotalAmount      pgtype.Numeric   `json:"total_amount"`
	AmountPaid       pgtype.Numeric   `json:"amount_paid"`
	ChangeGiven      pgtype.Numeric   `json:"change_given"`
	Notes            pgtype.Text      `json:"notes"`
	PosTransactionID pgtype.Int4      `json:"pos_transaction_id"`
	ConfirmedAt      pgtype.Timestamp `json:"confirmed_at"`
	ServedAt         pgtype.Timestamp `json:"served_at"`
	PaidAt           pgtype.Timestamp `json:"paid_at"`
	Metadata         []byte           `json:"metadata"`
}

func (q *Queries) UpdateRestaurantOrder(ctx context.Context, arg UpdateRestaurantOrderParams) (RestaurantOrder, error) {
	row := q.db.QueryRow(ctx, updateRestaurantOrder,
		arg.ID,
		arg.TableID,
		arg.CashierID,
		arg.CashierSessionID,
		arg.CustomerID,
		arg.Status,
		arg.Subtotal,
		arg.DiscountAmount,
		arg.TaxAmount,
		arg.TotalAmount,
		arg.AmountPaid,
		arg.ChangeGiven,
		arg.Notes,
		arg.PosTransactionID,
		arg.ConfirmedAt,
		arg.ServedAt,
		arg.PaidAt,
		arg.Metadata,
	)
	var i RestaurantOrder
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.TableID,
		&i.CashierID,
		&i.CashierSessionID,
		&i.CustomerID,
		&i.OrderNumber,
		&i.OrderSource,
		&i.Status,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.AmountPaid,
		&i.ChangeGiven,
		&i.Notes,
		&i.PosTransactionID,
		&i.OrderedAt,
		&i.ConfirmedAt,
		&i.ServedAt,
		&i.PaidAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRestaurantOrderStatus = `-- name: UpdateRestaurantOrderStatus :one
UPDATE restaurant_orders
SET
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, store_id, table_id, cashier_id, cashier_session_id, customer_id, order_number, order_source, status, subtotal, discount_amount, tax_amount, total_amount, amount_paid, change_given, notes, pos_transaction_id, ordered_at, confirmed_at, served_at, paid_at, metadata, created_at, updated_at
`

type UpdateRestaurantOrderStatusParams struct {
	ID     int32  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateRestaurantOrderStatus(ctx context.Context, arg UpdateRestaurantOrderStatusParams) (RestaurantOrder, error) {
	row := q.db.QueryRow(ctx, updateRestaurantOrderStatus, arg.ID, arg.Status)
	var i RestaurantOrder
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.TableID,
		&i.CashierID,
		&i.CashierSessionID,
		&i.CustomerID,
		&i.OrderNumber,
		&i.OrderSource,
		&i.Status,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.AmountPaid,
		&i.ChangeGiven,
		&i.Notes,
		&i.PosTransactionID,
		&i.OrderedAt,
		&i.ConfirmedAt,
		&i.ServedAt,
		&i.PaidAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
