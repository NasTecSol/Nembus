// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: profit_loss_analytics_query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProfitLossAnalytics = `-- name: CreateProfitLossAnalytics :one
INSERT INTO profit_loss_analytics (
    organization_id,
    store_id,
    date,
    period_type,
    month,
    quarter,
    year,
    gross_revenue,
    sales_discounts,
    sales_returns,
    net_revenue,
    opening_inventory_value,
    purchases,
    closing_inventory_value,
    cogs,
    gross_profit,
    gross_profit_margin,
    total_expenses,
    net_profit,
    net_profit_margin,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21
) RETURNING id, organization_id, store_id, date, period_type, month, quarter, year, gross_revenue, sales_discounts, sales_returns, net_revenue, opening_inventory_value, purchases, closing_inventory_value, cogs, gross_profit, gross_profit_margin, total_expenses, net_profit, net_profit_margin, metadata, created_at, updated_at
`

type CreateProfitLossAnalyticsParams struct {
	OrganizationID        int32          `json:"organization_id"`
	StoreID               pgtype.Int4    `json:"store_id"`
	Date                  pgtype.Date    `json:"date"`
	PeriodType            pgtype.Text    `json:"period_type"`
	Month                 pgtype.Int4    `json:"month"`
	Quarter               pgtype.Int4    `json:"quarter"`
	Year                  pgtype.Int4    `json:"year"`
	GrossRevenue          pgtype.Numeric `json:"gross_revenue"`
	SalesDiscounts        pgtype.Numeric `json:"sales_discounts"`
	SalesReturns          pgtype.Numeric `json:"sales_returns"`
	NetRevenue            pgtype.Numeric `json:"net_revenue"`
	OpeningInventoryValue pgtype.Numeric `json:"opening_inventory_value"`
	Purchases             pgtype.Numeric `json:"purchases"`
	ClosingInventoryValue pgtype.Numeric `json:"closing_inventory_value"`
	Cogs                  pgtype.Numeric `json:"cogs"`
	GrossProfit           pgtype.Numeric `json:"gross_profit"`
	GrossProfitMargin     pgtype.Numeric `json:"gross_profit_margin"`
	TotalExpenses         pgtype.Numeric `json:"total_expenses"`
	NetProfit             pgtype.Numeric `json:"net_profit"`
	NetProfitMargin       pgtype.Numeric `json:"net_profit_margin"`
	Metadata              []byte         `json:"metadata"`
}

func (q *Queries) CreateProfitLossAnalytics(ctx context.Context, arg CreateProfitLossAnalyticsParams) (ProfitLossAnalytic, error) {
	row := q.db.QueryRow(ctx, createProfitLossAnalytics,
		arg.OrganizationID,
		arg.StoreID,
		arg.Date,
		arg.PeriodType,
		arg.Month,
		arg.Quarter,
		arg.Year,
		arg.GrossRevenue,
		arg.SalesDiscounts,
		arg.SalesReturns,
		arg.NetRevenue,
		arg.OpeningInventoryValue,
		arg.Purchases,
		arg.ClosingInventoryValue,
		arg.Cogs,
		arg.GrossProfit,
		arg.GrossProfitMargin,
		arg.TotalExpenses,
		arg.NetProfit,
		arg.NetProfitMargin,
		arg.Metadata,
	)
	var i ProfitLossAnalytic
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.StoreID,
		&i.Date,
		&i.PeriodType,
		&i.Month,
		&i.Quarter,
		&i.Year,
		&i.GrossRevenue,
		&i.SalesDiscounts,
		&i.SalesReturns,
		&i.NetRevenue,
		&i.OpeningInventoryValue,
		&i.Purchases,
		&i.ClosingInventoryValue,
		&i.Cogs,
		&i.GrossProfit,
		&i.GrossProfitMargin,
		&i.TotalExpenses,
		&i.NetProfit,
		&i.NetProfitMargin,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProfitLossAnalytics = `-- name: DeleteProfitLossAnalytics :exec
DELETE FROM profit_loss_analytics
WHERE id = $1
`

func (q *Queries) DeleteProfitLossAnalytics(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProfitLossAnalytics, id)
	return err
}

const getProfitLossAnalytics = `-- name: GetProfitLossAnalytics :one
SELECT id, organization_id, store_id, date, period_type, month, quarter, year, gross_revenue, sales_discounts, sales_returns, net_revenue, opening_inventory_value, purchases, closing_inventory_value, cogs, gross_profit, gross_profit_margin, total_expenses, net_profit, net_profit_margin, metadata, created_at, updated_at FROM profit_loss_analytics
WHERE id = $1
`

func (q *Queries) GetProfitLossAnalytics(ctx context.Context, id int32) (ProfitLossAnalytic, error) {
	row := q.db.QueryRow(ctx, getProfitLossAnalytics, id)
	var i ProfitLossAnalytic
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.StoreID,
		&i.Date,
		&i.PeriodType,
		&i.Month,
		&i.Quarter,
		&i.Year,
		&i.GrossRevenue,
		&i.SalesDiscounts,
		&i.SalesReturns,
		&i.NetRevenue,
		&i.OpeningInventoryValue,
		&i.Purchases,
		&i.ClosingInventoryValue,
		&i.Cogs,
		&i.GrossProfit,
		&i.GrossProfitMargin,
		&i.TotalExpenses,
		&i.NetProfit,
		&i.NetProfitMargin,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProfitLossAnalyticsByDateRange = `-- name: GetProfitLossAnalyticsByDateRange :many
SELECT id, organization_id, store_id, date, period_type, month, quarter, year, gross_revenue, sales_discounts, sales_returns, net_revenue, opening_inventory_value, purchases, closing_inventory_value, cogs, gross_profit, gross_profit_margin, total_expenses, net_profit, net_profit_margin, metadata, created_at, updated_at FROM profit_loss_analytics
WHERE organization_id = $1
  AND date >= $2 AND date <= $3
ORDER BY date DESC
`

type GetProfitLossAnalyticsByDateRangeParams struct {
	OrganizationID int32       `json:"organization_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

func (q *Queries) GetProfitLossAnalyticsByDateRange(ctx context.Context, arg GetProfitLossAnalyticsByDateRangeParams) ([]ProfitLossAnalytic, error) {
	rows, err := q.db.Query(ctx, getProfitLossAnalyticsByDateRange, arg.OrganizationID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProfitLossAnalytic
	for rows.Next() {
		var i ProfitLossAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.Date,
			&i.PeriodType,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.GrossRevenue,
			&i.SalesDiscounts,
			&i.SalesReturns,
			&i.NetRevenue,
			&i.OpeningInventoryValue,
			&i.Purchases,
			&i.ClosingInventoryValue,
			&i.Cogs,
			&i.GrossProfit,
			&i.GrossProfitMargin,
			&i.TotalExpenses,
			&i.NetProfit,
			&i.NetProfitMargin,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfitLossAnalyticsByPeriod = `-- name: GetProfitLossAnalyticsByPeriod :many
SELECT id, organization_id, store_id, date, period_type, month, quarter, year, gross_revenue, sales_discounts, sales_returns, net_revenue, opening_inventory_value, purchases, closing_inventory_value, cogs, gross_profit, gross_profit_margin, total_expenses, net_profit, net_profit_margin, metadata, created_at, updated_at FROM profit_loss_analytics
WHERE organization_id = $1 AND period_type = $2
  AND date >= $3 AND date <= $4
ORDER BY date DESC
`

type GetProfitLossAnalyticsByPeriodParams struct {
	OrganizationID int32       `json:"organization_id"`
	PeriodType     pgtype.Text `json:"period_type"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

func (q *Queries) GetProfitLossAnalyticsByPeriod(ctx context.Context, arg GetProfitLossAnalyticsByPeriodParams) ([]ProfitLossAnalytic, error) {
	rows, err := q.db.Query(ctx, getProfitLossAnalyticsByPeriod,
		arg.OrganizationID,
		arg.PeriodType,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProfitLossAnalytic
	for rows.Next() {
		var i ProfitLossAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.Date,
			&i.PeriodType,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.GrossRevenue,
			&i.SalesDiscounts,
			&i.SalesReturns,
			&i.NetRevenue,
			&i.OpeningInventoryValue,
			&i.Purchases,
			&i.ClosingInventoryValue,
			&i.Cogs,
			&i.GrossProfit,
			&i.GrossProfitMargin,
			&i.TotalExpenses,
			&i.NetProfit,
			&i.NetProfitMargin,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfitLossAnalyticsByStore = `-- name: GetProfitLossAnalyticsByStore :many
SELECT id, organization_id, store_id, date, period_type, month, quarter, year, gross_revenue, sales_discounts, sales_returns, net_revenue, opening_inventory_value, purchases, closing_inventory_value, cogs, gross_profit, gross_profit_margin, total_expenses, net_profit, net_profit_margin, metadata, created_at, updated_at FROM profit_loss_analytics
WHERE organization_id = $1 AND store_id = $2
  AND date >= $3 AND date <= $4
ORDER BY date DESC
`

type GetProfitLossAnalyticsByStoreParams struct {
	OrganizationID int32       `json:"organization_id"`
	StoreID        pgtype.Int4 `json:"store_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

func (q *Queries) GetProfitLossAnalyticsByStore(ctx context.Context, arg GetProfitLossAnalyticsByStoreParams) ([]ProfitLossAnalytic, error) {
	rows, err := q.db.Query(ctx, getProfitLossAnalyticsByStore,
		arg.OrganizationID,
		arg.StoreID,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProfitLossAnalytic
	for rows.Next() {
		var i ProfitLossAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.Date,
			&i.PeriodType,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.GrossRevenue,
			&i.SalesDiscounts,
			&i.SalesReturns,
			&i.NetRevenue,
			&i.OpeningInventoryValue,
			&i.Purchases,
			&i.ClosingInventoryValue,
			&i.Cogs,
			&i.GrossProfit,
			&i.GrossProfitMargin,
			&i.TotalExpenses,
			&i.NetProfit,
			&i.NetProfitMargin,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfitLossSummaryByMonth = `-- name: GetProfitLossSummaryByMonth :many
SELECT 
    year,
    month,
    SUM(gross_revenue) AS total_gross_revenue,
    SUM(net_revenue) AS total_net_revenue,
    SUM(cogs) AS total_cogs,
    SUM(gross_profit) AS total_gross_profit,
    AVG(gross_profit_margin) AS avg_gross_profit_margin,
    SUM(total_expenses) AS total_expenses,
    SUM(net_profit) AS total_net_profit,
    AVG(net_profit_margin) AS avg_net_profit_margin
FROM profit_loss_analytics
WHERE organization_id = $1
  AND date >= $2 AND date <= $3
GROUP BY year, month
ORDER BY year DESC, month DESC
`

type GetProfitLossSummaryByMonthParams struct {
	OrganizationID int32       `json:"organization_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

type GetProfitLossSummaryByMonthRow struct {
	Year                 pgtype.Int4 `json:"year"`
	Month                pgtype.Int4 `json:"month"`
	TotalGrossRevenue    int64       `json:"total_gross_revenue"`
	TotalNetRevenue      int64       `json:"total_net_revenue"`
	TotalCogs            int64       `json:"total_cogs"`
	TotalGrossProfit     int64       `json:"total_gross_profit"`
	AvgGrossProfitMargin float64     `json:"avg_gross_profit_margin"`
	TotalExpenses        int64       `json:"total_expenses"`
	TotalNetProfit       int64       `json:"total_net_profit"`
	AvgNetProfitMargin   float64     `json:"avg_net_profit_margin"`
}

func (q *Queries) GetProfitLossSummaryByMonth(ctx context.Context, arg GetProfitLossSummaryByMonthParams) ([]GetProfitLossSummaryByMonthRow, error) {
	rows, err := q.db.Query(ctx, getProfitLossSummaryByMonth, arg.OrganizationID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfitLossSummaryByMonthRow
	for rows.Next() {
		var i GetProfitLossSummaryByMonthRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalGrossRevenue,
			&i.TotalNetRevenue,
			&i.TotalCogs,
			&i.TotalGrossProfit,
			&i.AvgGrossProfitMargin,
			&i.TotalExpenses,
			&i.TotalNetProfit,
			&i.AvgNetProfitMargin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfitLossSummaryByQuarter = `-- name: GetProfitLossSummaryByQuarter :many
SELECT 
    year,
    quarter,
    SUM(gross_revenue) AS total_gross_revenue,
    SUM(net_revenue) AS total_net_revenue,
    SUM(cogs) AS total_cogs,
    SUM(gross_profit) AS total_gross_profit,
    SUM(net_profit) AS total_net_profit
FROM profit_loss_analytics
WHERE organization_id = $1
  AND date >= $2 AND date <= $3
GROUP BY year, quarter
ORDER BY year DESC, quarter DESC
`

type GetProfitLossSummaryByQuarterParams struct {
	OrganizationID int32       `json:"organization_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

type GetProfitLossSummaryByQuarterRow struct {
	Year              pgtype.Int4 `json:"year"`
	Quarter           pgtype.Int4 `json:"quarter"`
	TotalGrossRevenue int64       `json:"total_gross_revenue"`
	TotalNetRevenue   int64       `json:"total_net_revenue"`
	TotalCogs         int64       `json:"total_cogs"`
	TotalGrossProfit  int64       `json:"total_gross_profit"`
	TotalNetProfit    int64       `json:"total_net_profit"`
}

func (q *Queries) GetProfitLossSummaryByQuarter(ctx context.Context, arg GetProfitLossSummaryByQuarterParams) ([]GetProfitLossSummaryByQuarterRow, error) {
	rows, err := q.db.Query(ctx, getProfitLossSummaryByQuarter, arg.OrganizationID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfitLossSummaryByQuarterRow
	for rows.Next() {
		var i GetProfitLossSummaryByQuarterRow
		if err := rows.Scan(
			&i.Year,
			&i.Quarter,
			&i.TotalGrossRevenue,
			&i.TotalNetRevenue,
			&i.TotalCogs,
			&i.TotalGrossProfit,
			&i.TotalNetProfit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfitLossSummaryByYear = `-- name: GetProfitLossSummaryByYear :many
SELECT 
    year,
    SUM(gross_revenue) AS total_gross_revenue,
    SUM(net_revenue) AS total_net_revenue,
    SUM(cogs) AS total_cogs,
    SUM(gross_profit) AS total_gross_profit,
    SUM(net_profit) AS total_net_profit
FROM profit_loss_analytics
WHERE organization_id = $1
  AND date >= $2 AND date <= $3
GROUP BY year
ORDER BY year DESC
`

type GetProfitLossSummaryByYearParams struct {
	OrganizationID int32       `json:"organization_id"`
	Date           pgtype.Date `json:"date"`
	Date_2         pgtype.Date `json:"date_2"`
}

type GetProfitLossSummaryByYearRow struct {
	Year              pgtype.Int4 `json:"year"`
	TotalGrossRevenue int64       `json:"total_gross_revenue"`
	TotalNetRevenue   int64       `json:"total_net_revenue"`
	TotalCogs         int64       `json:"total_cogs"`
	TotalGrossProfit  int64       `json:"total_gross_profit"`
	TotalNetProfit    int64       `json:"total_net_profit"`
}

func (q *Queries) GetProfitLossSummaryByYear(ctx context.Context, arg GetProfitLossSummaryByYearParams) ([]GetProfitLossSummaryByYearRow, error) {
	rows, err := q.db.Query(ctx, getProfitLossSummaryByYear, arg.OrganizationID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfitLossSummaryByYearRow
	for rows.Next() {
		var i GetProfitLossSummaryByYearRow
		if err := rows.Scan(
			&i.Year,
			&i.TotalGrossRevenue,
			&i.TotalNetRevenue,
			&i.TotalCogs,
			&i.TotalGrossProfit,
			&i.TotalNetProfit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfitLossAnalytics = `-- name: ListProfitLossAnalytics :many
SELECT id, organization_id, store_id, date, period_type, month, quarter, year, gross_revenue, sales_discounts, sales_returns, net_revenue, opening_inventory_value, purchases, closing_inventory_value, cogs, gross_profit, gross_profit_margin, total_expenses, net_profit, net_profit_margin, metadata, created_at, updated_at FROM profit_loss_analytics
WHERE organization_id = $1
ORDER BY date DESC
LIMIT $2 OFFSET $3
`

type ListProfitLossAnalyticsParams struct {
	OrganizationID int32 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

func (q *Queries) ListProfitLossAnalytics(ctx context.Context, arg ListProfitLossAnalyticsParams) ([]ProfitLossAnalytic, error) {
	rows, err := q.db.Query(ctx, listProfitLossAnalytics, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProfitLossAnalytic
	for rows.Next() {
		var i ProfitLossAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.StoreID,
			&i.Date,
			&i.PeriodType,
			&i.Month,
			&i.Quarter,
			&i.Year,
			&i.GrossRevenue,
			&i.SalesDiscounts,
			&i.SalesReturns,
			&i.NetRevenue,
			&i.OpeningInventoryValue,
			&i.Purchases,
			&i.ClosingInventoryValue,
			&i.Cogs,
			&i.GrossProfit,
			&i.GrossProfitMargin,
			&i.TotalExpenses,
			&i.NetProfit,
			&i.NetProfitMargin,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProfitLossAnalytics = `-- name: UpdateProfitLossAnalytics :one
UPDATE profit_loss_analytics
SET 
    gross_revenue = $2,
    sales_discounts = $3,
    sales_returns = $4,
    net_revenue = $5,
    opening_inventory_value = $6,
    purchases = $7,
    closing_inventory_value = $8,
    cogs = $9,
    gross_profit = $10,
    gross_profit_margin = $11,
    total_expenses = $12,
    net_profit = $13,
    net_profit_margin = $14,
    metadata = $15
WHERE id = $1
RETURNING id, organization_id, store_id, date, period_type, month, quarter, year, gross_revenue, sales_discounts, sales_returns, net_revenue, opening_inventory_value, purchases, closing_inventory_value, cogs, gross_profit, gross_profit_margin, total_expenses, net_profit, net_profit_margin, metadata, created_at, updated_at
`

type UpdateProfitLossAnalyticsParams struct {
	ID                    int32          `json:"id"`
	GrossRevenue          pgtype.Numeric `json:"gross_revenue"`
	SalesDiscounts        pgtype.Numeric `json:"sales_discounts"`
	SalesReturns          pgtype.Numeric `json:"sales_returns"`
	NetRevenue            pgtype.Numeric `json:"net_revenue"`
	OpeningInventoryValue pgtype.Numeric `json:"opening_inventory_value"`
	Purchases             pgtype.Numeric `json:"purchases"`
	ClosingInventoryValue pgtype.Numeric `json:"closing_inventory_value"`
	Cogs                  pgtype.Numeric `json:"cogs"`
	GrossProfit           pgtype.Numeric `json:"gross_profit"`
	GrossProfitMargin     pgtype.Numeric `json:"gross_profit_margin"`
	TotalExpenses         pgtype.Numeric `json:"total_expenses"`
	NetProfit             pgtype.Numeric `json:"net_profit"`
	NetProfitMargin       pgtype.Numeric `json:"net_profit_margin"`
	Metadata              []byte         `json:"metadata"`
}

func (q *Queries) UpdateProfitLossAnalytics(ctx context.Context, arg UpdateProfitLossAnalyticsParams) (ProfitLossAnalytic, error) {
	row := q.db.QueryRow(ctx, updateProfitLossAnalytics,
		arg.ID,
		arg.GrossRevenue,
		arg.SalesDiscounts,
		arg.SalesReturns,
		arg.NetRevenue,
		arg.OpeningInventoryValue,
		arg.Purchases,
		arg.ClosingInventoryValue,
		arg.Cogs,
		arg.GrossProfit,
		arg.GrossProfitMargin,
		arg.TotalExpenses,
		arg.NetProfit,
		arg.NetProfitMargin,
		arg.Metadata,
	)
	var i ProfitLossAnalytic
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.StoreID,
		&i.Date,
		&i.PeriodType,
		&i.Month,
		&i.Quarter,
		&i.Year,
		&i.GrossRevenue,
		&i.SalesDiscounts,
		&i.SalesReturns,
		&i.NetRevenue,
		&i.OpeningInventoryValue,
		&i.Purchases,
		&i.ClosingInventoryValue,
		&i.Cogs,
		&i.GrossProfit,
		&i.GrossProfitMargin,
		&i.TotalExpenses,
		&i.NetProfit,
		&i.NetProfitMargin,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
