// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: modules.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createModule = `-- name: CreateModule :one

INSERT INTO modules (
    name, code, description, icon, is_active, display_order, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, name, code, description, icon, is_active, display_order, metadata, created_at, updated_at
`

type CreateModuleParams struct {
	Name         string      `json:"name"`
	Code         string      `json:"code"`
	Description  pgtype.Text `json:"description"`
	Icon         pgtype.Text `json:"icon"`
	IsActive     pgtype.Bool `json:"is_active"`
	DisplayOrder pgtype.Int4 `json:"display_order"`
	Metadata     []byte      `json:"metadata"`
}

// =====================================================
// MODULES
// =====================================================
func (q *Queries) CreateModule(ctx context.Context, arg CreateModuleParams) (Module, error) {
	row := q.db.QueryRow(ctx, createModule,
		arg.Name,
		arg.Code,
		arg.Description,
		arg.Icon,
		arg.IsActive,
		arg.DisplayOrder,
		arg.Metadata,
	)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Description,
		&i.Icon,
		&i.IsActive,
		&i.DisplayOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteModule = `-- name: DeleteModule :exec
DELETE FROM modules WHERE id = $1
`

func (q *Queries) DeleteModule(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteModule, id)
	return err
}

const getFullNavigationHierarchy = `-- name: GetFullNavigationHierarchy :many



SELECT 
    m.id as module_id,
    m.name as module_name,
    m.code as module_code,
    m.icon as module_icon,
    m.display_order as module_order,
    mn.id as menu_id,
    mn.name as menu_name,
    mn.code as menu_code,
    mn.route_path as menu_route,
    mn.icon as menu_icon,
    mn.display_order as menu_order,
    sm.id as submenu_id,
    sm.name as submenu_name,
    sm.code as submenu_code,
    sm.route_path as submenu_route,
    sm.icon as submenu_icon,
    sm.display_order as submenu_order
FROM modules m
LEFT JOIN menus mn ON m.id = mn.module_id AND mn.is_active = true
LEFT JOIN submenus sm ON mn.id = sm.menu_id AND sm.is_active = true
WHERE m.is_active = true
ORDER BY m.display_order, mn.display_order, sm.display_order
`

type GetFullNavigationHierarchyRow struct {
	ModuleID     int32       `json:"module_id"`
	ModuleName   string      `json:"module_name"`
	ModuleCode   string      `json:"module_code"`
	ModuleIcon   pgtype.Text `json:"module_icon"`
	ModuleOrder  pgtype.Int4 `json:"module_order"`
	MenuID       pgtype.Int4 `json:"menu_id"`
	MenuName     pgtype.Text `json:"menu_name"`
	MenuCode     pgtype.Text `json:"menu_code"`
	MenuRoute    pgtype.Text `json:"menu_route"`
	MenuIcon     pgtype.Text `json:"menu_icon"`
	MenuOrder    pgtype.Int4 `json:"menu_order"`
	SubmenuID    pgtype.Int4 `json:"submenu_id"`
	SubmenuName  pgtype.Text `json:"submenu_name"`
	SubmenuCode  pgtype.Text `json:"submenu_code"`
	SubmenuRoute pgtype.Text `json:"submenu_route"`
	SubmenuIcon  pgtype.Text `json:"submenu_icon"`
	SubmenuOrder pgtype.Int4 `json:"submenu_order"`
}

// =====================================================
// MENUS
// Note: Menu queries are in menus_query.sql
// =====================================================
// =====================================================
// SUBMENUS
// Note: Submenu queries are in submenus_query.sql
// =====================================================
// =====================================================
// NAVIGATION HIERARCHY QUERIES
// =====================================================
func (q *Queries) GetFullNavigationHierarchy(ctx context.Context) ([]GetFullNavigationHierarchyRow, error) {
	rows, err := q.db.Query(ctx, getFullNavigationHierarchy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFullNavigationHierarchyRow
	for rows.Next() {
		var i GetFullNavigationHierarchyRow
		if err := rows.Scan(
			&i.ModuleID,
			&i.ModuleName,
			&i.ModuleCode,
			&i.ModuleIcon,
			&i.ModuleOrder,
			&i.MenuID,
			&i.MenuName,
			&i.MenuCode,
			&i.MenuRoute,
			&i.MenuIcon,
			&i.MenuOrder,
			&i.SubmenuID,
			&i.SubmenuName,
			&i.SubmenuCode,
			&i.SubmenuRoute,
			&i.SubmenuIcon,
			&i.SubmenuOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModule = `-- name: GetModule :one
SELECT id, name, code, description, icon, is_active, display_order, metadata, created_at, updated_at FROM modules WHERE id = $1 LIMIT 1
`

func (q *Queries) GetModule(ctx context.Context, id int32) (Module, error) {
	row := q.db.QueryRow(ctx, getModule, id)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Description,
		&i.Icon,
		&i.IsActive,
		&i.DisplayOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getModuleByCode = `-- name: GetModuleByCode :one
SELECT id, name, code, description, icon, is_active, display_order, metadata, created_at, updated_at FROM modules WHERE code = $1 LIMIT 1
`

func (q *Queries) GetModuleByCode(ctx context.Context, code string) (Module, error) {
	row := q.db.QueryRow(ctx, getModuleByCode, code)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Description,
		&i.Icon,
		&i.IsActive,
		&i.DisplayOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listModules = `-- name: ListModules :many
SELECT id, name, code, description, icon, is_active, display_order, metadata, created_at, updated_at FROM modules
WHERE is_active = COALESCE($1, is_active)
ORDER BY display_order, name
`

func (q *Queries) ListModules(ctx context.Context, isActive pgtype.Bool) ([]Module, error) {
	rows, err := q.db.Query(ctx, listModules, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Module
	for rows.Next() {
		var i Module
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Description,
			&i.Icon,
			&i.IsActive,
			&i.DisplayOrder,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateModule = `-- name: UpdateModule :one
UPDATE modules
SET 
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    icon = COALESCE($3, icon),
    is_active = COALESCE($4, is_active),
    display_order = COALESCE($5, display_order),
    metadata = COALESCE($6, metadata)
WHERE id = $7
RETURNING id, name, code, description, icon, is_active, display_order, metadata, created_at, updated_at
`

type UpdateModuleParams struct {
	Name         pgtype.Text `json:"name"`
	Description  pgtype.Text `json:"description"`
	Icon         pgtype.Text `json:"icon"`
	IsActive     pgtype.Bool `json:"is_active"`
	DisplayOrder pgtype.Int4 `json:"display_order"`
	Metadata     []byte      `json:"metadata"`
	ID           int32       `json:"id"`
}

func (q *Queries) UpdateModule(ctx context.Context, arg UpdateModuleParams) (Module, error) {
	row := q.db.QueryRow(ctx, updateModule,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.IsActive,
		arg.DisplayOrder,
		arg.Metadata,
		arg.ID,
	)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Description,
		&i.Icon,
		&i.IsActive,
		&i.DisplayOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
