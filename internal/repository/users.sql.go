// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignRoleToUser = `-- name: AssignRoleToUser :one

INSERT INTO user_roles (
    user_id, role_id, metadata
) VALUES (
    $1, $2, $3
) RETURNING id, user_id, role_id, metadata, assigned_at
`

type AssignRoleToUserParams struct {
	UserID   int32  `json:"user_id"`
	RoleID   int32  `json:"role_id"`
	Metadata []byte `json:"metadata"`
}

// =====================================================
// USER ROLES
// =====================================================
func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) (UserRole, error) {
	row := q.db.QueryRow(ctx, assignRoleToUser, arg.UserID, arg.RoleID, arg.Metadata)
	var i UserRole
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoleID,
		&i.Metadata,
		&i.AssignedAt,
	)
	return i, err
}

const checkUserHasRole = `-- name: CheckUserHasRole :one
SELECT EXISTS(
    SELECT 1 FROM user_roles 
    WHERE user_id = $1 AND role_id = $2
) as has_role
`

type CheckUserHasRoleParams struct {
	UserID int32 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

func (q *Queries) CheckUserHasRole(ctx context.Context, arg CheckUserHasRoleParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserHasRole, arg.UserID, arg.RoleID)
	var has_role bool
	err := row.Scan(&has_role)
	return has_role, err
}

const checkUserHasStoreAccess = `-- name: CheckUserHasStoreAccess :one
SELECT EXISTS(
    SELECT 1 FROM user_store_access 
    WHERE user_id = $1 AND store_id = $2
) as has_access
`

type CheckUserHasStoreAccessParams struct {
	UserID  int32 `json:"user_id"`
	StoreID int32 `json:"store_id"`
}

func (q *Queries) CheckUserHasStoreAccess(ctx context.Context, arg CheckUserHasStoreAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserHasStoreAccess, arg.UserID, arg.StoreID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
WHERE organization_id = $1
  AND is_active = COALESCE($2, is_active)
`

type CountUsersParams struct {
	OrganizationID int32       `json:"organization_id"`
	IsActive       pgtype.Bool `json:"is_active"`
}

func (q *Queries) CountUsers(ctx context.Context, arg CountUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers, arg.OrganizationID, arg.IsActive)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (
    organization_id, username, email, password_hash,
    first_name, last_name, employee_code, is_active, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, organization_id, username, email, password_hash, first_name, last_name, employee_code, is_active, metadata, created_at, updated_at
`

type CreateUserParams struct {
	OrganizationID int32       `json:"organization_id"`
	Username       string      `json:"username"`
	Email          string      `json:"email"`
	PasswordHash   string      `json:"password_hash"`
	FirstName      pgtype.Text `json:"first_name"`
	LastName       pgtype.Text `json:"last_name"`
	EmployeeCode   pgtype.Text `json:"employee_code"`
	IsActive       pgtype.Bool `json:"is_active"`
	Metadata       []byte      `json:"metadata"`
}

// =====================================================
// USERS
// =====================================================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.OrganizationID,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.EmployeeCode,
		arg.IsActive,
		arg.Metadata,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.EmployeeCode,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getStoreUsers = `-- name: GetStoreUsers :many
SELECT u.id, u.organization_id, u.username, u.email, u.password_hash, u.first_name, u.last_name, u.employee_code, u.is_active, u.metadata, u.created_at, u.updated_at FROM users u
INNER JOIN user_store_access usa ON u.id = usa.user_id
WHERE usa.store_id = $1
  AND u.is_active = true
ORDER BY u.first_name, u.last_name
`

func (q *Queries) GetStoreUsers(ctx context.Context, storeID int32) ([]User, error) {
	rows, err := q.db.Query(ctx, getStoreUsers, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.FirstName,
			&i.LastName,
			&i.EmployeeCode,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, organization_id, username, email, password_hash, first_name, last_name, employee_code, is_active, metadata, created_at, updated_at FROM users WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.EmployeeCode,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, organization_id, username, email, password_hash, first_name, last_name, employee_code, is_active, metadata, created_at, updated_at FROM users WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.EmployeeCode,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmployeeCode = `-- name: GetUserByEmployeeCode :one
SELECT id, organization_id, username, email, password_hash, first_name, last_name, employee_code, is_active, metadata, created_at, updated_at FROM users 
WHERE organization_id = $1 AND employee_code = $2 
LIMIT 1
`

type GetUserByEmployeeCodeParams struct {
	OrganizationID int32       `json:"organization_id"`
	EmployeeCode   pgtype.Text `json:"employee_code"`
}

func (q *Queries) GetUserByEmployeeCode(ctx context.Context, arg GetUserByEmployeeCodeParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmployeeCode, arg.OrganizationID, arg.EmployeeCode)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.EmployeeCode,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, organization_id, username, email, password_hash, first_name, last_name, employee_code, is_active, metadata, created_at, updated_at FROM users WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.EmployeeCode,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserPrimaryStore = `-- name: GetUserPrimaryStore :one
SELECT s.id, s.organization_id, s.parent_store_id, s.name, s.code, s.store_type, s.is_warehouse, s.is_pos_enabled, s.timezone, s.is_active, s.metadata, s.created_at, s.updated_at FROM stores s
INNER JOIN user_store_access usa ON s.id = usa.store_id
WHERE usa.user_id = $1 AND usa.is_primary = true
LIMIT 1
`

func (q *Queries) GetUserPrimaryStore(ctx context.Context, userID int32) (Store, error) {
	row := q.db.QueryRow(ctx, getUserPrimaryStore, userID)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ParentStoreID,
		&i.Name,
		&i.Code,
		&i.StoreType,
		&i.IsWarehouse,
		&i.IsPosEnabled,
		&i.Timezone,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.id, r.name, r.code, r.description, r.is_system_role, r.is_active, r.metadata, r.created_at, r.updated_at FROM roles r
INNER JOIN user_roles ur ON r.id = ur.role_id
WHERE ur.user_id = $1
ORDER BY r.name
`

func (q *Queries) GetUserRoles(ctx context.Context, userID int32) ([]Role, error) {
	rows, err := q.db.Query(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Description,
			&i.IsSystemRole,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStores = `-- name: GetUserStores :many
SELECT s.id, s.organization_id, s.parent_store_id, s.name, s.code, s.store_type, s.is_warehouse, s.is_pos_enabled, s.timezone, s.is_active, s.metadata, s.created_at, s.updated_at FROM stores s
INNER JOIN user_store_access usa ON s.id = usa.store_id
WHERE usa.user_id = $1
ORDER BY usa.is_primary DESC, s.name
`

func (q *Queries) GetUserStores(ctx context.Context, userID int32) ([]Store, error) {
	rows, err := q.db.Query(ctx, getUserStores, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Store
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ParentStoreID,
			&i.Name,
			&i.Code,
			&i.StoreType,
			&i.IsWarehouse,
			&i.IsPosEnabled,
			&i.Timezone,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithDetails = `-- name: GetUserWithDetails :one

SELECT 
    u.id, u.organization_id, u.username, u.email, u.password_hash, u.first_name, u.last_name, u.employee_code, u.is_active, u.metadata, u.created_at, u.updated_at,
    json_agg(DISTINCT jsonb_build_object(
        'id', r.id,
        'name', r.name,
        'code', r.code
    )) FILTER (WHERE r.id IS NOT NULL) as roles,
    json_agg(DISTINCT jsonb_build_object(
        'id', s.id,
        'name', s.name,
        'code', s.code,
        'is_primary', usa.is_primary
    )) FILTER (WHERE s.id IS NOT NULL) as stores
FROM users u
LEFT JOIN user_roles ur ON u.id = ur.user_id
LEFT JOIN roles r ON ur.role_id = r.id
LEFT JOIN user_store_access usa ON u.id = usa.user_id
LEFT JOIN stores s ON usa.store_id = s.id
WHERE u.id = $1
GROUP BY u.id
`

type GetUserWithDetailsRow struct {
	ID             int32            `json:"id"`
	OrganizationID int32            `json:"organization_id"`
	Username       string           `json:"username"`
	Email          string           `json:"email"`
	PasswordHash   string           `json:"password_hash"`
	FirstName      pgtype.Text      `json:"first_name"`
	LastName       pgtype.Text      `json:"last_name"`
	EmployeeCode   pgtype.Text      `json:"employee_code"`
	IsActive       pgtype.Bool      `json:"is_active"`
	Metadata       []byte           `json:"metadata"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	Roles          []byte           `json:"roles"`
	Stores         []byte           `json:"stores"`
}

// =====================================================
// USER DETAILS WITH ROLES AND STORES
// =====================================================
func (q *Queries) GetUserWithDetails(ctx context.Context, id int32) (GetUserWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getUserWithDetails, id)
	var i GetUserWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.EmployeeCode,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
		&i.Stores,
	)
	return i, err
}

const getUsersWithRole = `-- name: GetUsersWithRole :many
SELECT u.id, u.organization_id, u.username, u.email, u.password_hash, u.first_name, u.last_name, u.employee_code, u.is_active, u.metadata, u.created_at, u.updated_at FROM users u
INNER JOIN user_roles ur ON u.id = ur.user_id
WHERE ur.role_id = $1
  AND u.is_active = true
ORDER BY u.first_name, u.last_name
`

func (q *Queries) GetUsersWithRole(ctx context.Context, roleID int32) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersWithRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.FirstName,
			&i.LastName,
			&i.EmployeeCode,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const grantStoreAccessToUser = `-- name: GrantStoreAccessToUser :one

INSERT INTO user_store_access (
    user_id, store_id, is_primary, metadata
) VALUES (
    $1, $2, $3, $4
) RETURNING id, user_id, store_id, is_primary, metadata, granted_at
`

type GrantStoreAccessToUserParams struct {
	UserID    int32       `json:"user_id"`
	StoreID   int32       `json:"store_id"`
	IsPrimary pgtype.Bool `json:"is_primary"`
	Metadata  []byte      `json:"metadata"`
}

// =====================================================
// USER STORE ACCESS
// =====================================================
func (q *Queries) GrantStoreAccessToUser(ctx context.Context, arg GrantStoreAccessToUserParams) (UserStoreAccess, error) {
	row := q.db.QueryRow(ctx, grantStoreAccessToUser,
		arg.UserID,
		arg.StoreID,
		arg.IsPrimary,
		arg.Metadata,
	)
	var i UserStoreAccess
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StoreID,
		&i.IsPrimary,
		&i.Metadata,
		&i.GrantedAt,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, organization_id, username, email, password_hash, first_name, last_name, employee_code, is_active, metadata, created_at, updated_at FROM users
WHERE organization_id = $1
  AND is_active = COALESCE($4, is_active)
ORDER BY first_name, last_name
LIMIT $2 OFFSET $3
`

type ListUsersParams struct {
	OrganizationID int32       `json:"organization_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	IsActive       pgtype.Bool `json:"is_active"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers,
		arg.OrganizationID,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.FirstName,
			&i.LastName,
			&i.EmployeeCode,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithDetails = `-- name: ListUsersWithDetails :many
SELECT 
    u.id, u.organization_id, u.username, u.email, u.password_hash, u.first_name, u.last_name, u.employee_code, u.is_active, u.metadata, u.created_at, u.updated_at,
    json_agg(DISTINCT jsonb_build_object(
        'id', r.id,
        'name', r.name,
        'code', r.code
    )) FILTER (WHERE r.id IS NOT NULL) as roles,
    json_agg(DISTINCT jsonb_build_object(
        'id', s.id,
        'name', s.name,
        'code', s.code,
        'is_primary', usa.is_primary
    )) FILTER (WHERE s.id IS NOT NULL) as stores
FROM users u
LEFT JOIN user_roles ur ON u.id = ur.user_id
LEFT JOIN roles r ON ur.role_id = r.id
LEFT JOIN user_store_access usa ON u.id = usa.user_id
LEFT JOIN stores s ON usa.store_id = s.id
WHERE u.organization_id = $1
  AND u.is_active = COALESCE($4, u.is_active)
GROUP BY u.id
ORDER BY u.first_name, u.last_name
LIMIT $2 OFFSET $3
`

type ListUsersWithDetailsParams struct {
	OrganizationID int32       `json:"organization_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	IsActive       pgtype.Bool `json:"is_active"`
}

type ListUsersWithDetailsRow struct {
	ID             int32            `json:"id"`
	OrganizationID int32            `json:"organization_id"`
	Username       string           `json:"username"`
	Email          string           `json:"email"`
	PasswordHash   string           `json:"password_hash"`
	FirstName      pgtype.Text      `json:"first_name"`
	LastName       pgtype.Text      `json:"last_name"`
	EmployeeCode   pgtype.Text      `json:"employee_code"`
	IsActive       pgtype.Bool      `json:"is_active"`
	Metadata       []byte           `json:"metadata"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	Roles          []byte           `json:"roles"`
	Stores         []byte           `json:"stores"`
}

func (q *Queries) ListUsersWithDetails(ctx context.Context, arg ListUsersWithDetailsParams) ([]ListUsersWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, listUsersWithDetails,
		arg.OrganizationID,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersWithDetailsRow
	for rows.Next() {
		var i ListUsersWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.FirstName,
			&i.LastName,
			&i.EmployeeCode,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Roles,
			&i.Stores,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAllRolesFromUser = `-- name: RevokeAllRolesFromUser :exec
DELETE FROM user_roles WHERE user_id = $1
`

func (q *Queries) RevokeAllRolesFromUser(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, revokeAllRolesFromUser, userID)
	return err
}

const revokeAllStoreAccessFromUser = `-- name: RevokeAllStoreAccessFromUser :exec
DELETE FROM user_store_access WHERE user_id = $1
`

func (q *Queries) RevokeAllStoreAccessFromUser(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, revokeAllStoreAccessFromUser, userID)
	return err
}

const revokeRoleFromUser = `-- name: RevokeRoleFromUser :exec
DELETE FROM user_roles 
WHERE user_id = $1 AND role_id = $2
`

type RevokeRoleFromUserParams struct {
	UserID int32 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

func (q *Queries) RevokeRoleFromUser(ctx context.Context, arg RevokeRoleFromUserParams) error {
	_, err := q.db.Exec(ctx, revokeRoleFromUser, arg.UserID, arg.RoleID)
	return err
}

const revokeStoreAccessFromUser = `-- name: RevokeStoreAccessFromUser :exec
DELETE FROM user_store_access 
WHERE user_id = $1 AND store_id = $2
`

type RevokeStoreAccessFromUserParams struct {
	UserID  int32 `json:"user_id"`
	StoreID int32 `json:"store_id"`
}

func (q *Queries) RevokeStoreAccessFromUser(ctx context.Context, arg RevokeStoreAccessFromUserParams) error {
	_, err := q.db.Exec(ctx, revokeStoreAccessFromUser, arg.UserID, arg.StoreID)
	return err
}

const searchUsers = `-- name: SearchUsers :many
SELECT id, organization_id, username, email, password_hash, first_name, last_name, employee_code, is_active, metadata, created_at, updated_at FROM users
WHERE organization_id = $1
  AND is_active = true
  AND (
    username ILIKE '%' || $2 || '%' OR
    email ILIKE '%' || $2 || '%' OR
    first_name ILIKE '%' || $2 || '%' OR
    last_name ILIKE '%' || $2 || '%' OR
    employee_code ILIKE '%' || $2 || '%'
  )
ORDER BY first_name, last_name
LIMIT $3 OFFSET $4
`

type SearchUsersParams struct {
	OrganizationID int32       `json:"organization_id"`
	Column2        pgtype.Text `json:"column_2"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsers,
		arg.OrganizationID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.FirstName,
			&i.LastName,
			&i.EmployeeCode,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setUserPrimaryStore = `-- name: SetUserPrimaryStore :exec
UPDATE user_store_access
SET is_primary = false
WHERE user_id = $1
`

// First, unset all primary flags for the user
func (q *Queries) SetUserPrimaryStore(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, setUserPrimaryStore, userID)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    email = COALESCE($1, email),
    first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    employee_code = COALESCE($4, employee_code),
    is_active = COALESCE($5, is_active),
    metadata = COALESCE($6, metadata)
WHERE id = $7
RETURNING id, organization_id, username, email, password_hash, first_name, last_name, employee_code, is_active, metadata, created_at, updated_at
`

type UpdateUserParams struct {
	Email        pgtype.Text `json:"email"`
	FirstName    pgtype.Text `json:"first_name"`
	LastName     pgtype.Text `json:"last_name"`
	EmployeeCode pgtype.Text `json:"employee_code"`
	IsActive     pgtype.Bool `json:"is_active"`
	Metadata     []byte      `json:"metadata"`
	ID           int32       `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.EmployeeCode,
		arg.IsActive,
		arg.Metadata,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.EmployeeCode,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users
SET password_hash = $2
WHERE id = $1
RETURNING id, username, email
`

type UpdateUserPasswordParams struct {
	ID           int32  `json:"id"`
	PasswordHash string `json:"password_hash"`
}

type UpdateUserPasswordRow struct {
	ID       int32  `json:"id"`
	Username string `json:"username"`
	Email    string `json:"email"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (UpdateUserPasswordRow, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	var i UpdateUserPasswordRow
	err := row.Scan(&i.ID, &i.Username, &i.Email)
	return i, err
}

const updateUserStoreAccess = `-- name: UpdateUserStoreAccess :one
UPDATE user_store_access
SET is_primary = $3, metadata = COALESCE($4, metadata)
WHERE user_id = $1 AND store_id = $2
RETURNING id, user_id, store_id, is_primary, metadata, granted_at
`

type UpdateUserStoreAccessParams struct {
	UserID    int32       `json:"user_id"`
	StoreID   int32       `json:"store_id"`
	IsPrimary pgtype.Bool `json:"is_primary"`
	Metadata  []byte      `json:"metadata"`
}

func (q *Queries) UpdateUserStoreAccess(ctx context.Context, arg UpdateUserStoreAccessParams) (UserStoreAccess, error) {
	row := q.db.QueryRow(ctx, updateUserStoreAccess,
		arg.UserID,
		arg.StoreID,
		arg.IsPrimary,
		arg.Metadata,
	)
	var i UserStoreAccess
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StoreID,
		&i.IsPrimary,
		&i.Metadata,
		&i.GrantedAt,
	)
	return i, err
}
