// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: menu_items.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMenuItem = `-- name: CreateMenuItem :one
INSERT INTO menu_items (
    store_id, menu_category_id, product_id, recipe_id, name, short_name, description, image_url, base_price, cost_price, preparation_time_min, tax_category_id, is_available, is_active, display_order, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
)
RETURNING id, store_id, menu_category_id, product_id, recipe_id, name, short_name, description, image_url, base_price, cost_price, preparation_time_min, tax_category_id, is_available, is_active, display_order, metadata, created_at, updated_at
`

type CreateMenuItemParams struct {
	StoreID            int32          `json:"store_id"`
	MenuCategoryID     int32          `json:"menu_category_id"`
	ProductID          pgtype.Int4    `json:"product_id"`
	RecipeID           pgtype.Int4    `json:"recipe_id"`
	Name               string         `json:"name"`
	ShortName          pgtype.Text    `json:"short_name"`
	Description        pgtype.Text    `json:"description"`
	ImageUrl           pgtype.Text    `json:"image_url"`
	BasePrice          pgtype.Numeric `json:"base_price"`
	CostPrice          pgtype.Numeric `json:"cost_price"`
	PreparationTimeMin pgtype.Int4    `json:"preparation_time_min"`
	TaxCategoryID      pgtype.Int4    `json:"tax_category_id"`
	IsAvailable        pgtype.Bool    `json:"is_available"`
	IsActive           pgtype.Bool    `json:"is_active"`
	DisplayOrder       pgtype.Int4    `json:"display_order"`
	Metadata           []byte         `json:"metadata"`
}

func (q *Queries) CreateMenuItem(ctx context.Context, arg CreateMenuItemParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, createMenuItem,
		arg.StoreID,
		arg.MenuCategoryID,
		arg.ProductID,
		arg.RecipeID,
		arg.Name,
		arg.ShortName,
		arg.Description,
		arg.ImageUrl,
		arg.BasePrice,
		arg.CostPrice,
		arg.PreparationTimeMin,
		arg.TaxCategoryID,
		arg.IsAvailable,
		arg.IsActive,
		arg.DisplayOrder,
		arg.Metadata,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.MenuCategoryID,
		&i.ProductID,
		&i.RecipeID,
		&i.Name,
		&i.ShortName,
		&i.Description,
		&i.ImageUrl,
		&i.BasePrice,
		&i.CostPrice,
		&i.PreparationTimeMin,
		&i.TaxCategoryID,
		&i.IsAvailable,
		&i.IsActive,
		&i.DisplayOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMenuItem = `-- name: DeleteMenuItem :exec
DELETE FROM menu_items
WHERE id = $1
`

func (q *Queries) DeleteMenuItem(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMenuItem, id)
	return err
}

const getMenuItem = `-- name: GetMenuItem :one

SELECT id, store_id, menu_category_id, product_id, recipe_id, name, short_name, description, image_url, base_price, cost_price, preparation_time_min, tax_category_id, is_available, is_active, display_order, metadata, created_at, updated_at FROM menu_items
WHERE id = $1 LIMIT 1
`

// menu_items.sql
func (q *Queries) GetMenuItem(ctx context.Context, id int32) (MenuItem, error) {
	row := q.db.QueryRow(ctx, getMenuItem, id)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.MenuCategoryID,
		&i.ProductID,
		&i.RecipeID,
		&i.Name,
		&i.ShortName,
		&i.Description,
		&i.ImageUrl,
		&i.BasePrice,
		&i.CostPrice,
		&i.PreparationTimeMin,
		&i.TaxCategoryID,
		&i.IsAvailable,
		&i.IsActive,
		&i.DisplayOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMenuItems = `-- name: ListMenuItems :many
SELECT id, store_id, menu_category_id, product_id, recipe_id, name, short_name, description, image_url, base_price, cost_price, preparation_time_min, tax_category_id, is_available, is_active, display_order, metadata, created_at, updated_at FROM menu_items
WHERE menu_category_id = $1
ORDER BY display_order, name
`

func (q *Queries) ListMenuItems(ctx context.Context, menuCategoryID int32) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, listMenuItems, menuCategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.MenuCategoryID,
			&i.ProductID,
			&i.RecipeID,
			&i.Name,
			&i.ShortName,
			&i.Description,
			&i.ImageUrl,
			&i.BasePrice,
			&i.CostPrice,
			&i.PreparationTimeMin,
			&i.TaxCategoryID,
			&i.IsAvailable,
			&i.IsActive,
			&i.DisplayOrder,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenuItemsByStore = `-- name: ListMenuItemsByStore :many
SELECT id, store_id, menu_category_id, product_id, recipe_id, name, short_name, description, image_url, base_price, cost_price, preparation_time_min, tax_category_id, is_available, is_active, display_order, metadata, created_at, updated_at FROM menu_items
WHERE store_id = $1
ORDER BY display_order, name
`

func (q *Queries) ListMenuItemsByStore(ctx context.Context, storeID int32) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, listMenuItemsByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.MenuCategoryID,
			&i.ProductID,
			&i.RecipeID,
			&i.Name,
			&i.ShortName,
			&i.Description,
			&i.ImageUrl,
			&i.BasePrice,
			&i.CostPrice,
			&i.PreparationTimeMin,
			&i.TaxCategoryID,
			&i.IsAvailable,
			&i.IsActive,
			&i.DisplayOrder,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMenuItem = `-- name: UpdateMenuItem :one
UPDATE menu_items
SET
    menu_category_id = $2,
    product_id = $3,
    recipe_id = $4,
    name = $5,
    short_name = $6,
    description = $7,
    image_url = $8,
    base_price = $9,
    cost_price = $10,
    preparation_time_min = $11,
    tax_category_id = $12,
    is_available = $13,
    is_active = $14,
    display_order = $15,
    metadata = $16,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, store_id, menu_category_id, product_id, recipe_id, name, short_name, description, image_url, base_price, cost_price, preparation_time_min, tax_category_id, is_available, is_active, display_order, metadata, created_at, updated_at
`

type UpdateMenuItemParams struct {
	ID                 int32          `json:"id"`
	MenuCategoryID     int32          `json:"menu_category_id"`
	ProductID          pgtype.Int4    `json:"product_id"`
	RecipeID           pgtype.Int4    `json:"recipe_id"`
	Name               string         `json:"name"`
	ShortName          pgtype.Text    `json:"short_name"`
	Description        pgtype.Text    `json:"description"`
	ImageUrl           pgtype.Text    `json:"image_url"`
	BasePrice          pgtype.Numeric `json:"base_price"`
	CostPrice          pgtype.Numeric `json:"cost_price"`
	PreparationTimeMin pgtype.Int4    `json:"preparation_time_min"`
	TaxCategoryID      pgtype.Int4    `json:"tax_category_id"`
	IsAvailable        pgtype.Bool    `json:"is_available"`
	IsActive           pgtype.Bool    `json:"is_active"`
	DisplayOrder       pgtype.Int4    `json:"display_order"`
	Metadata           []byte         `json:"metadata"`
}

func (q *Queries) UpdateMenuItem(ctx context.Context, arg UpdateMenuItemParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, updateMenuItem,
		arg.ID,
		arg.MenuCategoryID,
		arg.ProductID,
		arg.RecipeID,
		arg.Name,
		arg.ShortName,
		arg.Description,
		arg.ImageUrl,
		arg.BasePrice,
		arg.CostPrice,
		arg.PreparationTimeMin,
		arg.TaxCategoryID,
		arg.IsAvailable,
		arg.IsActive,
		arg.DisplayOrder,
		arg.Metadata,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.MenuCategoryID,
		&i.ProductID,
		&i.RecipeID,
		&i.Name,
		&i.ShortName,
		&i.Description,
		&i.ImageUrl,
		&i.BasePrice,
		&i.CostPrice,
		&i.PreparationTimeMin,
		&i.TaxCategoryID,
		&i.IsAvailable,
		&i.IsActive,
		&i.DisplayOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
